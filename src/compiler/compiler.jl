# based on GPUCompiler example https://github.com/JuliaGPU/GPUCompiler.jl/blob/master/examples/kernel.jl
module IPUCompiler

export @codelet, @ipuprogram, VertexVector, In, Out, InOut, get_scount_l, get_tile_id

include("output.jl")

using GPUCompiler
using ..Poplar

# list of overrides (only for Julia 1.6)
const overrides = Expr[]

struct IPUCompilerParams <: AbstractCompilerParams
    kernel_name::String
end

# local method table for device functions
@static if isdefined(Base.Experimental, Symbol("@overlay"))
Base.Experimental.@MethodTable(method_table)
else
const method_table = nothing
end
# the method table to use
GPUCompiler.method_table(::CompilerJob{<:Any,IPUCompilerParams}) = method_table

macro device_override(ex)
    ex = macroexpand(__module__, ex)
    if Meta.isexpr(ex, :call)
        ex = eval(ex)
        error()
    end
    code = quote
        $GPUCompiler.@override($method_table, $ex)
    end
    if isdefined(Base.Experimental, Symbol("@overlay"))
        return esc(code)
    else
        push!(overrides, code)
        return
    end
end

macro device_function(ex)
    ex = macroexpand(__module__, ex)
    def = splitdef(ex)

    # generate a function that errors
    def[:body] = quote
        error("This function is not intended for use on the CPU")
    end

    esc(quote
        $(combinedef(def))
        @device_override $ex
    end)
end

# Functions needed by the runtime
function get_scount_l end
function get_tile_id end

include("runtime.jl")
include("vertexvectors.jl")

GPUCompiler.runtime_module(::CompilerJob{<:Any,IPUCompilerParams}) = IPURuntime
# `GPUCompiler.isintrinsic` specifies functions which are to be considered intrinsics for
# the current job, and so don't have to be validated by the compilation pipeline.  We set
# `getVec$(kernel_name)` to be considered intrinsic, as this is implemented in the
# accompanying C++ codelet, so outside of the LLVM IR generated by GPUCompiler.
GPUCompiler.isintrinsic(@nospecialize(job::CompilerJob{<:Any,IPUCompilerParams}), fn::String) =
    contains(fn, Regex("^get_vec_(ptr|size)_" * job.config.params.kernel_name * "\$")) ||
    fn âˆˆ ("printf", "puts", "tanf") || startswith(fn, "_llvm_colossus_")

include("codelet.jl")
include("tensors.jl")
include("program.jl")
include("timing.jl")

# Mapping of the LLVM version used by each version of the Poplar SDK.  To find it, use `popc
# --version`.
const POPLAR_SDK_LLVM_MAPPING = Dict(
    v"1.3.0" => v"11.0.0",
    v"1.4.0" => v"11.0.0",
    v"2.0.0" => v"11.0.0",
    v"2.1.0" => v"13.0.0",
    v"2.2.0" => v"13.0.0",
    v"2.3.0" => v"14.0.0",
    v"2.4.0" => v"14.0.0",
    v"2.5.0" => v"14.0.0",
    v"2.6.0" => v"15.0.0",
    v"3.0.0" => v"15.0.0",
)

function __init__()
    sdk_llvm_version = POPLAR_SDK_LLVM_MAPPING[Base.thisminor(Poplar.SDK_VERSION)]
    if sdk_llvm_version != Base.thismajor(Base.libllvm_version)
        @warn """
              You are using Poplar SDK v$(Poplar.SDK_VERSION) which is coupled to LLVM v$(sdk_llvm_version), but your Julia uses LLVM v$(Base.libllvm_version).
              IPUCompiler code generation may not work correctly.
              """
    end
end

end # module IPUCompiler
