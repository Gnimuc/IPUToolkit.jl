var documenterSearchIndex = {"docs":
[{"location":"compiler/#Writing-codelets-in-Julia","page":"Writing codelets","title":"Writing codelets in Julia","text":"","category":"section"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"The IPUToolkit.IPUCompiler submodule allows you to write codelets for the IPU in Julia. Codelets are defined with the @codelet macro, and then you can use them inside a program, written using the interface to the Poplar SDK described before. This mechanism uses the GPUCompiler.jl package, which is a generic framework for generating LLVM IR code for specialised targets, not limited to GPUs despite the historical name.","category":"page"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"Examples of codelets written in Julia are shown in the files examples/main.jl, examples/adam.jl, and examples/pi.jl.","category":"page"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"The code inside a codelet has the same limitations as all the compilation models based on GPUCompiler.jl:","category":"page"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"the code has to be statically inferred and compiled, dynamic dispatch is not admitted;\nyou cannot use functionalities which require the Julia runtime, most notably the garbage collector;\nyou cannot call into any other external binary library at runtime, for example you cannot call into a BLAS library.","category":"page"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"After defining a codelet with @codelet you can add a vertex calling this codelet to the graph with the function add_vertex, which also allows controlling the tile mapping in a basic way.","category":"page"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"@codelet\nVertexVector\nVertexScalar\nadd_vertex\nIPUCompiler.KEEP_LLVM_FILES\nIPUCompiler.POPC_FLAGS\nIPUCompiler.PROGRESS_SPINNER","category":"page"},{"location":"compiler/#IPUToolkit.IPUCompiler.@codelet","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.@codelet","text":"@codelet graph <function definition>\n\nDefine a codelet and add it to the graph. The @codelet macro takes two argument:\n\nthe graph to which to add the codelet with the Poplar.GraphAddCodelets function;\nthe function definition of the codelet that you want to compile for the IPU device.\n\nAll the arguments of the function must be either VertexVectors, which represent the Vector vertex type in the Poplar SDK, or VertexScalars, which represent scalar arguments.\n\n@codelet defines the function passed as argument, generates its LLVM Intermediate Representation (IR) using GPUCompiler.jl and then compiles it down to native code using the Poplar compiler popc, which must be in PATH. By default the LLVM IR of the function is written to a temporary file, but you can choose to keep it in the current directory by customising IPUCompiler.KEEP_LLVM_FILES. You can control flags passed to the popc compiler like debug and optimisation levels or target types by customising IPUCompiler.POPC_FLAGS. During compilation of codelets a spinner is displayed to show the progress, as this step can take a few seconds for each codelet to be generated. This can be disabled by setting IPUCompiler.PROGRESS_SPINNER. All the options mentioned in this section have to be set before the @codelet invocation where you want them to have effect.\n\nThe codelet is automatically added to the graph but you will have to separately use it in a vertex, by using either the add_vertex function, or Poplar's Poplar.GraphAddVertex.\n\nExample\n\nusing IPUToolkit.IPUCompiler, IPUToolkit.Poplar\ndevice = Poplar.get_ipu_device()\ntarget = Poplar.DeviceGetTarget(device)\ngraph = Poplar.Graph(target)\n@codelet graph function test(in::VertexVector{Int32,In}, out::VertexVector{Float32,Out})\n    for idx in eachindex(out)\n        out[idx] = sin(in[idx])\n    end\nend\n\nThis snippet of code defines a codelet called test, which takes in input the vector in, whose elements are Int32s, and modifies the vector out, of type Float32, by computing the sine of the elements of in.\n\n\n\n\n\n","category":"macro"},{"location":"compiler/#IPUToolkit.IPUCompiler.VertexVector","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.VertexVector","text":"VertexVector{T, S} <: AbstractVector{T}\n\nThis datatype formally represents vectors to be used in codelets (vertices) in IPU programs. They are the counterpart of the vertex vector types in the Poplar SDK.\n\nThe parameters of VertexVector{T,S} are\n\nT: the type of the elements of the vector, e.g. Int32, Float32, etc.;\nS: the scope of the vector in the codelet, In, Out, or InOut.\n\nVertexVector is only meant to be used by end-user to define the arguments of codelets with the @codelet macro. You should not try to manually instantiate or access the fields of a VertexVector.\n\nFor scalar arguments use VertexScalar.\n\nExample\n\nVertexVector{Float32, In}    # input-only vector of `Float32` elements\nVertexVector{Int32, Out}     # output-only vector of `Int32` elements\nVertexVector{UInt32, InOut}  # input/output vector of `UInt32` elements\n\n\n\n\n\n","category":"type"},{"location":"compiler/#IPUToolkit.IPUCompiler.VertexScalar","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.VertexScalar","text":"VertexScalar{T, S}\n\nThis datatype formally represents scalars to be used in codelets (vertices) in IPU programs. Technically, these are implemented as single-element tensors.\n\nThe parameters of VertexScalar{T,S} are\n\nT: the type of the scalar, e.g. Int32, Float32, etc.;\nS: the scope of the scalar in the codelet, In, Out, or InOut.\n\nVertexScalar is only meant to be used by end-user to define the arguments of codelets with the @codelet macro. You should not try to manually instantiate or access the fields of a VertexScalar.\n\nInside a codelet you can access and set the number by unwrapping it with [].\n\nFor vector arguments use VertexVector.\n\nExample\n\nExamples of types\n\nVertexScalar{Float32, In}    # input-only `Float32` number\nVertexScalar{Int32, Out}     # output-only `Int32` number\nVertexScalar{UInt32, InOut}  # input/output `UInt32` number\n\nInside a codelet, let x have type VertexScalar, you can access its value if it has scope In or InOut with\n\n@ipushow x[]\ny = x[] / 3.14\n\nIf x has scope Out or InOut you can set its value with x[] = ...:\n\nx[] = 3.14\n\n\n\n\n\n","category":"type"},{"location":"compiler/#IPUToolkit.IPUCompiler.add_vertex","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.add_vertex","text":"add_vertex(graph::Poplar.GraphAllocated,\n           compute_set_or_program::Union{Poplar.ComputeSetAllocated, Poplar.ProgramSequenceAllocated},\n           [tiles::Union{Integer,AbstractVector{<:Integer}},]\n           codelet::Function,\n           args::Union{Number,Poplar.TensorAllocated}...) -> Nothing\n\nAdd the codelet function codelet created with @codelet to graph, using the tensors args as arguments. The function codelet must have exactly one method, no more, no less. The second argument can be either the program or the compute set to which to add the new vertex/vertices. If a program is passed, a new compute set will be automatically created.\n\nadd_vertex also evenly maps all tensors and vertices across all tiles, which can be either a single tile ID or an AbstractVector of IDs and defaults to single tile 0 if this argument is omitted. Note that all argument tensors args must be longer than or equal to the number of tiles. If you want to have better control over tile mapping, do not use add_vertex.\n\n\n\n\n\n","category":"function"},{"location":"compiler/#IPUToolkit.IPUCompiler.KEEP_LLVM_FILES","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.KEEP_LLVM_FILES","text":"IPUToolkit.IPUCompiler.KEEP_LLVM_FILES::Base.RefValue{Bool}\n\nOption to control whether to keep in the current directory the files with the LLVM Intermediate Representation (IR) generated for the codelets.\n\nExample\n\nIPUToolkit.IPUCompiler.KEEP_LLVM_FILES[] = false # Generated LLVM IR files are automatically deleted after compilation, default\nIPUToolkit.IPUCompiler.KEEP_LLVM_FILES[] = true  # Generated LLVM IR files are kept in the current directory\n\n\n\n\n\n","category":"constant"},{"location":"compiler/#IPUToolkit.IPUCompiler.POPC_FLAGS","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.POPC_FLAGS","text":"IPUToolkit.IPUCompiler.POPC_FLAGS::Base.RefValue{Cmd}\n\nOptions to pass to the popc compiler to compile the code.\n\nExample\n\nIPUToolkit.IPUCompiler.POPC_FLAGS = `-O3 -g0 -target ipu2`\nIPUToolkit.IPUCompiler.POPC_FLAGS = `-O2 -g`\n\n\n\n\n\n","category":"constant"},{"location":"compiler/#IPUToolkit.IPUCompiler.PROGRESS_SPINNER","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.PROGRESS_SPINNER","text":"IPUToolkit.IPUCompiler.PROGRESS_SPINNER::Base.RefValue{Bool}\n\nOption to control whether to display a spinner to show progress during compilation of IPU codelets.\n\nExample\n\nIPUToolkit.IPUCompiler.PROGRESS_SPINNER[] = true  # enable spinner, default\nIPUToolkit.IPUCompiler.PROGRESS_SPINNER[] = false # disable spinner\n\n\n\n\n\n","category":"constant"},{"location":"compiler/#IPU-builtins","page":"Writing codelets","title":"IPU builtins","text":"","category":"section"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"Inside codelets defined with @codelet all calls to random functions","category":"page"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"rand(Float32)\nrand(UInt32)\nrand(UInt64)","category":"page"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"result to call to corresponding IPU builtins for random number generation, but with the general semantic of the Julia function rand (numbers uniformely distributed in the 0 1) range).","category":"page"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"Additionally, you can use the IPU builtins listed below.","category":"page"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"get_scount_l\nget_tile_id","category":"page"},{"location":"compiler/#IPUToolkit.IPUCompiler.get_scount_l","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.get_scount_l","text":"get_scount_l()\n\nCall the __builtin_ipu_get_scount_l() builtin:\n\nGet the value of the control/status register (CSR) SCOUNT_L, which is the lower 32 bits of the tile cycle counter value.\n\n\n\n\n\n","category":"function"},{"location":"compiler/#IPUToolkit.IPUCompiler.get_tile_id","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.get_tile_id","text":"get_scount_l()\n\nCall the __builtin_ipu_get_scount_l() builtin:\n\nGet the tile ID of the current tile.\n\n\n\n\n\n","category":"function"},{"location":"compiler/#Printing","page":"Writing codelets","title":"Printing","text":"","category":"section"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"Inside codelets you can print text and value of variables using the macros @ipuprintf, @ipuprint, @ipuprintln, and @ipushow. These macros are useful for debugging purposes but printing inside a codelet might incur performance penalty. To completely disable all printing and make these macros no-op you can set IPUCompiler.DISABLE_PRINT:","category":"page"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"IPUCompiler.DISABLE_PRINT[] = true","category":"page"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"@ipuprintf\n@ipuprint\n@ipuprintln\n@ipushow\nIPUCompiler.DISABLE_PRINT","category":"page"},{"location":"compiler/#IPUToolkit.IPUCompiler.@ipuprintf","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.@ipuprintf","text":"@ipuprintf(\"%Fmt\", args...)\n\nPrint a formatted string in device context on the host standard output.\n\nNote that this is not a fully C-compliant printf implementation.\n\nAlso beware that it is an untyped, and unforgiving printf implementation. Type widths need to match, eg. printing a 64-bit Julia integer requires the %ld formatting string.\n\nMore user-friendly versions of this macro are @ipuprint, @ipuprintln. See also @ipushow, which is built on top of @ipuprintf functionalities.\n\nPrinting can be completely disabled by setting\n\nIPUToolkit.IPUCompiler.DISABLE_PRINT[] = true\n\n\n\n\n\n","category":"macro"},{"location":"compiler/#IPUToolkit.IPUCompiler.@ipuprint","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.@ipuprint","text":"@ipuprint(xs...)\n@ipuprintln(xs...)\n\nPrint a textual representation of values xs to standard output from the IPU. The functionality builds on @ipuprintf, and is intended as a more use friendly alternative of that API. However, that also means there's only limited support for argument types, handling 16/32/64 signed and unsigned integers, 32 and 64-bit floating point numbers, Cchars and pointers. For more complex output, use @ipuprintf directly.\n\nLimited string interpolation is also possible:\n\n    @ipuprint(\"Hello, World \", 42, \"\\n\")\n    @ipuprint \"Hello, World $(42)\\n\"\n\nPrinting can be completely disabled by setting\n\nIPUToolkit.IPUCompiler.DISABLE_PRINT[] = true\n\n\n\n\n\n","category":"macro"},{"location":"compiler/#IPUToolkit.IPUCompiler.@ipuprintln","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.@ipuprintln","text":"@ipuprint(xs...)\n@ipuprintln(xs...)\n\nPrint a textual representation of values xs to standard output from the IPU. The functionality builds on @ipuprintf, and is intended as a more use friendly alternative of that API. However, that also means there's only limited support for argument types, handling 16/32/64 signed and unsigned integers, 32 and 64-bit floating point numbers, Cchars and pointers. For more complex output, use @ipuprintf directly.\n\nLimited string interpolation is also possible:\n\n    @ipuprint(\"Hello, World \", 42, \"\\n\")\n    @ipuprint \"Hello, World $(42)\\n\"\n\nPrinting can be completely disabled by setting\n\nIPUToolkit.IPUCompiler.DISABLE_PRINT[] = true\n\n\n\n\n\n\n\n","category":"macro"},{"location":"compiler/#IPUToolkit.IPUCompiler.@ipushow","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.@ipushow","text":"@ipushow(ex)\n\nIPU analogue of Base.@show. It comes with the same type restrictions as @ipuprintf.\n\n@ipushow x\n\nPrinting can be completely disabled by setting\n\nIPUToolkit.IPUCompiler.DISABLE_PRINT[] = true\n\n\n\n\n\n","category":"macro"},{"location":"compiler/#IPUToolkit.IPUCompiler.DISABLE_PRINT","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.DISABLE_PRINT","text":"IPUToolkit.IPUCompiler.DISABLE_PRINT::Base.RefValue{Bool}\n\nGlobal constant which controls whether printing through the various @ipuprint* macros should be disabled or not.  You may want to completely disable printing for production runs, to avoid the cost of printing on the device, but keep it enabled during development.\n\nExamples:\n\nIPUToolkit.IPUCompiler.DISABLE_PRINT[] = false # Do not disable printing, this is the default.\nIPUToolkit.IPUCompiler.DISABLE_PRINT[] = true  # Disable printing, the `@ipuprint*` macros are no-op.\n\n\n\n\n\n","category":"constant"},{"location":"compiler/#Benchmarking","page":"Writing codelets","title":"Benchmarking","text":"","category":"section"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"To benchmark expressions inside codelets you can use the macros @ipucycles, @ipushowcycles, and @ipuelapsed, which report the number of cycles spent in the wrapped expression. They are similar to Julia's @time, @showtime, and @elapsed macros, but report the number of cycles, as the clockspeed of tiles cannot be easily obtained inside a codelet. The corresponding time can be obtained by dividing the number of cycles by the clock frequency of the the tile, which you can get with Poplar.TargetGetTileClockFrequency(target) outside of the codelet, and should usually be 1.330 GHz or 1.850 GHz depending on the model of your IPU. The printing macros @ipucycles and @ipushowcycles can be made completely no-op by setting IPUCompiler.DISABLE_PRINT.","category":"page"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"warning: Warning\nTiming of expressions taking longer than typemax(UInt32) / tile_clock_frequency (about 2 or 3 seconds depending on your IPU model) is unreliable because the difference between the starting and the ending cycle counts would overflow.","category":"page"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"@ipucycles\n@ipushowcycles\n@ipuelapsed","category":"page"},{"location":"compiler/#IPUToolkit.IPUCompiler.@ipucycles","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.@ipucycles","text":"@ipucycles ex\n@ipucycles \"description\" ex\n\nPrint from inside a codelet the number of cycles spent to compute the expression ex. The corresponding time can be obtained by dividing the number of cycles by the clock frequency of the the tile, which you can get with Poplar.TargetGetTileClockFrequency(target) outside of the codelet. The optional argument description, a literal String, can be used to print also a label to identify the timed expression. A label is added automatically by @ipushowcycles.\n\nSee also @ipuelapsed.\n\nThis macro can be made no-op completely by setting\n\nIPUToolkit.IPUCompiler.DISABLE_PRINT[] = true\n\n\n\n\n\n","category":"macro"},{"location":"compiler/#IPUToolkit.IPUCompiler.@ipushowcycles","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.@ipushowcycles","text":"@ipushowcycles ex\n\nPrint from inside a codelet the expression ex and the number of cycles spent to compute it. This is useful when benchmarking multiple expression, to identify their contributions more easily. The corresponding time can be obtained by dividing the number of cycles by the clock frequency of the the tile, which you can get with Poplar.TargetGetTileClockFrequency(target) outside of the codelet.\n\nSee also @ipucycles, @ipuelapsed.\n\nThis macro can be made no-op completely by setting\n\nIPUToolkit.IPUCompiler.DISABLE_PRINT[] = true\n\n\n\n\n\n","category":"macro"},{"location":"compiler/#IPUToolkit.IPUCompiler.@ipuelapsed","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.@ipuelapsed","text":"@ipuelapsed ex\n\nReturn number of cycles spent to compute the expression ex. The corresponding time can be obtained by dividing the number of cycles by the clock frequency of the the tile, which you can get with Poplar.TargetGetTileClockFrequency(target) outside of the codelet.\n\nSee also @ipucycles, @ipushowcycles.\n\n\n\n\n\n","category":"macro"},{"location":"compiler/#Passing-non-constant-variables-from-global-scope","page":"Writing codelets","title":"Passing non-constant variables from global scope","text":"","category":"section"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"If your kernel references a non-constant (const) global variable, the generated code will result in a reference to a memory address on the host, and this will fatally fail at runtime because programs running on the IPU don't have access to the host memory. Constant variables are not affected by this problem because their values are inlined when the function is compiled. If you can't or don't want to make a variable constant you can interpolate its value with a top-level @eval when defining the codelet. For example:","category":"page"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"using IPUToolkit.IPUCompiler, IPUToolkit.Poplar\ndevice = Poplar.get_ipu_device()\ntarget = Poplar.DeviceGetTarget(device)\ngraph = Poplar.Graph(target)\ntile_clock_frequency = Poplar.TargetGetTileClockFrequency(target)\n@eval @codelet graph function test(invec::VertexVector{Float32, In}, outvec::VertexVector{Float32, Out})\n    # We can use the intrinsic `get_scount_l` to get the cycle counter right\n    # before and after some operations, so that we can benchmark it.\n    cycles_start = get_scount_l()\n    # Do some operations here...\n    cycles_end = get_scount_l()\n    # Divide the difference between the two cycle counts by the tile frequency\n    # clock to get the time.\n    time = (cycles_end - cycles_start) / $(tile_clock_frequency)\n    # Show the time spent doing your operations\n    @ipushow time\nend","category":"page"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"The use of @eval allows you not to have to pass an extra argument to your kernel just to use the value of the variable inside the codelet.","category":"page"},{"location":"compiler/#Domain-Specific-Language:-@ipuprogram","page":"Writing codelets","title":"Domain-Specific Language: @ipuprogram","text":"","category":"section"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"The IPUCompiler.@ipuprogram macro provides a very simple and limited DSL to automatically generate most of the boilerplate code needed when writing an IPU program. You can do very little with this DSL, which is mainly a showcase of Julia's meta-programming capabilities. A fully commented examples of use of the @ipuprogram macro is available in the examples/dsl.jl file.","category":"page"},{"location":"poplar/#Interfacing-the-Poplar-SDK","page":"Poplar SDK","title":"Interfacing the Poplar SDK","text":"","category":"section"},{"location":"poplar/","page":"Poplar SDK","title":"Poplar SDK","text":"A quick example of use of the Poplar SDK functionalities, available in the IPUToolkit.Poplar submodule:","category":"page"},{"location":"poplar/","page":"Poplar SDK","title":"Poplar SDK","text":"julia> using IPUToolkit.Poplar\n\njulia> dm = Poplar.DeviceManager();\n\njulia> Int(Poplar.DeviceManagerGetNumDevices(dm))\n129\n\njulia> device = Poplar.get_ipu_device();\n[ Info: Trying to attach to device 0...\n[ Info: Successfully attached to device 0\n\njulia> Int(Poplar.DeviceGetId(device))\n0\n\njulia> Poplar.DeviceDetach(device)","category":"page"},{"location":"poplar/","page":"Poplar SDK","title":"Poplar SDK","text":"A couple of basic examples of programs running on the IPU written using the interface to the Poplar SDK are available in the files examples/tutorial1.jl and examples/tutorial2.jl.","category":"page"},{"location":"poplar/","page":"Poplar SDK","title":"Poplar SDK","text":"We automatically generate the bindings of the Poplar SDK using Clang.jl and CxxWrap.jl. There is not automatic documentation at the moment, but functions can be accessed from the Poplar submodule. Also, the IPUToolkit.Poplar submodule wraps a subset of the functionalities available in the Poplar SDK, do not expect to be able to use all functionalities. Remember that Julia does not use class-based object-oriented programming, class instances will usually be first arguments of the methods you want to use.","category":"page"},{"location":"poplar/","page":"Poplar SDK","title":"Poplar SDK","text":"Function naming convention and signature is usually as follows:","category":"page"},{"location":"poplar/","page":"Poplar SDK","title":"Poplar SDK","text":"class name in CamelCase, followed by method name also in CamelCase.  Note that first letter of method name is always uppercase in this naming convention, even if it is lowercase in the Poplar SDK.  For example, the method getNumDevices of the DeviceManager class can be accessed in the Poplar submodule with Poplar.DeviceManagerGetNumDevices;\nthe first argument of the function is the class instance.  For example, to use the Julia function Poplar.DeviceManagerGetNumDevices, you need to pass as first argument an instance of DeviceManager;\nthe following arguments are the same as in the method you want to use in the SDK.  For example, the method getNumDevices of the DeviceManager class doesn't take any argument, so the Julia function Poplar.DeviceManagerGetNumDevices will take an instance of DeviceManager as only argument.","category":"page"},{"location":"poplar/#Convenient-methods","page":"Poplar SDK","title":"Convenient methods","text":"","category":"section"},{"location":"poplar/","page":"Poplar SDK","title":"Poplar SDK","text":"In addition to this, for some functions (e.g. EngineWriteTensor, EngineConnectStream, EngineReadTensor) we provide more user-friendly methods where the last argument can be a Julia's Array, without having to pass additional arguments for pointers or array size. Furthermore, the custom functions Poplar.get_ipu_device and Poplar.get_ipu_devices can be used to access one more IPU devices, as shown in the example above.","category":"page"},{"location":"poplar/","page":"Poplar SDK","title":"Poplar SDK","text":"Another function for which we provide a convenient method is Poplar.GraphAddConstant:","category":"page"},{"location":"poplar/","page":"Poplar SDK","title":"Poplar SDK","text":"Poplar.GraphAddConstant(graph, host_array)","category":"page"},{"location":"poplar/","page":"Poplar SDK","title":"Poplar SDK","text":"adds the host_array (a plain standard Julia Array living on the host) to graph, automatically inferring from host_array the type and the shape of the tensor in the graph.","category":"page"},{"location":"poplar/","page":"Poplar SDK","title":"Poplar SDK","text":"You can slice a tensor with the usual Julia notation tensor[index1:index2], this corresponds to a call to Tensor.slice(index1, index2+1).","category":"page"},{"location":"poplar/","page":"Poplar SDK","title":"Poplar SDK","text":"similar can be used to add to graph a tensor with the same shape and optionally element type as tensor.","category":"page"},{"location":"poplar/","page":"Poplar SDK","title":"Poplar SDK","text":"Modules = [IPUToolkit.Poplar]","category":"page"},{"location":"poplar/#Base.similar-Tuple{IPUToolkit.Poplar.Graph, IPUToolkit.Poplar.TensorAllocated}","page":"Poplar SDK","title":"Base.similar","text":"similar(\n    graph::Poplar.Graph,\n    tensor::Poplar.TensorAllocated,\n    [type::DataType],\n    [debug::String]\n) -> Poplar.TensorAllocated\n\nAdds to graph a variable tensor with the same shape as tensor. If a type (this is a Julia type, like Float32 or Int32) argument is not passed, the same element type as tensor will be automatically used. An optional debug context can also be passed, as a String.\n\n\n\n\n\n","category":"method"},{"location":"poplar/#IPUToolkit.Poplar.get_ipu_device","page":"Poplar SDK","title":"IPUToolkit.Poplar.get_ipu_device","text":"get_ipu_device(hint::Union{AbstractVector{<:Integer},Integer}=0)\n\nSimilar to get_ipu_devices, but request exactly one IPU device.  If it can attach to a device, return that pointer only (not in a vector, like get_ipu_devices), otherwise return nothing.  You can release the device with Poplar.DeviceDetach(device).\n\nThe optional argument hint suggests to which device IDs to try and attach.  It can have different types:\n\nif of type Integer, try to attach to one device, starting from the one with index hint. The default is hint=0;\nif of type AbstractVector, try to attach to a device from that list of IDs.\n\n\n\n\n\n","category":"function"},{"location":"poplar/#IPUToolkit.Poplar.get_ipu_devices","page":"Poplar SDK","title":"IPUToolkit.Poplar.get_ipu_devices","text":"get_ipu_devices(n::Int, hint::Union{AbstractVector{<:Integer},Integer}=0)\n\nTry to attach to n IPU devices, returns a vector of the pointers to the devices successfully attached to.  You can release them with Poplar.DeviceDetach (note that this function takes a single pointer as input, so you have to use broadcasting Poplar.DeviceDetach.(devices) to release a vector of pointers).\n\nThe second optional argument hint suggests to which device IDs to try and attach.  It can have different types:\n\nif of type Integer, try to attach to n devices, starting from the one with index hint.  The default is hint=0;\nif of type AbstractVector, try to attach to n devices from that list of IDs.\n\nSee get_ipu_device for requesting exactly one IPU device.\n\n\n\n\n\n","category":"function"},{"location":"#IPUToolkit.jl","page":"IPUToolkit","title":"IPUToolkit.jl","text":"","category":"section"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"IPUToolkit.jl allows you to interface the Intelligence Processing Unit (IPU) by Graphcore using the Julia programming language.","category":"page"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"The main motivation for this project is to explore Julia's introspection and metaprogramming capabilities to write high-level code for the IPU using an alternative method to the tools developed by Graphcore, and leverage code-generation through LLVM to generate efficient code for the device: also the IPU compiler is based on this framework, so the LLVM IR constitutes a common language between Julia and the IPU compiler.","category":"page"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"warning: Disclaimer\nThis effort is not officially endorsed by Graphcore, although we gracefully received help through the public Graphcore support channels. This package is currently a proof-of-concept, not suited for production usage. Its API may be subject to frequent development and breaking changes.","category":"page"},{"location":"#Requirements","page":"IPUToolkit","title":"Requirements","text":"","category":"section"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"This package requires","category":"page"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"Julia v1.6+ (currently tested up to Julia v1.10),\nthe Poplar SDK v1.3 or v2.0-v2.6 including the popc compiler,\nand GCC 10+ for compiling the wrapper around the Poplar SDK (it requires support for the C++20 standard).","category":"page"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"Other versions of the Poplar SDK are not currently supported.","category":"page"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"note: Compatibility between Julia and Poplar SDK\nBoth Julia and the Poplar SDK are coupled to a specific version of the LLVM compiler framework, and you will need to match a specific version of the Poplar SDK with a version of Julia using the same major version of LLVM. For examplethe Poplar SDK version 2.2 uses LLVM 13, which is available in Julia v1.8;\nthe Poplar SDK versions 2.3-2.5 use LLVM 14, which is available in Julia v1.9;\nthe Poplar SDK versions 2.6-3.0 use LLVM 15, which is available in Julia v1.10.","category":"page"},{"location":"#Installation","page":"IPUToolkit","title":"Installation","text":"","category":"section"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"To install the package, run the commands","category":"page"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"using Pkg\nPkg.add(; url=\"https://github.com/giordano/IPUToolkit.jl\")","category":"page"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"You will need to build the wrapper around the Poplar SDK. This should happen automatically the first time you install the package, in any case you can run it with","category":"page"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"Pkg.build()","category":"page"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"This step requires a C++ compiler supporting C++20 standard. You have to set the compiler with the CXX environment variable, this can be either its absolute path or simply its name if it is in the PATH environment variable.","category":"page"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"note: Note\nCompiling the wrapper around the Poplar SDK will take a while, without printing an update to screen. Hold on.","category":"page"},{"location":"#Usage","page":"IPUToolkit","title":"Usage","text":"","category":"section"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"The package is called IPUToolkit because it provides different tools to interface the IPU from Julia:","category":"page"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"you can use functionalities in the Poplar SDK;\nyou can use Julia's code generation capabilities to automatically compile native code that can be run on the IPU;\nthere is a small embedded Domain-Specific Language (eDSL) to automatically generate the code of a program.","category":"page"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"These approaches are exploratory of the functionalities, and are often limited in scope and are described in more details in the following sections.","category":"page"}]
}
