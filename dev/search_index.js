var documenterSearchIndex = {"docs":
[{"location":"#IPUToolkit.jl","page":"IPUToolkit","title":"IPUToolkit.jl","text":"","category":"section"},{"location":"#Index","page":"IPUToolkit","title":"Index","text":"","category":"section"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"","category":"page"},{"location":"#Types","page":"IPUToolkit","title":"Types","text":"","category":"section"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"Modules = [IPUToolkit.Poplar, IPUToolkit.IPUCompiler]\nOrder = [:type]","category":"page"},{"location":"#Functions-and-macros","page":"IPUToolkit","title":"Functions and macros","text":"","category":"section"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"Modules = [IPUToolkit.Poplar, IPUToolkit.IPUCompiler]\nOrder = [:function, :macro]","category":"page"},{"location":"#Base.similar-Tuple{IPUToolkit.Poplar.Graph, IPUToolkit.Poplar.TensorAllocated}","page":"IPUToolkit","title":"Base.similar","text":"similar(\n    graph::Poplar.Graph,\n    tensor::Poplar.TensorAllocated,\n    [type::DataType],\n    [debug::String]\n) -> Poplar.TensorAllocated\n\nAdds to graph a variable tensor with the same shape as tensor. If a type (this is a Julia type, like Float32 or Int32) argument is not passed, the same element type as tensor will be automatically used. An optional debug context can also be passed, as a String.\n\n\n\n\n\n","category":"method"},{"location":"#IPUToolkit.Poplar.get_ipu_device","page":"IPUToolkit","title":"IPUToolkit.Poplar.get_ipu_device","text":"get_ipu_device(hint::Union{AbstractVector{<:Integer},Integer}=0)\n\nSimilar to get_ipu_devices, but request exactly one IPU device.  If it can attach to a device, return that pointer only (not in a vector, like get_ipu_devices), otherwise return nothing.  You can release the device with Poplar.DeviceDetach.\n\nThe optional argument hint suggests to which device IDs to try and attach.  It can have different types:\n\nif of type Integer, try to attach to n devices, starting from the one with index hint.  The default is hint=0;\nif of type AbstractVector, try to attach to n devices from that list of IDs.\n\n\n\n\n\n","category":"function"},{"location":"#IPUToolkit.Poplar.get_ipu_devices","page":"IPUToolkit","title":"IPUToolkit.Poplar.get_ipu_devices","text":"get_ipu_devices(n::Int, hint::Union{AbstractVector{<:Integer},Integer}=0)\n\nTry to attach to n IPU devices, returns a vector of the pointers to the devices successfully attached to.  You can release them with Poplar.DeviceDetach (note that this function takes a single pointer as input, so you have to use broadcasting Poplar.DeviceDetach.(devices) to release a vector of pointers).\n\nThe second optional argument hint suggests to which device IDs to try and attach.  It can have different types:\n\nif of type Integer, try to attach to n devices, starting from the one with index hint.  The default is hint=0;\nif of type AbstractVector, try to attach to n devices from that list of IDs.\n\nSee get_ipu_device for requesting exactly one IPU device.\n\n\n\n\n\n","category":"function"},{"location":"#IPUToolkit.IPUCompiler.add_vertex","page":"IPUToolkit","title":"IPUToolkit.IPUCompiler.add_vertex","text":"add_vertex(graph::Poplar.GraphAllocated,\n           compute_set_or_program::Union{Poplar.ComputeSetAllocated, Poplar.ProgramSequenceAllocated},\n           [tiles::Union{Integer,AbstractVector{<:Integer}},]\n           codelet::Function,\n           args::Poplar.TensorAllocated...) -> Nothing\n\nAdd the codelet function codelet created with @codelet to graph, using the tensors args as arguments. The function codelet must have exactly one method, no more, no less. The second argument can be either the program or the compute set to which to add the new vertex/vertices. If a program is passed, a new compute set will be automatically created.\n\nadd_vertex also evenly maps all tensors and vertices across all tiles, which can be either a single tile ID or an AbstractVector of IDs and defaults to single tile 0 if this argument is omitted. Note that all argument tensors args must be longer than or equal to the number of tiles. If you want to have better control over tile mapping, do not use add_vertex.\n\n\n\n\n\n","category":"function"},{"location":"#IPUToolkit.IPUCompiler.@ipucycles","page":"IPUToolkit","title":"IPUToolkit.IPUCompiler.@ipucycles","text":"@ipucycles ex\n@ipucycles \"description\" ex\n\nPrint from inside a codelet the number of cycles spent to compute the expression ex. The corresponding time can be obtained by dividing the number of cycles by the clock frequency of the the tile, which you can get with Poplar.TargetGetTileClockFrequency(target) outside of the codelet. The optional argument description, a literal String, can be used to print also a label to identify the timed expression. A label is added automatically by @ipushowcycles.\n\nSee also @ipuelapsed.\n\nThis macro can be made no-op completely by setting\n\nIPUToolkit.IPUCompiler.DISABLE_PRINT[] = true\n\n\n\n\n\n","category":"macro"},{"location":"#IPUToolkit.IPUCompiler.@ipuelapsed-Tuple{Any}","page":"IPUToolkit","title":"IPUToolkit.IPUCompiler.@ipuelapsed","text":"@ipuelapsed ex\n\nReturn number of cycles spent to compute the expression ex. The corresponding time can be obtained by dividing the number of cycles by the clock frequency of the the tile, which you can get with Poplar.TargetGetTileClockFrequency(target) outside of the codelet.\n\nSee also @ipucycles, @ipushowcycles.\n\n\n\n\n\n","category":"macro"},{"location":"#IPUToolkit.IPUCompiler.@ipuprint-Tuple","page":"IPUToolkit","title":"IPUToolkit.IPUCompiler.@ipuprint","text":"@ipuprint(xs...)\n@ipuprintln(xs...)\n\nPrint a textual representation of values xs to standard output from the IPU. The functionality builds on @ipuprintf, and is intended as a more use friendly alternative of that API. However, that also means there's only limited support for argument types, handling 16/32/64 signed and unsigned integers, 32 and 64-bit floating point numbers, Cchars and pointers. For more complex output, use @ipuprintf directly.\n\nLimited string interpolation is also possible:\n\n    @ipuprint(\"Hello, World \", 42, \"\\n\")\n    @ipuprint \"Hello, World $(42)\\n\"\n\nPrinting can be completely disabled by setting\n\nIPUToolkit.IPUCompiler.DISABLE_PRINT[] = true\n\n\n\n\n\n","category":"macro"},{"location":"#IPUToolkit.IPUCompiler.@ipuprintf-Tuple{String, Vararg{Any}}","page":"IPUToolkit","title":"IPUToolkit.IPUCompiler.@ipuprintf","text":"@ipuprintf(\"%Fmt\", args...)\n\nPrint a formatted string in device context on the host standard output.\n\nNote that this is not a fully C-compliant printf implementation.\n\nAlso beware that it is an untyped, and unforgiving printf implementation. Type widths need to match, eg. printing a 64-bit Julia integer requires the %ld formatting string.\n\nPrinting can be completely disabled by setting\n\nIPUToolkit.IPUCompiler.DISABLE_PRINT[] = true\n\n\n\n\n\n","category":"macro"},{"location":"#IPUToolkit.IPUCompiler.@ipuprintln-Tuple","page":"IPUToolkit","title":"IPUToolkit.IPUCompiler.@ipuprintln","text":"@ipuprint(xs...)\n@ipuprintln(xs...)\n\nPrint a textual representation of values xs to standard output from the IPU. The functionality builds on @ipuprintf, and is intended as a more use friendly alternative of that API. However, that also means there's only limited support for argument types, handling 16/32/64 signed and unsigned integers, 32 and 64-bit floating point numbers, Cchars and pointers. For more complex output, use @ipuprintf directly.\n\nLimited string interpolation is also possible:\n\n    @ipuprint(\"Hello, World \", 42, \"\\n\")\n    @ipuprint \"Hello, World $(42)\\n\"\n\nPrinting can be completely disabled by setting\n\nIPUToolkit.IPUCompiler.DISABLE_PRINT[] = true\n\n\n\n\n\n\n\n","category":"macro"},{"location":"#IPUToolkit.IPUCompiler.@ipushow-Tuple","page":"IPUToolkit","title":"IPUToolkit.IPUCompiler.@ipushow","text":"@ipushow(ex)\n\nIPU analog of Base.@show. It comes with the same type restrictions as @ipuprintf.\n\n@ipushow x\n\nPrinting can be completely disabled by setting\n\nIPUToolkit.IPUCompiler.DISABLE_PRINT[] = true\n\n\n\n\n\n","category":"macro"},{"location":"#IPUToolkit.IPUCompiler.@ipushowcycles-Tuple{Any}","page":"IPUToolkit","title":"IPUToolkit.IPUCompiler.@ipushowcycles","text":"@ipushowcycles ex\n\nPrint from inside a codelet the expression ex and the number of cycles spent to compute it. This is useful when benchmarking multiple expression, to identify their contributions more easily. The corresponding time can be obtained by dividing the number of cycles by the clock frequency of the the tile, which you can get with Poplar.TargetGetTileClockFrequency(target) outside of the codelet.\n\nSee also @ipucycles, @ipuelapsed.\n\nThis macro can be made no-op completely by setting\n\nIPUToolkit.IPUCompiler.DISABLE_PRINT[] = true\n\n\n\n\n\n","category":"macro"},{"location":"#Options","page":"IPUToolkit","title":"Options","text":"","category":"section"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"Modules = [IPUToolkit.Poplar, IPUToolkit.IPUCompiler]\nOrder = [:constant]","category":"page"},{"location":"#IPUToolkit.IPUCompiler.DISABLE_PRINT","page":"IPUToolkit","title":"IPUToolkit.IPUCompiler.DISABLE_PRINT","text":"IPUToolkit.IPUCompiler.DISABLE_PRINT::Base.RefValue{Bool}\n\nGlobal constant which controls whether printing through the various @ipuprint* macros should be disabled or not.  You may want to completely disable printing for production runs, to avoid the cost of printing on the device, but keep it enabled during development.\n\nExamples:\n\nIPUToolkit.IPUCompiler.DISABLE_PRINT[] = false # Do not disable printing, this is the default.\nIPUToolkit.IPUCompiler.DISABLE_PRINT[] = true  # Disable printing, the `@ipuprint*` macros are no-op.\n\n\n\n\n\n","category":"constant"},{"location":"#IPUToolkit.IPUCompiler.KEEP_LLVM_FILES","page":"IPUToolkit","title":"IPUToolkit.IPUCompiler.KEEP_LLVM_FILES","text":"IPUToolkit.IPUCompiler.KEEP_LLVM_FILES::Base.RefValue{Bool}\n\nOption to control whether to keep in the current directory the files with the LLVM Intermediate Representation (IR) generated for the codelets.\n\n\n\n\n\n","category":"constant"},{"location":"#IPUToolkit.IPUCompiler.POPC_FLAGS","page":"IPUToolkit","title":"IPUToolkit.IPUCompiler.POPC_FLAGS","text":"IPUToolkit.IPUCompiler.POPC_FLAGS::Base.RefValue{Cmd}\n\nOptions to pass to the popc compiler to compile the code.\n\n\n\n\n\n","category":"constant"},{"location":"#IPUToolkit.IPUCompiler.PROGRESS_SPINNER","page":"IPUToolkit","title":"IPUToolkit.IPUCompiler.PROGRESS_SPINNER","text":"IPUToolkit.IPUCompiler.PROGRESS_SPINNER::Base.RefValue{Bool}\n\nOption to control whether to display a spinner to show progress during compilation of IPU codelets.\n\n\n\n\n\n","category":"constant"}]
}
