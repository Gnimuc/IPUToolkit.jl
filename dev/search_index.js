var documenterSearchIndex = {"docs":
[{"location":"compiler/#Writing-codelets-in-Julia","page":"Writing codelets","title":"Writing codelets in Julia","text":"","category":"section"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"The IPUToolkit.IPUCompiler submodule allows you to write codelets for the IPU in Julia. Codelets are defined with the IPUCompiler.@codelet macro, and then you can use them inside a program, written using the interface to the Poplar SDK described before. This mechanism uses the GPUCompiler.jl package, which is a generic framework for generating LLVM IR code for specialised targets, not limited to GPUs despite the historical name. The IPUCompiler.@codelet macro takes two arguments:","category":"page"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"the graph to which to add the codelet with the Poplar.GraphAddCodelets function\nthe function definition of the kernel you want to compile for the device.","category":"page"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"The arguments of a codelet function have to be VertexVector{T,S}, a subtype of AbstractVector{T} which represents a vertex vector, passed as argument to a codelet. The parameters of VertexVector{T,S} are","category":"page"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"T: the type of the elements of the vector;\nS: the scope of the vector in the codelet, In, Out, or InOut.","category":"page"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"Examples of codelets written in Julia are shown in the files examples/main.jl, examples/adam.jl, and examples/pi.jl.","category":"page"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"The code inside a codelet has the same limitations as all the compilation models based on GPUCompiler.jl:","category":"page"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"the code has to be statically inferred and compiled, dynamic dispatch is not admitted;\nyou cannot use functionalities which require the Julia runtime, most notably the garbage collector;\nyou cannot call into any other external binary library at runtime, for example you cannot call into a BLAS library.","category":"page"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"After defining a codelet with @codelet you can add a vertex calling this codelet to the graph with the function add_vertex, which also allows controlling the tile mapping in a basic way. Read its docstring for more details.","category":"page"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"During compilation of codelets a spinner is displayed to show the progress, as this step can take a few seconds for each codelet to be generated. This can be disabled by setting IPUCompiler.PROGRESS_SPINNER:","category":"page"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"IPUCompiler.PROGRESS_SPINNER[] = false","category":"page"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"add_vertex\nIPUCompiler.PROGRESS_SPINNER","category":"page"},{"location":"compiler/#IPUToolkit.IPUCompiler.add_vertex","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.add_vertex","text":"add_vertex(graph::Poplar.GraphAllocated,\n           compute_set_or_program::Union{Poplar.ComputeSetAllocated, Poplar.ProgramSequenceAllocated},\n           [tiles::Union{Integer,AbstractVector{<:Integer}},]\n           codelet::Function,\n           args::Poplar.TensorAllocated...) -> Nothing\n\nAdd the codelet function codelet created with @codelet to graph, using the tensors args as arguments. The function codelet must have exactly one method, no more, no less. The second argument can be either the program or the compute set to which to add the new vertex/vertices. If a program is passed, a new compute set will be automatically created.\n\nadd_vertex also evenly maps all tensors and vertices across all tiles, which can be either a single tile ID or an AbstractVector of IDs and defaults to single tile 0 if this argument is omitted. Note that all argument tensors args must be longer than or equal to the number of tiles. If you want to have better control over tile mapping, do not use add_vertex.\n\n\n\n\n\n","category":"function"},{"location":"compiler/#IPUToolkit.IPUCompiler.PROGRESS_SPINNER","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.PROGRESS_SPINNER","text":"IPUToolkit.IPUCompiler.PROGRESS_SPINNER::Base.RefValue{Bool}\n\nOption to control whether to display a spinner to show progress during compilation of IPU codelets.\n\n\n\n\n\n","category":"constant"},{"location":"compiler/#Printing","page":"Writing codelets","title":"Printing","text":"","category":"section"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"Inside codelets you can print text and value of variables using the macros @ipuprintf, @ipuprint, @ipuprintln, and @ipushow. These macros are useful for debugging purposes but printing inside a codelet might incur performance penalty. To completely disable all printing and make these macros no-op you can set IPUCompiler.DISABLE_PRINT:","category":"page"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"IPUCompiler.DISABLE_PRINT[] = true","category":"page"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"@ipuprintf\n@ipuprint\n@ipuprintln\n@ipushow\nIPUCompiler.DISABLE_PRINT","category":"page"},{"location":"compiler/#IPUToolkit.IPUCompiler.@ipuprintf","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.@ipuprintf","text":"@ipuprintf(\"%Fmt\", args...)\n\nPrint a formatted string in device context on the host standard output.\n\nNote that this is not a fully C-compliant printf implementation.\n\nAlso beware that it is an untyped, and unforgiving printf implementation. Type widths need to match, eg. printing a 64-bit Julia integer requires the %ld formatting string.\n\nPrinting can be completely disabled by setting\n\nIPUToolkit.IPUCompiler.DISABLE_PRINT[] = true\n\n\n\n\n\n","category":"macro"},{"location":"compiler/#IPUToolkit.IPUCompiler.@ipuprint","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.@ipuprint","text":"@ipuprint(xs...)\n@ipuprintln(xs...)\n\nPrint a textual representation of values xs to standard output from the IPU. The functionality builds on @ipuprintf, and is intended as a more use friendly alternative of that API. However, that also means there's only limited support for argument types, handling 16/32/64 signed and unsigned integers, 32 and 64-bit floating point numbers, Cchars and pointers. For more complex output, use @ipuprintf directly.\n\nLimited string interpolation is also possible:\n\n    @ipuprint(\"Hello, World \", 42, \"\\n\")\n    @ipuprint \"Hello, World $(42)\\n\"\n\nPrinting can be completely disabled by setting\n\nIPUToolkit.IPUCompiler.DISABLE_PRINT[] = true\n\n\n\n\n\n","category":"macro"},{"location":"compiler/#IPUToolkit.IPUCompiler.@ipuprintln","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.@ipuprintln","text":"@ipuprint(xs...)\n@ipuprintln(xs...)\n\nPrint a textual representation of values xs to standard output from the IPU. The functionality builds on @ipuprintf, and is intended as a more use friendly alternative of that API. However, that also means there's only limited support for argument types, handling 16/32/64 signed and unsigned integers, 32 and 64-bit floating point numbers, Cchars and pointers. For more complex output, use @ipuprintf directly.\n\nLimited string interpolation is also possible:\n\n    @ipuprint(\"Hello, World \", 42, \"\\n\")\n    @ipuprint \"Hello, World $(42)\\n\"\n\nPrinting can be completely disabled by setting\n\nIPUToolkit.IPUCompiler.DISABLE_PRINT[] = true\n\n\n\n\n\n\n\n","category":"macro"},{"location":"compiler/#IPUToolkit.IPUCompiler.@ipushow","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.@ipushow","text":"@ipushow(ex)\n\nIPU analog of Base.@show. It comes with the same type restrictions as @ipuprintf.\n\n@ipushow x\n\nPrinting can be completely disabled by setting\n\nIPUToolkit.IPUCompiler.DISABLE_PRINT[] = true\n\n\n\n\n\n","category":"macro"},{"location":"compiler/#IPUToolkit.IPUCompiler.DISABLE_PRINT","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.DISABLE_PRINT","text":"IPUToolkit.IPUCompiler.DISABLE_PRINT::Base.RefValue{Bool}\n\nGlobal constant which controls whether printing through the various @ipuprint* macros should be disabled or not.  You may want to completely disable printing for production runs, to avoid the cost of printing on the device, but keep it enabled during development.\n\nExamples:\n\nIPUToolkit.IPUCompiler.DISABLE_PRINT[] = false # Do not disable printing, this is the default.\nIPUToolkit.IPUCompiler.DISABLE_PRINT[] = true  # Disable printing, the `@ipuprint*` macros are no-op.\n\n\n\n\n\n","category":"constant"},{"location":"compiler/#Benchmarking","page":"Writing codelets","title":"Benchmarking","text":"","category":"section"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"To benchmark expressions inside codelets you can use the macros @ipucycles, @ipushowcycles, and @ipuelapsed, which report the number of cycles spent in the wrapped expression. They are similar to Julia's @time, @showtime, and @elapsed macros, but report the number of cycles, as the clockspeed of tiles cannot be easily obtained inside a codelet. The corresponding time can be obtained by dividing the number of cycles by the clock frequency of the the tile, which you can get with Poplar.TargetGetTileClockFrequency(target) outside of the codelet, and should usually be 1.330 GHz or 1.850 GHz depending on the model of your IPU. The printing macros @ipucycles and @ipushowcycles can be made completely no-op by setting IPUCompiler.DISABLE_PRINT.","category":"page"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"warning: Warning\nTiming of expressions taking longer than typemax(UInt32) / tile_clock_frequency (about 2 or 3 seconds depending on your IPU model) is unreliable because the difference between the starting and the ending cycle counts would overflow.","category":"page"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"@ipucycles\n@ipushowcycles\n@ipuelapsed","category":"page"},{"location":"compiler/#IPUToolkit.IPUCompiler.@ipucycles","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.@ipucycles","text":"@ipucycles ex\n@ipucycles \"description\" ex\n\nPrint from inside a codelet the number of cycles spent to compute the expression ex. The corresponding time can be obtained by dividing the number of cycles by the clock frequency of the the tile, which you can get with Poplar.TargetGetTileClockFrequency(target) outside of the codelet. The optional argument description, a literal String, can be used to print also a label to identify the timed expression. A label is added automatically by @ipushowcycles.\n\nSee also @ipuelapsed.\n\nThis macro can be made no-op completely by setting\n\nIPUToolkit.IPUCompiler.DISABLE_PRINT[] = true\n\n\n\n\n\n","category":"macro"},{"location":"compiler/#IPUToolkit.IPUCompiler.@ipushowcycles","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.@ipushowcycles","text":"@ipushowcycles ex\n\nPrint from inside a codelet the expression ex and the number of cycles spent to compute it. This is useful when benchmarking multiple expression, to identify their contributions more easily. The corresponding time can be obtained by dividing the number of cycles by the clock frequency of the the tile, which you can get with Poplar.TargetGetTileClockFrequency(target) outside of the codelet.\n\nSee also @ipucycles, @ipuelapsed.\n\nThis macro can be made no-op completely by setting\n\nIPUToolkit.IPUCompiler.DISABLE_PRINT[] = true\n\n\n\n\n\n","category":"macro"},{"location":"compiler/#IPUToolkit.IPUCompiler.@ipuelapsed","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.@ipuelapsed","text":"@ipuelapsed ex\n\nReturn number of cycles spent to compute the expression ex. The corresponding time can be obtained by dividing the number of cycles by the clock frequency of the the tile, which you can get with Poplar.TargetGetTileClockFrequency(target) outside of the codelet.\n\nSee also @ipucycles, @ipushowcycles.\n\n\n\n\n\n","category":"macro"},{"location":"compiler/#Other-options","page":"Writing codelets","title":"Other options","text":"","category":"section"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"Other options related to codelet generation are:","category":"page"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"IPUCompiler.KEEP_LLVM_FILES\nIPUCompiler.POPC_FLAGS","category":"page"},{"location":"compiler/#IPUToolkit.IPUCompiler.KEEP_LLVM_FILES","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.KEEP_LLVM_FILES","text":"IPUToolkit.IPUCompiler.KEEP_LLVM_FILES::Base.RefValue{Bool}\n\nOption to control whether to keep in the current directory the files with the LLVM Intermediate Representation (IR) generated for the codelets.\n\n\n\n\n\n","category":"constant"},{"location":"compiler/#IPUToolkit.IPUCompiler.POPC_FLAGS","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.POPC_FLAGS","text":"IPUToolkit.IPUCompiler.POPC_FLAGS::Base.RefValue{Cmd}\n\nOptions to pass to the popc compiler to compile the code.\n\n\n\n\n\n","category":"constant"},{"location":"compiler/#Domain-Specific-Language:-@ipuprogram","page":"Writing codelets","title":"Domain-Specific Language: @ipuprogram","text":"","category":"section"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"The IPUCompiler.@ipuprogram macro provides a very simple and limited DSL to automatically generate most of the boilerplate code needed when writing an IPU program. You can do very little with this DSL, which is mainly a showcase of Julia's meta-programming capabilities. A fully commented examples of use of the @ipuprogram macro is available in the examples/dsl.jl file.","category":"page"},{"location":"poplar/#Interfacing-the-Poplar-SDK","page":"Poplar SDK","title":"Interfacing the Poplar SDK","text":"","category":"section"},{"location":"poplar/","page":"Poplar SDK","title":"Poplar SDK","text":"A quick example of use of the Poplar SDK functionalities, available in the IPUToolkit.Poplar submodule:","category":"page"},{"location":"poplar/","page":"Poplar SDK","title":"Poplar SDK","text":"julia> using IPUToolkit.Poplar\n\njulia> dm = Poplar.DeviceManager();\n\njulia> Int(Poplar.DeviceManagerGetNumDevices(dm))\n129\n\njulia> device = Poplar.get_ipu_device();\n[ Info: Trying to attach to device 0...\n[ Info: Successfully attached to device 0\n\njulia> Int(Poplar.DeviceGetId(device))\n0\n\njulia> Poplar.DeviceDetach(device)","category":"page"},{"location":"poplar/","page":"Poplar SDK","title":"Poplar SDK","text":"A couple of basic examples of programs running on the IPU written using the interface to the Poplar SDK are available in the files examples/tutorial1.jl and examples/tutorial2.jl.","category":"page"},{"location":"poplar/","page":"Poplar SDK","title":"Poplar SDK","text":"We automatically generate the bindings of the Poplar SDK using Clang.jl and CxxWrap.jl. There is not automatic documentation at the moment, but functions can be accessed from the Poplar submodule. Also, the IPUToolkit.Poplar submodule wraps a subset of the functionalities available in the Poplar SDK, do not expect to be able to use all functionalities. Remember that Julia does not use class-based object-oriented programming, class instances will usually be first arguments of the methods you want to use.","category":"page"},{"location":"poplar/","page":"Poplar SDK","title":"Poplar SDK","text":"Function naming convention and signature is usually as follows:","category":"page"},{"location":"poplar/","page":"Poplar SDK","title":"Poplar SDK","text":"class name in CamelCase, followed by method name also in CamelCase.  Note that first letter of method name is always uppercase in this naming convention, even if it is lowercase in the Poplar SDK.  For example, the method getNumDevices of the DeviceManager class can be accessed in the Poplar submodule with Poplar.DeviceManagerGetNumDevices;\nthe first argument of the function is the class instance.  For example, to use the Julia function Poplar.DeviceManagerGetNumDevices, you need to pass as first argument an instance of DeviceManager;\nthe following arguments are the same as in the method you want to use in the SDK.  For example, the method getNumDevices of the DeviceManager class doesn't take any argument, so the Julia function Poplar.DeviceManagerGetNumDevices will take an instance of DeviceManager as only argument.","category":"page"},{"location":"poplar/#Convenient-methods","page":"Poplar SDK","title":"Convenient methods","text":"","category":"section"},{"location":"poplar/","page":"Poplar SDK","title":"Poplar SDK","text":"In addition to this, for some functions (e.g. EngineWriteTensor, EngineConnectStream, EngineReadTensor) we provide more user-friendly methods where the last argument can be a Julia's Array, without having to pass additional arguments for pointers or array size. Furthermore, the custom functions Poplar.get_ipu_device and Poplar.get_ipu_devices can be used to access one more IPU devices, as shown in the example above.","category":"page"},{"location":"poplar/","page":"Poplar SDK","title":"Poplar SDK","text":"Another function for which we provide a convenient method is Poplar.GraphAddConstant:","category":"page"},{"location":"poplar/","page":"Poplar SDK","title":"Poplar SDK","text":"Poplar.GraphAddConstant(graph, host_array)","category":"page"},{"location":"poplar/","page":"Poplar SDK","title":"Poplar SDK","text":"adds the host_array (a plain standard Julia Array living on the host) to graph, automatically inferring from host_array the type and the shape of the tensor in the graph.","category":"page"},{"location":"poplar/","page":"Poplar SDK","title":"Poplar SDK","text":"You can slice a tensor with the usual Julia notation tensor[index1:index2], this corresponds to a call to Tensor.slice(index1, index2+1).","category":"page"},{"location":"poplar/","page":"Poplar SDK","title":"Poplar SDK","text":"similar can be used to add to graph a tensor with the same shape and optionally element type as tensor.","category":"page"},{"location":"poplar/","page":"Poplar SDK","title":"Poplar SDK","text":"Modules = [IPUToolkit.Poplar]","category":"page"},{"location":"poplar/#Base.similar-Tuple{IPUToolkit.Poplar.Graph, IPUToolkit.Poplar.TensorAllocated}","page":"Poplar SDK","title":"Base.similar","text":"similar(\n    graph::Poplar.Graph,\n    tensor::Poplar.TensorAllocated,\n    [type::DataType],\n    [debug::String]\n) -> Poplar.TensorAllocated\n\nAdds to graph a variable tensor with the same shape as tensor. If a type (this is a Julia type, like Float32 or Int32) argument is not passed, the same element type as tensor will be automatically used. An optional debug context can also be passed, as a String.\n\n\n\n\n\n","category":"method"},{"location":"poplar/#IPUToolkit.Poplar.get_ipu_device","page":"Poplar SDK","title":"IPUToolkit.Poplar.get_ipu_device","text":"get_ipu_device(hint::Union{AbstractVector{<:Integer},Integer}=0)\n\nSimilar to get_ipu_devices, but request exactly one IPU device.  If it can attach to a device, return that pointer only (not in a vector, like get_ipu_devices), otherwise return nothing.  You can release the device with Poplar.DeviceDetach(device).\n\nThe optional argument hint suggests to which device IDs to try and attach.  It can have different types:\n\nif of type Integer, try to attach to one device, starting from the one with index hint. The default is hint=0;\nif of type AbstractVector, try to attach to a device from that list of IDs.\n\n\n\n\n\n","category":"function"},{"location":"poplar/#IPUToolkit.Poplar.get_ipu_devices","page":"Poplar SDK","title":"IPUToolkit.Poplar.get_ipu_devices","text":"get_ipu_devices(n::Int, hint::Union{AbstractVector{<:Integer},Integer}=0)\n\nTry to attach to n IPU devices, returns a vector of the pointers to the devices successfully attached to.  You can release them with Poplar.DeviceDetach (note that this function takes a single pointer as input, so you have to use broadcasting Poplar.DeviceDetach.(devices) to release a vector of pointers).\n\nThe second optional argument hint suggests to which device IDs to try and attach.  It can have different types:\n\nif of type Integer, try to attach to n devices, starting from the one with index hint.  The default is hint=0;\nif of type AbstractVector, try to attach to n devices from that list of IDs.\n\nSee get_ipu_device for requesting exactly one IPU device.\n\n\n\n\n\n","category":"function"},{"location":"#IPUToolkit.jl","page":"IPUToolkit","title":"IPUToolkit.jl","text":"","category":"section"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"IPUToolkit.jl allows you to interface the Intelligence Processing Unit (IPU) by Graphcore using the Julia programming language.","category":"page"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"warning: Disclaimer\nThis is package is currently a proof-of-concept, not suited for production usage. Its API is subject to frequent development and breaking changes.","category":"page"},{"location":"#Requirements","page":"IPUToolkit","title":"Requirements","text":"","category":"section"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"This package requires Julia v1.6+ (currently tested up to Julia v1.9), GCC 10+ as compiler (it requires support for the C++20 standard), and the Poplar SDK v1.3, or v2.0-v2.5. Other versions of the Poplar SDK are not currently supported.","category":"page"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"Note that both Julia and the Poplar SDK are coupled to a specific version of the LLVM compiler framework, and you will need to match a specific version of the Poplar SDK with a version of Julia using the same major version of LLVM. For example, the Poplar SDK v2.2 uses LLVM 13, which is available in Julia v1.8, while the Poplar SDK versions 2.3-2.5 use LLVM 14, which is available in Julia v1.9.","category":"page"},{"location":"#Installation","page":"IPUToolkit","title":"Installation","text":"","category":"section"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"To install the package, run the commands","category":"page"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"using Pkg\nPkg.add(; url=\"https://github.com/giordano/julia-ipu\")","category":"page"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"and then build the package with","category":"page"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"Pkg.build()","category":"page"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"note: Note\nThis step will compile a wrapper around the Poplar SDK that can be used by Julia. It will take a while, without printing an update to screen. Hold on.","category":"page"},{"location":"#Usage","page":"IPUToolkit","title":"Usage","text":"","category":"section"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"The package is called IPUToolkit because it provides different tools to interface the IPU from Julia:","category":"page"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"you can use functionalities in the Poplar SDK;\nyou can use Julia's code generation capabilities to automatically compile native code that can be run on the IPU;\nthere is a small embedded Domain-Specific Language (eDSL) to automatically generate the code of a program.","category":"page"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"These approaches are exploratory of the functionalities, and are often limited in scope and are described in more details in the following sections.","category":"page"}]
}
