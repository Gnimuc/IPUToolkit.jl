{"Token type":"EnumDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar::layout","Name":"poplar::layout::Vector","Filename":"poplar/VectorLayout.hpp","Text":"enum class Vector { NotAVector , Span , ShortSpan , OnePtr , ScaledPtr32 , ScaledPtr64 , ScaledPtr128 }"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar::layout","Name":"poplar::layout::Vector::NotAVector","Filename":"poplar/VectorLayout.hpp","Text":"NotAVector"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar::layout","Name":"poplar::layout::Vector::Span","Filename":"poplar/VectorLayout.hpp","Text":"Span"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar::layout","Name":"poplar::layout::Vector::ShortSpan","Filename":"poplar/VectorLayout.hpp","Text":"ShortSpan"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar::layout","Name":"poplar::layout::Vector::OnePtr","Filename":"poplar/VectorLayout.hpp","Text":"OnePtr"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar::layout","Name":"poplar::layout::Vector::ScaledPtr32","Filename":"poplar/VectorLayout.hpp","Text":"ScaledPtr32"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar::layout","Name":"poplar::layout::Vector::ScaledPtr64","Filename":"poplar/VectorLayout.hpp","Text":"ScaledPtr64"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar::layout","Name":"poplar::layout::Vector::ScaledPtr128","Filename":"poplar/VectorLayout.hpp","Text":"ScaledPtr128"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar::layout","Name":"poplar::layout::operator<<(std::ostream &, const poplar::layout::Vector)","Filename":"poplar/VectorLayout.hpp","Text":"std :: ostream & operator << ( std :: ostream & os , const Vector v )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar::layout","Name":"poplar::layout::to_string(const poplar::layout::Vector)","Filename":"poplar/VectorLayout.hpp","Text":"std :: string to_string ( const Vector v )"}
{"Token type":"EnumDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar::layout","Name":"poplar::layout::VectorList","Filename":"poplar/VectorLayout.hpp","Text":"enum class VectorList { NotAVector , OnePtr , ScaledPtr32 , ScaledPtr64 , ScaledPtr128 , DeltaN , DeltaNElements }"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar::layout","Name":"poplar::layout::VectorList::NotAVector","Filename":"poplar/VectorLayout.hpp","Text":"NotAVector"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar::layout","Name":"poplar::layout::VectorList::OnePtr","Filename":"poplar/VectorLayout.hpp","Text":"OnePtr"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar::layout","Name":"poplar::layout::VectorList::ScaledPtr32","Filename":"poplar/VectorLayout.hpp","Text":"ScaledPtr32"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar::layout","Name":"poplar::layout::VectorList::ScaledPtr64","Filename":"poplar/VectorLayout.hpp","Text":"ScaledPtr64"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar::layout","Name":"poplar::layout::VectorList::ScaledPtr128","Filename":"poplar/VectorLayout.hpp","Text":"ScaledPtr128"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar::layout","Name":"poplar::layout::VectorList::DeltaN","Filename":"poplar/VectorLayout.hpp","Text":"DeltaN"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar::layout","Name":"poplar::layout::VectorList::DeltaNElements","Filename":"poplar/VectorLayout.hpp","Text":"DeltaNElements"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar::layout","Name":"poplar::layout::operator<<(std::ostream &, const poplar::layout::VectorList)","Filename":"poplar/VectorLayout.hpp","Text":"std :: ostream & operator << ( std :: ostream & os , const VectorList v )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar::layout","Name":"poplar::layout::to_string(const poplar::layout::VectorList)","Filename":"poplar/VectorLayout.hpp","Text":"std :: string to_string ( const VectorList v )"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::ArrayRef<T>(std::nullptr_t)","Filename":"poplar/ArrayRef.hpp","Text":"ArrayRef ( std :: nullptr_t ) = delete"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::ArrayRef<T>()","Filename":"poplar/ArrayRef.hpp","Text":"constexpr ArrayRef ( ) : ptr ( nullptr ) , len ( 0 ) { }"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::ArrayRef<T>(const T *, std::size_t)","Filename":"poplar/ArrayRef.hpp","Text":"constexpr ArrayRef ( const T * p , std :: size_t size ) : ptr ( p ) , len ( size ) { }"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::ArrayRef<T>(const std::vector<T> &)","Filename":"poplar/ArrayRef.hpp","Text":"ArrayRef ( const std :: vector < T > & v )"}
{"Token type":"FunctionTemplate","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::ArrayRef<T>(const std::array<T, N> &)","Filename":"poplar/ArrayRef.hpp","Text":"template < std :: size_t N > constexpr ArrayRef ( const std :: array < T , N > & a ) : ArrayRef ( a . data ( ) , N ) { }"}
{"Token type":"FunctionTemplate","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::ArrayRef<T>(const T (&)[N])","Filename":"poplar/ArrayRef.hpp","Text":"template < std :: size_t N > constexpr ArrayRef ( const T ( & p ) [ N ] ) : ArrayRef ( p , N ) { }"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::ArrayRef<T>(const std::initializer_list<T> &)","Filename":"poplar/ArrayRef.hpp","Text":"constexpr ArrayRef ( const std :: initializer_list < T > & list ) : ArrayRef ( list . begin ( ) , list . size ( ) ) { }"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::ArrayRef<T>(const ArrayRef<T> &)","Filename":"poplar/ArrayRef.hpp","Text":"constexpr ArrayRef ( const ArrayRef & ) = default"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::data()","Filename":"poplar/ArrayRef.hpp","Text":"constexpr const T * data ( ) const { return ptr ; }"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::size()","Filename":"poplar/ArrayRef.hpp","Text":"constexpr std :: size_t size ( ) const { return len ; }"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::empty()","Filename":"poplar/ArrayRef.hpp","Text":"constexpr bool empty ( ) const { return len == 0 ; }"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::front()","Filename":"poplar/ArrayRef.hpp","Text":"const T & front ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::operator[](std::size_t)","Filename":"poplar/ArrayRef.hpp","Text":"const T & operator [ ] ( std :: size_t i ) const"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::begin()","Filename":"poplar/ArrayRef.hpp","Text":"const_iterator begin ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::end()","Filename":"poplar/ArrayRef.hpp","Text":"const_iterator end ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::cbegin()","Filename":"poplar/ArrayRef.hpp","Text":"const_iterator cbegin ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::cend()","Filename":"poplar/ArrayRef.hpp","Text":"const_iterator cend ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::cloneAsVector()","Filename":"poplar/ArrayRef.hpp","Text":"std :: vector < T > cloneAsVector ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::max_size()","Filename":"poplar/ArrayRef.hpp","Text":"std :: size_t max_size ( ) const"}
{"Token type":"FunctionTemplate","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::operator==(const ArrayRef<T> &, const ArrayRef<T> &)","Filename":"poplar/ArrayRef.hpp","Text":"template < class T > inline bool operator == ( const ArrayRef < T > & l , const ArrayRef < T > & r )"}
{"Token type":"FunctionTemplate","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::operator!=(const ArrayRef<T> &, const ArrayRef<T> &)","Filename":"poplar/ArrayRef.hpp","Text":"template < class T > inline bool operator != ( const ArrayRef < T > & l , const ArrayRef < T > & r )"}
{"Token type":"StructDecl","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef","Filename":"poplar/StringRef.hpp","Text":"struct StringRef : public ArrayRef < char > { constexpr StringRef ( ) : ArrayRef ( nullptr , 0 ) { } constexpr StringRef ( const StringRef & ) = default ; StringRef ( std :: nullptr_t ) = delete ; StringRef ( const std :: string & s ) : ArrayRef ( s . data ( ) , s . size ( ) ) { } constexpr StringRef ( const char * p , std :: size_t len ) : ArrayRef ( p , len ) { } StringRef ( const char * p ) : ArrayRef ( p , std :: strlen ( p ) ) { } // String literal will always be null terminated hence N-1: template < std :: size_t N > constexpr StringRef ( const char ( & p ) [ N ] ) : ArrayRef ( p , N - 1 ) { } std :: string cloneAsString ( ) const { return std :: string ( begin ( ) , size ( ) ) ; } operator std :: string ( ) const { return cloneAsString ( ) ; } }"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef::StringRef()","Filename":"poplar/StringRef.hpp","Text":"constexpr StringRef ( ) : ArrayRef ( nullptr , 0 ) { }"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef::StringRef(const poplar::StringRef &)","Filename":"poplar/StringRef.hpp","Text":"constexpr StringRef ( const StringRef & ) = default"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef::StringRef(std::nullptr_t)","Filename":"poplar/StringRef.hpp","Text":"StringRef ( std :: nullptr_t ) = delete"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef::StringRef(const std::string &)","Filename":"poplar/StringRef.hpp","Text":"StringRef ( const std :: string & s )"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef::StringRef(const char *, std::size_t)","Filename":"poplar/StringRef.hpp","Text":"constexpr StringRef ( const char * p , std :: size_t len ) : ArrayRef ( p , len ) { }"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef::StringRef(const char *)","Filename":"poplar/StringRef.hpp","Text":"StringRef ( const char * p )"}
{"Token type":"FunctionTemplate","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef::StringRef(const char (&)[N])","Filename":"poplar/StringRef.hpp","Text":"template < std :: size_t N > constexpr StringRef ( const char ( & p ) [ N ] ) : ArrayRef ( p , N - 1 ) { }"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef::cloneAsString()","Filename":"poplar/StringRef.hpp","Text":"std :: string cloneAsString ( ) const"}
{"Token type":"FunctionDecl","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::operator==(poplar::StringRef, poplar::StringRef)","Filename":"poplar/StringRef.hpp","Text":"inline bool operator == ( StringRef l , StringRef r )"}
{"Token type":"FunctionDecl","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::operator!=(poplar::StringRef, poplar::StringRef)","Filename":"poplar/StringRef.hpp","Text":"inline bool operator != ( StringRef l , StringRef r )"}
{"Token type":"FunctionDecl","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<(poplar::StringRef, poplar::StringRef)","Filename":"poplar/StringRef.hpp","Text":"inline bool operator < ( StringRef l , StringRef r )"}
{"Token type":"FunctionDecl","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::operator+(poplar::StringRef, poplar::StringRef)","Filename":"poplar/StringRef.hpp","Text":"inline std :: string operator + ( StringRef l , StringRef r )"}
{"Token type":"FunctionDecl","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::operator+=(std::string &, poplar::StringRef)","Filename":"poplar/StringRef.hpp","Text":"inline std :: string & operator += ( std :: string & s , StringRef r )"}
{"Token type":"FunctionDecl","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<<(std::ostream &, const poplar::StringRef &)","Filename":"poplar/StringRef.hpp","Text":"inline std :: ostream & operator << ( std :: ostream & os , const StringRef & s )"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::OptionFlags","Filename":"poplar/OptionFlags.hpp","Text":"class OptionFlags"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::OptionFlagsIterator","Filename":"poplar/OptionFlags.hpp","Text":"class OptionFlagsIterator"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue","Filename":"poplar/OptionFlags.hpp","Text":"class ProfileValue"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::OptionFlags","Filename":"poplar/OptionFlags.hpp","Text":"class OptionFlags { public : using OptionFlag = std :: pair < const std :: string , std :: string > ; using initializer_list = std :: initializer_list < OptionFlag > ; class iterator : public std :: iterator < std :: forward_iterator_tag , OptionFlag > { std :: unique_ptr < core :: OptionFlagsIterator > impl ; iterator ( std :: unique_ptr < core :: OptionFlagsIterator > && p ) noexcept ; friend class OptionFlags ; public : iterator ( const iterator & other ) ; iterator & operator = ( const iterator & other ) ; iterator ( iterator && other ) noexcept ; iterator & operator = ( iterator && other ) noexcept ; ~ iterator ( ) ; const OptionFlag & operator * ( ) const ; const OptionFlag * operator -> ( ) const ; bool operator == ( const iterator & other ) const ; bool operator != ( const iterator & other ) const { return ! ( * this == other ) ; } iterator & operator ++ ( ) ; iterator operator ++ ( int ) { iterator it ( * this ) ; ++ ( * this ) ; return it ; } } ; public : /** Construct a set of option flags.\n   *\n   *  The default constructor creates an empty set of flags.\n   */ OptionFlags ( ) ; ~ OptionFlags ( ) ; OptionFlags ( const OptionFlags & other ) ; OptionFlags ( OptionFlags && other ) ; OptionFlags & operator = ( const OptionFlags & other ) ; OptionFlags & operator = ( OptionFlags && other ) ; /** Option flags are an exact match\n   *\n   * Each collection contains the same keys, and both collections have the same\n   * values for each key\n   */ bool operator == ( const OptionFlags & other ) const ; /** Construct a set of option flags from an initializer\n   *  list of string pairs. Flags are set in the order they\n   *  appear in the constructor.\n   *\n   *  Setting a flag more than once will result in the previous\n   *  value for that option being overwritten.\n   *\n   * \\param initializer A list of option/value string pairs to\n   *                    set in the flags.\n   */ OptionFlags ( initializer_list && list ) : OptionFlags ( ) { set ( std :: move ( list ) ) ; } /** Set option flags from an initializer list of string\n   *  pairs. Flags are set in the order they appear in the\n   *  list.\n   *\n   *  Setting a flag more than once will result in the\n   *  previous value for that option being overwritten. If the\n   *  option was already set in these flags then the previous\n   *  value will be overwritten.\n   *\n   * \\param initializer A list of option/value string pairs to\n   *                    set in the flags.\n   */ void set ( initializer_list && list ) ; /** Set a single option to a value. If the option was already\n   *  set in these flags then the previous value will be over-\n   *  written.\n   *\n   * \\param option  The option to set in the flags.\n   * \\param value   The value to set the option to in the flags.\n   */ void set ( StringRef option , StringRef value ) ; /** Retrieves the value of the given option. If the option does not exist,\n   * then an exception is thrown.\n   *\n   * \\param option  The option to retrieve in the flags.\n   */ StringRef at ( StringRef option ) const ; /** Remove all set flags.\n   */ void clear ( ) ; /** Get iterators for the currently set option flags.\n   *  All iterators are invalidated when a new flag is set or\n   *  the option flags are re-assigned.\n   */ iterator begin ( ) const ; iterator end ( ) const ; // Implementation private : std :: unique_ptr < core :: OptionFlags > impl ; }"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator","Filename":"poplar/OptionFlags.hpp","Text":"class iterator : public std :: iterator < std :: forward_iterator_tag , OptionFlag > { std :: unique_ptr < core :: OptionFlagsIterator > impl ; iterator ( std :: unique_ptr < core :: OptionFlagsIterator > && p ) noexcept ; friend class OptionFlags ; public : iterator ( const iterator & other ) ; iterator & operator = ( const iterator & other ) ; iterator ( iterator && other ) noexcept ; iterator & operator = ( iterator && other ) noexcept ; ~ iterator ( ) ; const OptionFlag & operator * ( ) const ; const OptionFlag * operator -> ( ) const ; bool operator == ( const iterator & other ) const ; bool operator != ( const iterator & other ) const { return ! ( * this == other ) ; } iterator & operator ++ ( ) ; iterator operator ++ ( int ) { iterator it ( * this ) ; ++ ( * this ) ; return it ; } }"}
{"Token type":"CXXConstructor","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::iterator(std::unique_ptr<core::OptionFlagsIterator> &&)","Filename":"poplar/OptionFlags.hpp","Text":"iterator ( std :: unique_ptr < core :: OptionFlagsIterator > && p ) noexcept"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::iterator(const poplar::OptionFlags::iterator &)","Filename":"poplar/OptionFlags.hpp","Text":"iterator ( const iterator & other )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::operator=(const poplar::OptionFlags::iterator &)","Filename":"poplar/OptionFlags.hpp","Text":"iterator & operator = ( const iterator & other )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::iterator(poplar::OptionFlags::iterator &&)","Filename":"poplar/OptionFlags.hpp","Text":"iterator ( iterator && other ) noexcept"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::operator=(poplar::OptionFlags::iterator &&)","Filename":"poplar/OptionFlags.hpp","Text":"iterator & operator = ( iterator && other ) noexcept"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::operator*()","Filename":"poplar/OptionFlags.hpp","Text":"const OptionFlag & operator * ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::operator->()","Filename":"poplar/OptionFlags.hpp","Text":"const OptionFlag * operator -> ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::operator==(const poplar::OptionFlags::iterator &)","Filename":"poplar/OptionFlags.hpp","Text":"bool operator == ( const iterator & other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::operator!=(const poplar::OptionFlags::iterator &)","Filename":"poplar/OptionFlags.hpp","Text":"bool operator != ( const iterator & other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::operator++()","Filename":"poplar/OptionFlags.hpp","Text":"iterator & operator ++ ( )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::operator++(int)","Filename":"poplar/OptionFlags.hpp","Text":"iterator operator ++ ( int )"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::OptionFlags()","Filename":"poplar/OptionFlags.hpp","Text":"OptionFlags ( )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::OptionFlags::OptionFlags(const poplar::OptionFlags &)","Filename":"poplar/OptionFlags.hpp","Text":"OptionFlags ( const OptionFlags & other )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::OptionFlags(poplar::OptionFlags &&)","Filename":"poplar/OptionFlags.hpp","Text":"OptionFlags ( OptionFlags && other )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::operator=(const poplar::OptionFlags &)","Filename":"poplar/OptionFlags.hpp","Text":"OptionFlags & operator = ( const OptionFlags & other )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::operator=(poplar::OptionFlags &&)","Filename":"poplar/OptionFlags.hpp","Text":"OptionFlags & operator = ( OptionFlags && other )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::operator==(const poplar::OptionFlags &)","Filename":"poplar/OptionFlags.hpp","Text":"bool operator == ( const OptionFlags & other ) const"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::OptionFlags(poplar::OptionFlags::initializer_list &&)","Filename":"poplar/OptionFlags.hpp","Text":"OptionFlags ( initializer_list && list )"}
{"Token type":"CXXMethod","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::set(poplar::OptionFlags::initializer_list &&)","Filename":"poplar/OptionFlags.hpp","Text":"void set ( initializer_list && list )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::OptionFlags::set(poplar::StringRef, poplar::StringRef)","Filename":"poplar/OptionFlags.hpp","Text":"void set ( StringRef option , StringRef value )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::OptionFlags::at(poplar::StringRef)","Filename":"poplar/OptionFlags.hpp","Text":"StringRef at ( StringRef option ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::OptionFlags::clear()","Filename":"poplar/OptionFlags.hpp","Text":"void clear ( )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::OptionFlags::begin()","Filename":"poplar/OptionFlags.hpp","Text":"iterator begin ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::OptionFlags::end()","Filename":"poplar/OptionFlags.hpp","Text":"iterator end ( ) const"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::getAsProfileValue(const poplar::OptionFlags &)","Filename":"poplar/OptionFlags.hpp","Text":"ProfileValue getAsProfileValue ( const OptionFlags & flags )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::readJSON(poplar::StringRef, poplar::OptionFlags &)","Filename":"poplar/OptionFlags.hpp","Text":"void readJSON ( StringRef string , OptionFlags & flags )"}
{"Token type":"FunctionDecl","FaliureReason":"istream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::readJSON(std::istream &, poplar::OptionFlags &)","Filename":"poplar/OptionFlags.hpp","Text":"void readJSON ( std :: istream & stream , OptionFlags & flags )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::GlobalExchangeFlow","Filename":"poplar/GlobalExchangeConstraints.hpp","Text":"struct GlobalExchangeFlow { unsigned src ; unsigned dst ; GlobalExchangeFlow ( unsigned src , unsigned dst ) : src ( src ) , dst ( dst ) { } bool operator == ( const GlobalExchangeFlow & other ) const { return std :: tie ( src , dst ) == std :: tie ( other . src , other . dst ) ; } bool operator < ( const GlobalExchangeFlow & other ) const { return std :: tie ( src , dst ) < std :: tie ( other . src , other . dst ) ; } }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::GlobalExchangeFlow::GlobalExchangeFlow(unsigned int, unsigned int)","Filename":"poplar/GlobalExchangeConstraints.hpp","Text":"GlobalExchangeFlow ( unsigned src , unsigned dst )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::GlobalExchangeFlow::operator==(const poplar::GlobalExchangeFlow &)","Filename":"poplar/GlobalExchangeConstraints.hpp","Text":"bool operator == ( const GlobalExchangeFlow & other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::GlobalExchangeFlow::operator<(const poplar::GlobalExchangeFlow &)","Filename":"poplar/GlobalExchangeConstraints.hpp","Text":"bool operator < ( const GlobalExchangeFlow & other ) const"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::GlobalExchangeConstraint","Filename":"poplar/GlobalExchangeConstraints.hpp","Text":"struct GlobalExchangeConstraint { /// Bandwidth in bits per second. double bandwidth ; /// The flows that the constraint applies to. std :: vector < GlobalExchangeFlow > flows ; GlobalExchangeConstraint ( double bandwidth , ArrayRef < GlobalExchangeFlow > flows ) : bandwidth ( bandwidth ) , flows ( flows . cloneAsVector ( ) ) { } bool operator == ( const GlobalExchangeConstraint & other ) const { return std :: tie ( bandwidth , flows ) == std :: tie ( other . bandwidth , other . flows ) ; } bool operator < ( const GlobalExchangeConstraint & other ) const { return std :: tie ( bandwidth , flows ) < std :: tie ( other . bandwidth , other . flows ) ; } }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::GlobalExchangeConstraint::GlobalExchangeConstraint(double, ArrayRef<poplar::GlobalExchangeFlow>)","Filename":"poplar/GlobalExchangeConstraints.hpp","Text":"GlobalExchangeConstraint ( double bandwidth , ArrayRef < GlobalExchangeFlow > flows )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::GlobalExchangeConstraint::operator==(const poplar::GlobalExchangeConstraint &)","Filename":"poplar/GlobalExchangeConstraints.hpp","Text":"bool operator == ( const GlobalExchangeConstraint & other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::GlobalExchangeConstraint::operator<(const poplar::GlobalExchangeConstraint &)","Filename":"poplar/GlobalExchangeConstraints.hpp","Text":"bool operator < ( const GlobalExchangeConstraint & other ) const"}
{"Token type":"EnumDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::IpuLinkConfiguration","Filename":"poplar/IpuLinkConfiguration.hpp","Text":"enum class IpuLinkConfiguration { Default , // Fully connects up to 16 IPUs in a ladder. SlidingWindow , // Connects IPUs so that they can only communicate with a // number of neighbours above and below. BarleyTwist , // Same as Sliding window with the addition of the IPUs forming // a ring. None , // No configuration. }"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::IpuLinkConfiguration::Default","Filename":"poplar/IpuLinkConfiguration.hpp","Text":"Default"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::IpuLinkConfiguration::SlidingWindow","Filename":"poplar/IpuLinkConfiguration.hpp","Text":"SlidingWindow"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::IpuLinkConfiguration::BarleyTwist","Filename":"poplar/IpuLinkConfiguration.hpp","Text":"BarleyTwist"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::IpuLinkConfiguration::None","Filename":"poplar/IpuLinkConfiguration.hpp","Text":"None"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<<(std::ostream &, poplar::IpuLinkConfiguration)","Filename":"poplar/IpuLinkConfiguration.hpp","Text":"std :: ostream & operator << ( std :: ostream & os , IpuLinkConfiguration ic )"}
{"Token type":"EnumDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::IpuLinkTopology","Filename":"poplar/IpuLinkTopology.hpp","Text":"enum class IpuLinkTopology { Mesh , Torus , }"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::IpuLinkTopology::Mesh","Filename":"poplar/IpuLinkTopology.hpp","Text":"Mesh"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::IpuLinkTopology::Torus","Filename":"poplar/IpuLinkTopology.hpp","Text":"Torus"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<<(std::ostream &, poplar::IpuLinkTopology)","Filename":"poplar/IpuLinkTopology.hpp","Text":"std :: ostream & operator << ( std :: ostream & os , IpuLinkTopology topo )"}
{"Token type":"EnumDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::TargetType","Filename":"poplar/TargetType.hpp","Text":"enum class TargetType { IPU , ///< Run on real IPU hardware. IPU_MODEL , ///< Model of the IPU which actually runs on the CPU but behaves ///  like an IPU. CPU ///< Run code on the CPU. This does not accurately replicate all /// the functionality of an IPU and should only be used for running /// simple tests. }"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::TargetType::IPU","Filename":"poplar/TargetType.hpp","Text":"IPU"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::TargetType::IPU_MODEL","Filename":"poplar/TargetType.hpp","Text":"IPU_MODEL"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::TargetType::CPU","Filename":"poplar/TargetType.hpp","Text":"CPU"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::toString(poplar::TargetType)","Filename":"poplar/TargetType.hpp","Text":"std :: string toString ( TargetType t )"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::Type","Filename":"poplar/Type.hpp","Text":"class Type"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Type","Filename":"poplar/Type.hpp","Text":"class Type { public : Type ( ) ; ~ Type ( ) ; Type ( const Type & other ) ; Type ( Type && other ) ; Type & operator = ( const Type & other ) ; Type & operator = ( Type && other ) ; /** Get a string representation on a type.\n   *\n   *  \\return A string representation of the type.\n   */ StringRef toString ( ) const ; bool operator == ( const Type & other ) const ; bool operator != ( const Type & other ) const { return ! ( * this == other ) ; } bool operator < ( const Type & other ) const ; // Implementation Type ( std :: unique_ptr < core :: Type > ) ; const core :: Type & getImpl ( ) const { return * impl ; } private : std :: unique_ptr < core :: Type > impl ; }"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::Type()","Filename":"poplar/Type.hpp","Text":"Type ( )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Type::Type(const poplar::Type &)","Filename":"poplar/Type.hpp","Text":"Type ( const Type & other )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::Type(poplar::Type &&)","Filename":"poplar/Type.hpp","Text":"Type ( Type && other )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::operator=(const poplar::Type &)","Filename":"poplar/Type.hpp","Text":"Type & operator = ( const Type & other )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::operator=(poplar::Type &&)","Filename":"poplar/Type.hpp","Text":"Type & operator = ( Type && other )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Type::toString()","Filename":"poplar/Type.hpp","Text":"StringRef toString ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::operator==(const poplar::Type &)","Filename":"poplar/Type.hpp","Text":"bool operator == ( const Type & other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::operator!=(const poplar::Type &)","Filename":"poplar/Type.hpp","Text":"bool operator != ( const Type & other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::operator<(const poplar::Type &)","Filename":"poplar/Type.hpp","Text":"bool operator < ( const Type & other ) const"}
{"Token type":"CXXConstructor","FaliureReason":"unique_ptr_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::Type(std::unique_ptr<core::Type>)","Filename":"poplar/Type.hpp","Text":"Type ( std :: unique_ptr < core :: Type > )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::getImpl()","Filename":"poplar/Type.hpp","Text":"const core :: Type & getImpl ( ) const"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<<(std::ostream &, const poplar::Type &)","Filename":"poplar/Type.hpp","Text":"inline std :: ostream & operator << ( std :: ostream & os , const Type & t )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<bool>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( bool , BOOL )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<char>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( char , CHAR )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<unsigned char>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( unsigned char , UNSIGNED_CHAR )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<signed char>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( signed char , SIGNED_CHAR )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<unsigned short>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( unsigned short , UNSIGNED_SHORT )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<short>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( signed short , SHORT )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<unsigned int>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( unsigned int , UNSIGNED_INT )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<int>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( signed int , INT )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<unsigned long>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( unsigned long , UNSIGNED_LONG )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<long>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( signed long , LONG )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<unsigned long long>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( unsigned long long , UNSIGNED_LONGLONG )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<long long>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( signed long long , LONGLONG )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<float>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( float , FLOAT )"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::Target","Filename":"poplar/Target.hpp","Text":"class Target"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target","Filename":"poplar/Target.hpp","Text":"class Target { public : Target ( ) ; ~ Target ( ) ; Target ( const Target & ) ; Target ( Target && ) ; Target & operator = ( const Target & ) ; Target & operator = ( Target && ) ; bool operator == ( const Target & ) const ; bool operator != ( const Target & ) const ; bool operator < ( const Target & ) const ; /// The target type. TargetType getTargetType ( ) const ; /// The target architecture. StringRef getTargetArchString ( ) const ; /// The number of IPUs. unsigned getNumIPUs ( ) const ; /// The number of tiles per IPU. unsigned getTilesPerIPU ( ) const ; /// The number of worker contexts per tile. unsigned getNumWorkerContexts ( ) const ; /// Bytes of memory per tile. unsigned getBytesPerTile ( ) const ; /// The bandwidth of internal IPU exchange in bytes per cycle. unsigned getExchangeBytesPerCycle ( ) const ; /// The maximum bandwidth for internal data copies on a tile. unsigned getMemcpyBytesPerCycle ( ) const ; /// The IPU sync delay for the tile that is closest to the sync controller. unsigned getMinIPUSyncDelay ( ) const ; /// The number of clock cycles required to synchronize all IPUs. unsigned getGlobalSyncCycles ( ) const ; /// Memory element offsets. const std :: vector < unsigned > & getMemoryElementOffsets ( ) const ; /// Memory element offset index for interleaved memory. unsigned getInterleavedMemoryElementIndex ( ) const ; /// Set of constraints that provide a lower bound on the time it takes to /// send data between IPUs. const std :: vector < GlobalExchangeConstraint > & getGlobalExchangeConstraints ( ) const ; // The number of stride bits. unsigned getNumStrideBits ( ) const ; /// The width of the load/store data path within the tile. unsigned getDataPathWidth ( ) const ; /// The maximum pipeline depth of the convolution units within the tile for /// fp16. unsigned getFp16ConvUnitMaxPipelineDepth ( ) const ; /// The maximum pipeline depth of the convolution units within the tile for /// fp32. unsigned getFp32ConvUnitMaxPipelineDepth ( ) const ; /// The number of input elements loaded per cycle in f16 convolution unit. unsigned getFp16ConvUnitInputLoadElemsPerCycle ( ) const ; /// The number of input elements loaded per cycle in f32 convolution unit. unsigned getFp32ConvUnitInputLoadElemsPerCycle ( ) const ; /// The number of convolution units in the tile that can be used /// when partial results are outputs as 16-bits and inputs are 16 bits. unsigned getFp16InFp16OutConvUnitsPerTile ( ) const ; /// The number of convolution units in the tile that can be used /// when partial results are outputs as 32-bits and inputs are 16 bits. unsigned getFp16InFp32OutConvUnitsPerTile ( ) const ; /// The number of convolution units in the tile that can be used /// when accumulating to 32 bit values. unsigned getFp32InFp32OutConvUnitsPerTile ( ) const ; /// The number of convolutional weights that can be loaded in a cycle. unsigned getConvUnitCoeffLoadBytesPerCycle ( ) const ; // rpt counters max value. unsigned getRptCountMax ( ) const ; /// Whether tiles can share the local exchange bus during exchange. bool supportsExchangeBusSharing ( ) const ; /// The number of consecutive tiles that can share the exchange bus. unsigned getTilesPerSharedExchangeBus ( ) const ; /// Get the total number of tiles for this target (tiles per IPU * number /// of IPUs). unsigned getNumTiles ( ) const ; /// Get the total amount of memory on this target, across all IPUs. std :: uint64_t getMemoryBytes ( ) const ; /// How many floats can be processed in one vector operation. Equivalent to /// getDataPathWidth() / 32. unsigned getFloatVectorWidth ( ) const ; /// How many halves can be processed in one vector operation. Equivalent to /// getDataPathWidth() / 16. unsigned getHalfVectorWidth ( ) const ; /// How many of the given type can be processed in one vector operation. unsigned getVectorWidth ( const poplar :: Type & type ) const ; unsigned getWeightsPerConvUnit ( bool floatActivations ) const ; unsigned getConvUnitInputLoadElemsPerCycle ( bool floatActivations ) const ; /// Get the maximum number of cycles required for an IPU sync in the best /// case scenario (all tiles are immediately ready). unsigned getMaxIPUSyncDelay ( ) const ; /// Get the tile clock frequency in Hertz. double getTileClockFrequency ( ) const ; /// Get the number of tiles per exchange-block context (with repair). unsigned getNumTilesPerXBContext ( ) const ; /// Get the number of contexts per exchange-block. unsigned getNumContextsPerXB ( ) const ; /// Get the size of a given type in bytes. std :: size_t getTypeSize ( const Type & ) const ; /** Get the granularity of atomic stores that can be made by independent\n   * parallel worker threads.\n   * \\returns The granularity in bytes.\n   */ std :: size_t getAtomicStoreGranularity ( ) const ; /** Generate a value that could be written to Floating Point Initial\n   *  Control Value register CSR_S.FP_ICTL in order to configure it\n   *  with the specified options.\n   *\n   * \\param inv      If true, a floating-point invalid operation (defined by\n   *                 IEEE 754) will cause an exception. \\n\n   *                 The invalid operations are:\n   *                 - Addition or subtraction where the operands\n   *                   are + or - infinity (inf) and the operation results\n   *                   in the subtraction of two infs; for example:\n   *                   (-inf)+(+inf) or (+inf)-(+inf).\n   *                 - Divisions: (+/-0)/(+/-0) and (+/-inf)/(+/-inf).\n   *                 - Multiplications: (+/-0)*(+/-inf) and (+/-inf)*(+/-0).\n   *                 - Remainder: x REM y where y=0 or x=(+/-inf)\n   *                 - Real operations with complex results such as the\n   *                   square root or logarithm of a negative number.\n   *                 - Operations with Not-a-Number as at least one operand.\n   *                 - Comparisons where one of the operands is Not-a-Number.\n   *                 \\n See also nanoo below.\n   * \\param div      If true a floating point divide by zero operation will\n   *                 cause an exception\n   * \\param oflo     If true a floating point overflow will cause an\n   *                 exception\n   * \\param esr      Enable stochastic rounding\n   * \\param nanoo    Enable Not-a-Number on overflow mode.  When enabled half\n   *                 precision calculations that have overflowed will\n   *                 produce a Not-a-Number result, rather than\n   *                 saturating to the half precision max/min value, and the\n   *                 invalid operation (`inv`) flag will be set\n   */ uint32_t makeFpIctlValue ( bool inv , bool div0 , bool oflo , bool esr , bool nanoo ) const ; /** Return the register index of the Floating Point Initial Control\n   *  Value register CSR_S.FP_ICTL\n   */ unsigned getFpIctlRegIndex ( ) const ; /// Return the register index of CSR_C.DBG_DATA unsigned getDbgDataRegIndex ( ) const ; /// Return the ipu link configuration of this target. IpuLinkConfiguration getIpuLinkConfiguration ( ) const ; /// Return the IPU link topology. IpuLinkTopology getIpuLinkTopology ( ) const ; /** Return the size of the IPU link domain. That is the number of IPUs that\n   *  are connected via IPU links.\n   */ unsigned getIpuLinkDomainSize ( ) const ; /** Create a \"virtual\" target consisting of a subset of the target's tiles.\n   *\n   *  This method returns a target object that references the same state as\n   *  this target but only uses a subset of the target's tiles.\n   *\n   *  \\param numIPUs     The number of IPUs the target should be for.\n   *  \\param tilesPerIPU The number of tiles per IPU.\n   *\n   *  \\returns The virtual target object.\n   */ Target createVirtualTarget ( unsigned numIPUs , unsigned tilesPerIPU ) const ; /** Create a CPU target.\n   *\n   *  Create a target for executing a simple graph on the CPU. This target\n   *  will have 1 IPU with 1 tile on 1 worker thread.\n   *\n   *  This should only be used for simple functional testing.\n   *\n   *  \\returns A Target object that can be used to create a graph.\n   */ static Target createCPUTarget ( bool accurateHalf = false ) ; /** Create an IPU target.\n   *\n   *  Create an IPU target with a specified number of IPUs based on\n   *  the given system type.\n   *\n   *  \\param numIPUs    The number of IPUs the target should be for.\n   *  \\param systemType The ID of the system. Possible options: `\"ipu1\"`\n   *  \\param opts The option passed to the target.\n   *  \\returns A Target object that can be used to create a graph.\n   */ static Target createIPUTarget ( unsigned numIPUs , StringRef systemType , const OptionFlags & opts = { } ) ; /** Create an IPU target with a virtual number of tiles.\n   *\n   *  Create an IPU target with a specified number of IPUs based on\n   *  the given system type. In addition, the number of tiles can be\n   *  restricted to a smaller virtual number of observable tiles.\n   *\n   *  \\param numIPUs    The number of IPUs the target should be for.\n   *  \\param tilesPerIPU The number of tiles per IPU.\n   *  \\param systemType The ID of the system. Possible options: `\"ipu1\"`\n   *  \\param opts The option passed to the target.\n   *  \\returns A Target object that can be used to create a graph.\n   */ static Target createIPUTarget ( unsigned numIPUs , unsigned tilesPerIPU , StringRef systemType , const OptionFlags & opts = { } ) ; // Implementation Target ( std :: unique_ptr < core :: Target > ) ; core :: Target & getImpl ( ) const { return * impl ; } private : std :: unique_ptr < core :: Target > impl ; }"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::Target()","Filename":"poplar/Target.hpp","Text":"Target ( )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::Target(const poplar::Target &)","Filename":"poplar/Target.hpp","Text":"Target ( const Target & )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::Target(poplar::Target &&)","Filename":"poplar/Target.hpp","Text":"Target ( Target && )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::operator=(const poplar::Target &)","Filename":"poplar/Target.hpp","Text":"Target & operator = ( const Target & )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::operator=(poplar::Target &&)","Filename":"poplar/Target.hpp","Text":"Target & operator = ( Target && )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::operator==(const poplar::Target &)","Filename":"poplar/Target.hpp","Text":"bool operator == ( const Target & ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::operator!=(const poplar::Target &)","Filename":"poplar/Target.hpp","Text":"bool operator != ( const Target & ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::operator<(const poplar::Target &)","Filename":"poplar/Target.hpp","Text":"bool operator < ( const Target & ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::getTargetType()","Filename":"poplar/Target.hpp","Text":"TargetType getTargetType ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::getTargetArchString()","Filename":"poplar/Target.hpp","Text":"StringRef getTargetArchString ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::getNumIPUs()","Filename":"poplar/Target.hpp","Text":"unsigned getNumIPUs ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::getTilesPerIPU()","Filename":"poplar/Target.hpp","Text":"unsigned getTilesPerIPU ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::getNumWorkerContexts()","Filename":"poplar/Target.hpp","Text":"unsigned getNumWorkerContexts ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::getBytesPerTile()","Filename":"poplar/Target.hpp","Text":"unsigned getBytesPerTile ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::getExchangeBytesPerCycle()","Filename":"poplar/Target.hpp","Text":"unsigned getExchangeBytesPerCycle ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::getMemcpyBytesPerCycle()","Filename":"poplar/Target.hpp","Text":"unsigned getMemcpyBytesPerCycle ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::getMinIPUSyncDelay()","Filename":"poplar/Target.hpp","Text":"unsigned getMinIPUSyncDelay ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::getGlobalSyncCycles()","Filename":"poplar/Target.hpp","Text":"unsigned getGlobalSyncCycles ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::getMemoryElementOffsets()","Filename":"poplar/Target.hpp","Text":"const std :: vector < unsigned > & getMemoryElementOffsets ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::getInterleavedMemoryElementIndex()","Filename":"poplar/Target.hpp","Text":"unsigned getInterleavedMemoryElementIndex ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::getGlobalExchangeConstraints()","Filename":"poplar/Target.hpp","Text":"const std :: vector < GlobalExchangeConstraint > & getGlobalExchangeConstraints ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::getNumStrideBits()","Filename":"poplar/Target.hpp","Text":"unsigned getNumStrideBits ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::getDataPathWidth()","Filename":"poplar/Target.hpp","Text":"unsigned getDataPathWidth ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::getFp16ConvUnitMaxPipelineDepth()","Filename":"poplar/Target.hpp","Text":"unsigned getFp16ConvUnitMaxPipelineDepth ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::getFp32ConvUnitMaxPipelineDepth()","Filename":"poplar/Target.hpp","Text":"unsigned getFp32ConvUnitMaxPipelineDepth ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::getFp16ConvUnitInputLoadElemsPerCycle()","Filename":"poplar/Target.hpp","Text":"unsigned getFp16ConvUnitInputLoadElemsPerCycle ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::getFp32ConvUnitInputLoadElemsPerCycle()","Filename":"poplar/Target.hpp","Text":"unsigned getFp32ConvUnitInputLoadElemsPerCycle ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::getFp16InFp16OutConvUnitsPerTile()","Filename":"poplar/Target.hpp","Text":"unsigned getFp16InFp16OutConvUnitsPerTile ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::getFp16InFp32OutConvUnitsPerTile()","Filename":"poplar/Target.hpp","Text":"unsigned getFp16InFp32OutConvUnitsPerTile ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::getFp32InFp32OutConvUnitsPerTile()","Filename":"poplar/Target.hpp","Text":"unsigned getFp32InFp32OutConvUnitsPerTile ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::getConvUnitCoeffLoadBytesPerCycle()","Filename":"poplar/Target.hpp","Text":"unsigned getConvUnitCoeffLoadBytesPerCycle ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::getRptCountMax()","Filename":"poplar/Target.hpp","Text":"unsigned getRptCountMax ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::supportsExchangeBusSharing()","Filename":"poplar/Target.hpp","Text":"bool supportsExchangeBusSharing ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::getTilesPerSharedExchangeBus()","Filename":"poplar/Target.hpp","Text":"unsigned getTilesPerSharedExchangeBus ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::getNumTiles()","Filename":"poplar/Target.hpp","Text":"unsigned getNumTiles ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::getMemoryBytes()","Filename":"poplar/Target.hpp","Text":"std :: uint64_t getMemoryBytes ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::getFloatVectorWidth()","Filename":"poplar/Target.hpp","Text":"unsigned getFloatVectorWidth ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::getHalfVectorWidth()","Filename":"poplar/Target.hpp","Text":"unsigned getHalfVectorWidth ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::getVectorWidth(const poplar::Type &)","Filename":"poplar/Target.hpp","Text":"unsigned getVectorWidth ( const poplar :: Type & type ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::getWeightsPerConvUnit(bool)","Filename":"poplar/Target.hpp","Text":"unsigned getWeightsPerConvUnit ( bool floatActivations ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::getConvUnitInputLoadElemsPerCycle(bool)","Filename":"poplar/Target.hpp","Text":"unsigned getConvUnitInputLoadElemsPerCycle ( bool floatActivations ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::getMaxIPUSyncDelay()","Filename":"poplar/Target.hpp","Text":"unsigned getMaxIPUSyncDelay ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::getTileClockFrequency()","Filename":"poplar/Target.hpp","Text":"double getTileClockFrequency ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::getNumTilesPerXBContext()","Filename":"poplar/Target.hpp","Text":"unsigned getNumTilesPerXBContext ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::getNumContextsPerXB()","Filename":"poplar/Target.hpp","Text":"unsigned getNumContextsPerXB ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::getTypeSize(const poplar::Type &)","Filename":"poplar/Target.hpp","Text":"std :: size_t getTypeSize ( const Type & ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::getAtomicStoreGranularity()","Filename":"poplar/Target.hpp","Text":"std :: size_t getAtomicStoreGranularity ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::makeFpIctlValue(bool, bool, bool, bool, bool)","Filename":"poplar/Target.hpp","Text":"uint32_t makeFpIctlValue ( bool inv , bool div0 , bool oflo , bool esr , bool nanoo ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::getFpIctlRegIndex()","Filename":"poplar/Target.hpp","Text":"unsigned getFpIctlRegIndex ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::getDbgDataRegIndex()","Filename":"poplar/Target.hpp","Text":"unsigned getDbgDataRegIndex ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::getIpuLinkConfiguration()","Filename":"poplar/Target.hpp","Text":"IpuLinkConfiguration getIpuLinkConfiguration ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::getIpuLinkTopology()","Filename":"poplar/Target.hpp","Text":"IpuLinkTopology getIpuLinkTopology ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::getIpuLinkDomainSize()","Filename":"poplar/Target.hpp","Text":"unsigned getIpuLinkDomainSize ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::createVirtualTarget(unsigned int, unsigned int)","Filename":"poplar/Target.hpp","Text":"Target createVirtualTarget ( unsigned numIPUs , unsigned tilesPerIPU ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::createCPUTarget(bool)","Filename":"poplar/Target.hpp","Text":"static Target createCPUTarget ( bool accurateHalf = false )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::createIPUTarget(unsigned int, poplar::StringRef, const poplar::OptionFlags &)","Filename":"poplar/Target.hpp","Text":"static Target createIPUTarget ( unsigned numIPUs , StringRef systemType , const OptionFlags & opts = { } )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Target::createIPUTarget(unsigned int, unsigned int, poplar::StringRef, const poplar::OptionFlags &)","Filename":"poplar/Target.hpp","Text":"static Target createIPUTarget ( unsigned numIPUs , unsigned tilesPerIPU , StringRef systemType , const OptionFlags & opts = { } )"}
{"Token type":"CXXConstructor","FaliureReason":"unique_ptr_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::Target(std::unique_ptr<core::Target>)","Filename":"poplar/Target.hpp","Text":"Target ( std :: unique_ptr < core :: Target > )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::getImpl()","Filename":"poplar/Target.hpp","Text":"core :: Target & getImpl ( ) const"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::copyDeviceHalfToFloat(const poplar::Target &, const void *, float *, std::size_t)","Filename":"poplar/Target.hpp","Text":"void copyDeviceHalfToFloat ( const Target & target , const void * src , float * dst , std :: size_t numElements )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::copyFloatToDeviceHalf(const poplar::Target &, const float *, void *, std::size_t)","Filename":"poplar/Target.hpp","Text":"void copyFloatToDeviceHalf ( const Target & target , const float * src , void * dst , std :: size_t numElements )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::copyDeviceHalfToDouble(const poplar::Target &, const void *, double *, std::size_t)","Filename":"poplar/Target.hpp","Text":"void copyDeviceHalfToDouble ( const Target & target , const void * src , double * dst , std :: size_t numElements )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::copyDoubleToDeviceHalf(const poplar::Target &, const double *, void *, std::size_t)","Filename":"poplar/Target.hpp","Text":"void copyDoubleToDeviceHalf ( const Target & target , const double * src , void * dst , std :: size_t numElements )"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::Device","Filename":"poplar/Device.hpp","Text":"class Device"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Device","Filename":"poplar/Device.hpp","Text":"class Device { public : Device ( ) ; Device ( Device && ) ; virtual ~ Device ( ) ; Device & operator = ( Device && ) ; // A Device can not be copied or assigned in order to preserve the // attach/detach state of underlying hardware. Device ( const Device & ) = delete ; Device & operator = ( const Device & ) = delete ; /// Get the numerical ID of this device as known by the DeviceManager. unsigned getId ( ) const ; /// Get the target description of the device. const Target & getTarget ( ) const ; /// Try and acquire this device and lock it to the current process. bool attach ( ) const ; /// Release this device to other processes. void detach ( ) const ; /// Temporarily detach from this device so it can be reattached to without /// reloading the executable. The behaviour is undefined if another process /// acquires and uses the device inbetween. Use of this method is /// strongly discouraged and it will be removed in future. void temporarilyDetach ( ) const ; /// Retrieve driver version of the attached device. /// /// Throws if the device is not attached or is not an IPU device. void getDriverVersion ( unsigned & major , unsigned & minor , unsigned & point ) const ; /// Retrieve Remote Buffers availability from attached device /// /// Throws if the device is not attached or is not an IPU device. bool supportsRemoteBuffers ( ) const ; /// Retrieve Remote Buffers availability from attached device /// /// Throws if the device is not attached or is not an IPU device. /// Deprecated, please use supportsRemoteBuffers() bool supportsGraphStreaming ( ) const ; std :: map < std :: string , std :: string > getAttributes ( ) const ; /// Get the list of driver device IDs that make up this device. std :: vector < unsigned > getDriverIDs ( ) const ; /// Reset the device's state. void reset ( ) const ; /// Create a virtual device with a restricted number of tiles per IPU. /// /// This method provides a smaller \"virtual\" device whose target only /// shows a subset of the tiles on the underlying device. /// /// The calling object becomes a null device (the underlying device is moved /// into the returned Device object). Device createVirtualDevice ( unsigned tilesPerIPU ) ; /** Create a device that executes vertex code on the host CPU.\n   *  This is only suitable for running small amounts of code; for example, for\n   *  functional testing. It may not reproduce exactly the same functionality\n   *  as running on an IPU. Also, functions such as\n   *  Engine::getTileClockFrequency() may not return meaningful results.\n   *\n   */ static Device createCPUDevice ( ) ; /* [Graphcore Internal Use]\n   *\n   * Create a device that runs code on the IPU simulator.\n   *\n   * The current options are:\n   *\n   * * `debug.trace` (true, false) [=false]\n   *\n   *   Enables debug tracing\n   *\n   * * `sim.simulateFullDevice` (true, false) [=false]\n   *\n   *    Controls whether simulation is over all tiles that the\n   *    hardware would have, even if the target has fewer used tiles\n   *\n   * * `sim.accurateTiming` (true, false) [=true]\n   *\n   *    Controls improved modelling of execution, which can be slower to\n   *    evalute.\n   *\n   * Options can be overridden with the environment variable\n   * `POPLAR_SIMULATOR_OPTIONS`. For example:\n   *\n   *     POPLAR_SIMULATOR_OPTIONS='{\"sim.simulateFullDevice\":\"true\"}'\n   *\n   * \\param target  The target simulator.\n   * \\param options Options for simulation.\n   */ static Device createSimulatorDevice ( const Target & target , const OptionFlags & options = { } ) ; // Implementation Device ( std :: unique_ptr < core :: Device > ) ; core :: Device & getImpl ( ) const { return * impl ; } private : Target target ; std :: unique_ptr < core :: Device > impl ; }"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::Device::Device()","Filename":"poplar/Device.hpp","Text":"Device ( )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Device::Device(poplar::Device &&)","Filename":"poplar/Device.hpp","Text":"Device ( Device && )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Device::operator=(poplar::Device &&)","Filename":"poplar/Device.hpp","Text":"Device & operator = ( Device && )"}
{"Token type":"CXXConstructor","FaliureReason":"deleted_method","Implemented":false,"Namespace":"poplar","Name":"poplar::Device::Device(const poplar::Device &)","Filename":"poplar/Device.hpp","Text":"Device ( const Device & ) = delete"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Device::operator=(const poplar::Device &)","Filename":"poplar/Device.hpp","Text":"Device & operator = ( const Device & ) = delete"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Device::getId()","Filename":"poplar/Device.hpp","Text":"unsigned getId ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Device::getTarget()","Filename":"poplar/Device.hpp","Text":"const Target & getTarget ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Device::attach()","Filename":"poplar/Device.hpp","Text":"bool attach ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Device::detach()","Filename":"poplar/Device.hpp","Text":"void detach ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Device::temporarilyDetach()","Filename":"poplar/Device.hpp","Text":"void temporarilyDetach ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Device::getDriverVersion(unsigned int &, unsigned int &, unsigned int &)","Filename":"poplar/Device.hpp","Text":"void getDriverVersion ( unsigned & major , unsigned & minor , unsigned & point ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Device::supportsRemoteBuffers()","Filename":"poplar/Device.hpp","Text":"bool supportsRemoteBuffers ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Device::supportsGraphStreaming()","Filename":"poplar/Device.hpp","Text":"bool supportsGraphStreaming ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Device::getAttributes()","Filename":"poplar/Device.hpp","Text":"std :: map < std :: string , std :: string > getAttributes ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Device::getDriverIDs()","Filename":"poplar/Device.hpp","Text":"std :: vector < unsigned > getDriverIDs ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Device::reset()","Filename":"poplar/Device.hpp","Text":"void reset ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Device::createVirtualDevice(unsigned int)","Filename":"poplar/Device.hpp","Text":"Device createVirtualDevice ( unsigned tilesPerIPU )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Device::createCPUDevice()","Filename":"poplar/Device.hpp","Text":"static Device createCPUDevice ( )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Device::createSimulatorDevice(const poplar::Target &, const poplar::OptionFlags &)","Filename":"poplar/Device.hpp","Text":"static Device createSimulatorDevice ( const Target & target , const OptionFlags & options = { } )"}
{"Token type":"CXXConstructor","FaliureReason":"unique_ptr_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Device::Device(std::unique_ptr<core::Device>)","Filename":"poplar/Device.hpp","Text":"Device ( std :: unique_ptr < core :: Device > )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Device::getImpl()","Filename":"poplar/Device.hpp","Text":"core :: Device & getImpl ( ) const"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::DeviceManagerImpl","Filename":"poplar/DeviceManager.hpp","Text":"class DeviceManagerImpl"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::DeviceManager","Filename":"poplar/DeviceManager.hpp","Text":"class DeviceManager { public : DeviceManager ( ) ; DeviceManager ( const DeviceManager & ) ; DeviceManager ( DeviceManager && ) ; virtual ~ DeviceManager ( ) ; /// Get the number of devices attached to this host. std :: size_t getNumDevices ( ) const ; /// Get the list of all devices. std :: vector < Device > getDevices ( const OptionFlags & opts = { } ) const ; /** Get the list of all devices fulfilling the specified criteria.\n   * \\param type The desired target type (IPU, IPU_Model, CPU)\n   * \\param requiredNumIPUs Number of IPUs required\n   * \\param opts The arguments passed to the target (optional)\n   * \\returns A matching device\n   */ std :: vector < Device > getDevices ( TargetType type , unsigned requiredNumIPUs , const OptionFlags & opts = { } ) const ; /** Get a specific device by its device manager id.\n   * \\param deviceManagerId The ID of the requested device. The ID is that\n   *                        returned by the `gc-info` command. This can\n   *                        specify a single device or a group of devices.\n   * \\param opts The arguments passed to the target (optional)\n   * \\returns A matching device\n   */ Device getDevice ( unsigned deviceManagerId , const OptionFlags & opts = { } ) const ; /** Get the deviceIds of the child devices of a multi-IPU device.\n   *\n   *  A multi-IPU device will fully overlap \"child\" devices that are made out\n   *  of the same IPUs. This method returns the set of child devices.\n   *\n   *  \\param parentId  The device ID of the parent device\n   */ std :: vector < unsigned > getChildDeviceIds ( unsigned parentId ) const ; /// Create a device manager for the current host. static DeviceManager createDeviceManager ( ) ; private : std :: unique_ptr < core :: DeviceManagerImpl > impl ; }"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::DeviceManager::DeviceManager()","Filename":"poplar/DeviceManager.hpp","Text":"DeviceManager ( )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::DeviceManager::DeviceManager(const poplar::DeviceManager &)","Filename":"poplar/DeviceManager.hpp","Text":"DeviceManager ( const DeviceManager & )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::DeviceManager::DeviceManager(poplar::DeviceManager &&)","Filename":"poplar/DeviceManager.hpp","Text":"DeviceManager ( DeviceManager && )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::DeviceManager::getNumDevices()","Filename":"poplar/DeviceManager.hpp","Text":"std :: size_t getNumDevices ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::DeviceManager::getDevices(const poplar::OptionFlags &)","Filename":"poplar/DeviceManager.hpp","Text":"std :: vector < Device > getDevices ( const OptionFlags & opts = { } ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::DeviceManager::getDevices(poplar::TargetType, unsigned int, const poplar::OptionFlags &)","Filename":"poplar/DeviceManager.hpp","Text":"std :: vector < Device > getDevices ( TargetType type , unsigned requiredNumIPUs , const OptionFlags & opts = { } ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::DeviceManager::getDevice(unsigned int, const poplar::OptionFlags &)","Filename":"poplar/DeviceManager.hpp","Text":"Device getDevice ( unsigned deviceManagerId , const OptionFlags & opts = { } ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::DeviceManager::getChildDeviceIds(unsigned int)","Filename":"poplar/DeviceManager.hpp","Text":"std :: vector < unsigned > getChildDeviceIds ( unsigned parentId ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::DeviceManager::createDeviceManager()","Filename":"poplar/DeviceManager.hpp","Text":"static DeviceManager createDeviceManager ( )"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::ArrayRef<T>(std::nullptr_t)","Filename":"poplar/ArrayRef.hpp","Text":"ArrayRef ( std :: nullptr_t ) = delete"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::ArrayRef<T>()","Filename":"poplar/ArrayRef.hpp","Text":"constexpr ArrayRef ( ) : ptr ( nullptr ) , len ( 0 ) { }"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::ArrayRef<T>(const T *, std::size_t)","Filename":"poplar/ArrayRef.hpp","Text":"constexpr ArrayRef ( const T * p , std :: size_t size ) : ptr ( p ) , len ( size ) { }"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::ArrayRef<T>(const std::vector<T> &)","Filename":"poplar/ArrayRef.hpp","Text":"ArrayRef ( const std :: vector < T > & v )"}
{"Token type":"FunctionTemplate","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::ArrayRef<T>(const std::array<T, N> &)","Filename":"poplar/ArrayRef.hpp","Text":"template < std :: size_t N > constexpr ArrayRef ( const std :: array < T , N > & a ) : ArrayRef ( a . data ( ) , N ) { }"}
{"Token type":"FunctionTemplate","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::ArrayRef<T>(const T (&)[N])","Filename":"poplar/ArrayRef.hpp","Text":"template < std :: size_t N > constexpr ArrayRef ( const T ( & p ) [ N ] ) : ArrayRef ( p , N ) { }"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::ArrayRef<T>(const std::initializer_list<T> &)","Filename":"poplar/ArrayRef.hpp","Text":"constexpr ArrayRef ( const std :: initializer_list < T > & list ) : ArrayRef ( list . begin ( ) , list . size ( ) ) { }"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::ArrayRef<T>(const ArrayRef<T> &)","Filename":"poplar/ArrayRef.hpp","Text":"constexpr ArrayRef ( const ArrayRef & ) = default"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::data()","Filename":"poplar/ArrayRef.hpp","Text":"constexpr const T * data ( ) const { return ptr ; }"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::size()","Filename":"poplar/ArrayRef.hpp","Text":"constexpr std :: size_t size ( ) const { return len ; }"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::empty()","Filename":"poplar/ArrayRef.hpp","Text":"constexpr bool empty ( ) const { return len == 0 ; }"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::front()","Filename":"poplar/ArrayRef.hpp","Text":"const T & front ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::operator[](std::size_t)","Filename":"poplar/ArrayRef.hpp","Text":"const T & operator [ ] ( std :: size_t i ) const"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::begin()","Filename":"poplar/ArrayRef.hpp","Text":"const_iterator begin ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::end()","Filename":"poplar/ArrayRef.hpp","Text":"const_iterator end ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::cbegin()","Filename":"poplar/ArrayRef.hpp","Text":"const_iterator cbegin ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::cend()","Filename":"poplar/ArrayRef.hpp","Text":"const_iterator cend ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::cloneAsVector()","Filename":"poplar/ArrayRef.hpp","Text":"std :: vector < T > cloneAsVector ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::max_size()","Filename":"poplar/ArrayRef.hpp","Text":"std :: size_t max_size ( ) const"}
{"Token type":"FunctionTemplate","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::operator==(const ArrayRef<T> &, const ArrayRef<T> &)","Filename":"poplar/ArrayRef.hpp","Text":"template < class T > inline bool operator == ( const ArrayRef < T > & l , const ArrayRef < T > & r )"}
{"Token type":"FunctionTemplate","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::operator!=(const ArrayRef<T> &, const ArrayRef<T> &)","Filename":"poplar/ArrayRef.hpp","Text":"template < class T > inline bool operator != ( const ArrayRef < T > & l , const ArrayRef < T > & r )"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::Executable","Filename":"poplar/Executable.hpp","Text":"class Executable"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Executable","Filename":"poplar/Executable.hpp","Text":"class Executable { public : ~ Executable ( ) ; Executable ( Executable && other ) ; Executable & operator = ( Executable && other ) ; /** Serialize an executable to a stream. All of the binary files and\n   * metadata needed to run a Poplar executable will be written to the stream.\n   * Currently the format is opaque, and compatibility between different\n   * versions of Poplar is not guaranteed.\n   *\n   * \\param out  The stream to write to. It must be seekable.\n   *\n   * \\throws poplar_error if the target is not an IPU - this cannot be\n   *         used to serialise CPU or IPU_MODEL executables.\n   */ void serialize ( std :: ostream & out ) const ; /** Load an executable from a stream.\n   *\n   * \\param in  The stream to read from. It must be seekable.\n   */ static Executable deserialize ( std :: istream & in ) ; // Implementation explicit Executable ( std :: unique_ptr < core :: Executable > impl ) ; friend class Engine ; const core :: Executable & getImpl ( ) const { return * impl ; } ; private : std :: unique_ptr < core :: Executable > impl ; }"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Executable::Executable(poplar::Executable &&)","Filename":"poplar/Executable.hpp","Text":"Executable ( Executable && other )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Executable::operator=(poplar::Executable &&)","Filename":"poplar/Executable.hpp","Text":"Executable & operator = ( Executable && other )"}
{"Token type":"CXXMethod","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Executable::serialize(std::ostream &)","Filename":"poplar/Executable.hpp","Text":"void serialize ( std :: ostream & out ) const"}
{"Token type":"CXXMethod","FaliureReason":"istream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Executable::deserialize(std::istream &)","Filename":"poplar/Executable.hpp","Text":"static Executable deserialize ( std :: istream & in )"}
{"Token type":"CXXConstructor","FaliureReason":"unique_ptr_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Executable::Executable(std::unique_ptr<core::Executable>)","Filename":"poplar/Executable.hpp","Text":"explicit Executable ( std :: unique_ptr < core :: Executable > impl )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Executable::getImpl()","Filename":"poplar/Executable.hpp","Text":"const core :: Executable & getImpl ( ) const"}
{"Token type":"EnumDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::CodeletFileType","Filename":"poplar/CodeletFileType.hpp","Text":"enum class CodeletFileType { PreprocessedAsmSource , /**< A graph assembly language source file */ AsmSource , /**< A graph assembly language file with preprocessor macros */ CSource , /**< A graph C source file */ CppSource , /**< A graph C++ source file */ IrSource , /**< A graph LLVM IR source file */ Object , /**< A graph program object file. */ Auto /**< Auto detect based on file name */ }"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::CodeletFileType::PreprocessedAsmSource","Filename":"poplar/CodeletFileType.hpp","Text":"PreprocessedAsmSource"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::CodeletFileType::AsmSource","Filename":"poplar/CodeletFileType.hpp","Text":"AsmSource"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::CodeletFileType::CSource","Filename":"poplar/CodeletFileType.hpp","Text":"CSource"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::CodeletFileType::CppSource","Filename":"poplar/CodeletFileType.hpp","Text":"CppSource"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::CodeletFileType::IrSource","Filename":"poplar/CodeletFileType.hpp","Text":"IrSource"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::CodeletFileType::Object","Filename":"poplar/CodeletFileType.hpp","Text":"Object"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::CodeletFileType::Auto","Filename":"poplar/CodeletFileType.hpp","Text":"Auto"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::getCodeletFileType(const char *)","Filename":"poplar/CodeletFileType.hpp","Text":"CodeletFileType getCodeletFileType ( const char * path )"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar","Name":"poplar::VertexIntrospector","Filename":"poplar/CycleEstimateFunc.hpp","Text":"class VertexIntrospector"}
{"Token type":"EnumDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::DataStreamType","Filename":"poplar/DataStreamType.hpp","Text":"enum class DataStreamType { HostToDeviceFIFO , ///< A DataStream from host to device DeviceToHostFIFO , ///< A DataStream from device to host HostToDeviceBuffer , ///< A stream from host to device in a remote buffer DeviceToHostBuffer , ///< A stream from device to host in a remote buffer }"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::DataStreamType::HostToDeviceFIFO","Filename":"poplar/DataStreamType.hpp","Text":"HostToDeviceFIFO"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::DataStreamType::DeviceToHostFIFO","Filename":"poplar/DataStreamType.hpp","Text":"DeviceToHostFIFO"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::DataStreamType::HostToDeviceBuffer","Filename":"poplar/DataStreamType.hpp","Text":"HostToDeviceBuffer"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::DataStreamType::DeviceToHostBuffer","Filename":"poplar/DataStreamType.hpp","Text":"DeviceToHostBuffer"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::isDeviceToHost(poplar::DataStreamType)","Filename":"poplar/DataStreamType.hpp","Text":"bool isDeviceToHost ( DataStreamType type )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::isHostToDevice(poplar::DataStreamType)","Filename":"poplar/DataStreamType.hpp","Text":"bool isHostToDevice ( DataStreamType type )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::isRemoteBuffer(poplar::DataStreamType)","Filename":"poplar/DataStreamType.hpp","Text":"bool isRemoteBuffer ( DataStreamType type )"}
{"Token type":"EnumDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::ReplicatedStreamMode","Filename":"poplar/ReplicatedStreamMode.hpp","Text":"enum class ReplicatedStreamMode { REPLICATE , ///< Create a stream per replica. BROADCAST , ///< Create a single stream whose data is implicitly broadcast to ///< every replica. }"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::ReplicatedStreamMode::REPLICATE","Filename":"poplar/ReplicatedStreamMode.hpp","Text":"REPLICATE"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::ReplicatedStreamMode::BROADCAST","Filename":"poplar/ReplicatedStreamMode.hpp","Text":"BROADCAST"}
{"Token type":"StructDecl","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef","Filename":"poplar/StringRef.hpp","Text":"struct StringRef : public ArrayRef < char > { constexpr StringRef ( ) : ArrayRef ( nullptr , 0 ) { } constexpr StringRef ( const StringRef & ) = default ; StringRef ( std :: nullptr_t ) = delete ; StringRef ( const std :: string & s ) : ArrayRef ( s . data ( ) , s . size ( ) ) { } constexpr StringRef ( const char * p , std :: size_t len ) : ArrayRef ( p , len ) { } StringRef ( const char * p ) : ArrayRef ( p , std :: strlen ( p ) ) { } // String literal will always be null terminated hence N-1: template < std :: size_t N > constexpr StringRef ( const char ( & p ) [ N ] ) : ArrayRef ( p , N - 1 ) { } std :: string cloneAsString ( ) const { return std :: string ( begin ( ) , size ( ) ) ; } operator std :: string ( ) const { return cloneAsString ( ) ; } }"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef::StringRef()","Filename":"poplar/StringRef.hpp","Text":"constexpr StringRef ( ) : ArrayRef ( nullptr , 0 ) { }"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef::StringRef(const poplar::StringRef &)","Filename":"poplar/StringRef.hpp","Text":"constexpr StringRef ( const StringRef & ) = default"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef::StringRef(std::nullptr_t)","Filename":"poplar/StringRef.hpp","Text":"StringRef ( std :: nullptr_t ) = delete"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef::StringRef(const std::string &)","Filename":"poplar/StringRef.hpp","Text":"StringRef ( const std :: string & s )"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef::StringRef(const char *, std::size_t)","Filename":"poplar/StringRef.hpp","Text":"constexpr StringRef ( const char * p , std :: size_t len ) : ArrayRef ( p , len ) { }"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef::StringRef(const char *)","Filename":"poplar/StringRef.hpp","Text":"StringRef ( const char * p )"}
{"Token type":"FunctionTemplate","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef::StringRef(const char (&)[N])","Filename":"poplar/StringRef.hpp","Text":"template < std :: size_t N > constexpr StringRef ( const char ( & p ) [ N ] ) : ArrayRef ( p , N - 1 ) { }"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef::cloneAsString()","Filename":"poplar/StringRef.hpp","Text":"std :: string cloneAsString ( ) const"}
{"Token type":"FunctionDecl","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::operator==(poplar::StringRef, poplar::StringRef)","Filename":"poplar/StringRef.hpp","Text":"inline bool operator == ( StringRef l , StringRef r )"}
{"Token type":"FunctionDecl","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::operator!=(poplar::StringRef, poplar::StringRef)","Filename":"poplar/StringRef.hpp","Text":"inline bool operator != ( StringRef l , StringRef r )"}
{"Token type":"FunctionDecl","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<(poplar::StringRef, poplar::StringRef)","Filename":"poplar/StringRef.hpp","Text":"inline bool operator < ( StringRef l , StringRef r )"}
{"Token type":"FunctionDecl","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::operator+(poplar::StringRef, poplar::StringRef)","Filename":"poplar/StringRef.hpp","Text":"inline std :: string operator + ( StringRef l , StringRef r )"}
{"Token type":"FunctionDecl","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::operator+=(std::string &, poplar::StringRef)","Filename":"poplar/StringRef.hpp","Text":"inline std :: string & operator += ( std :: string & s , StringRef r )"}
{"Token type":"FunctionDecl","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<<(std::ostream &, const poplar::StringRef &)","Filename":"poplar/StringRef.hpp","Text":"inline std :: ostream & operator << ( std :: ostream & os , const StringRef & s )"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::Type","Filename":"poplar/Type.hpp","Text":"class Type"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::Type()","Filename":"poplar/Type.hpp","Text":"Type ( )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::Type(poplar::Type &&)","Filename":"poplar/Type.hpp","Text":"Type ( Type && other )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::operator=(const poplar::Type &)","Filename":"poplar/Type.hpp","Text":"Type & operator = ( const Type & other )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::operator=(poplar::Type &&)","Filename":"poplar/Type.hpp","Text":"Type & operator = ( Type && other )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::operator==(const poplar::Type &)","Filename":"poplar/Type.hpp","Text":"bool operator == ( const Type & other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::operator!=(const poplar::Type &)","Filename":"poplar/Type.hpp","Text":"bool operator != ( const Type & other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::operator<(const poplar::Type &)","Filename":"poplar/Type.hpp","Text":"bool operator < ( const Type & other ) const"}
{"Token type":"CXXConstructor","FaliureReason":"unique_ptr_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::Type(std::unique_ptr<core::Type>)","Filename":"poplar/Type.hpp","Text":"Type ( std :: unique_ptr < core :: Type > )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::getImpl()","Filename":"poplar/Type.hpp","Text":"const core :: Type & getImpl ( ) const"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<<(std::ostream &, const poplar::Type &)","Filename":"poplar/Type.hpp","Text":"inline std :: ostream & operator << ( std :: ostream & os , const Type & t )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<bool>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( bool , BOOL )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<char>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( char , CHAR )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<unsigned char>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( unsigned char , UNSIGNED_CHAR )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<signed char>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( signed char , SIGNED_CHAR )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<unsigned short>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( unsigned short , UNSIGNED_SHORT )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<short>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( signed short , SHORT )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<unsigned int>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( unsigned int , UNSIGNED_INT )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<int>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( signed int , INT )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<unsigned long>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( unsigned long , UNSIGNED_LONG )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<long>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( signed long , LONG )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<unsigned long long>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( unsigned long long , UNSIGNED_LONGLONG )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<long long>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( signed long long , LONGLONG )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<float>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( float , FLOAT )"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::DataStreamRef","Filename":"poplar/DataStream.hpp","Text":"class DataStreamRef"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::RemoteBufferRef","Filename":"poplar/DataStream.hpp","Text":"class RemoteBufferRef"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::DataStream","Filename":"poplar/DataStream.hpp","Text":"class DataStream { public : DataStream ( ) ; DataStream ( const DataStream & ) ; DataStream ( DataStream && ) ; ~ DataStream ( ) ; DataStream & operator = ( const DataStream & ) ; DataStream & operator = ( DataStream && ) ; std :: string handle ( ) const ; std :: size_t numElements ( ) const ; unsigned replicationFactor ( ) const ; ReplicatedStreamMode replicatedMode ( ) const ; DataStreamType type ( ) const ; Type elementType ( ) const ; // Implementation DataStream ( std :: unique_ptr < core :: DataStreamRef > ) ; const core :: DataStreamRef & getImpl ( ) const { return * impl ; } private : std :: unique_ptr < core :: DataStreamRef > impl ; }"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::DataStream::DataStream()","Filename":"poplar/DataStream.hpp","Text":"DataStream ( )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::DataStream::DataStream(const poplar::DataStream &)","Filename":"poplar/DataStream.hpp","Text":"DataStream ( const DataStream & )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::DataStream::DataStream(poplar::DataStream &&)","Filename":"poplar/DataStream.hpp","Text":"DataStream ( DataStream && )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::DataStream::operator=(const poplar::DataStream &)","Filename":"poplar/DataStream.hpp","Text":"DataStream & operator = ( const DataStream & )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::DataStream::operator=(poplar::DataStream &&)","Filename":"poplar/DataStream.hpp","Text":"DataStream & operator = ( DataStream && )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::DataStream::handle()","Filename":"poplar/DataStream.hpp","Text":"std :: string handle ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::DataStream::numElements()","Filename":"poplar/DataStream.hpp","Text":"std :: size_t numElements ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::DataStream::replicationFactor()","Filename":"poplar/DataStream.hpp","Text":"unsigned replicationFactor ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::DataStream::replicatedMode()","Filename":"poplar/DataStream.hpp","Text":"ReplicatedStreamMode replicatedMode ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::DataStream::type()","Filename":"poplar/DataStream.hpp","Text":"DataStreamType type ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::DataStream::elementType()","Filename":"poplar/DataStream.hpp","Text":"Type elementType ( ) const"}
{"Token type":"CXXConstructor","FaliureReason":"unique_ptr_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::DataStream::DataStream(std::unique_ptr<core::DataStreamRef>)","Filename":"poplar/DataStream.hpp","Text":"DataStream ( std :: unique_ptr < core :: DataStreamRef > )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::DataStream::getImpl()","Filename":"poplar/DataStream.hpp","Text":"const core :: DataStreamRef & getImpl ( ) const"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::RemoteBuffer","Filename":"poplar/DataStream.hpp","Text":"class RemoteBuffer { public : RemoteBuffer ( ) ; RemoteBuffer ( const RemoteBuffer & ) ; RemoteBuffer ( RemoteBuffer && ) ; ~ RemoteBuffer ( ) ; RemoteBuffer & operator = ( const RemoteBuffer & ) ; RemoteBuffer & operator = ( RemoteBuffer && ) ; std :: string handle ( ) const ; DataStream getIpuToHostStream ( ) const ; DataStream getHostToIpuStream ( ) const ; size_t numElements ( ) const ; size_t getRepeats ( ) const ; Type elementType ( ) const ; bool isRearrangeOnHost ( ) const ; bool isOptimisedForMemory ( ) const ; // Implementation RemoteBuffer ( std :: unique_ptr < core :: RemoteBufferRef > ) ; const core :: RemoteBufferRef & getImpl ( ) const { return * impl ; } bool operator == ( const RemoteBuffer & b ) const ; bool operator != ( const RemoteBuffer & b ) const ; private : std :: unique_ptr < core :: RemoteBufferRef > impl ; }"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::RemoteBuffer::RemoteBuffer()","Filename":"poplar/DataStream.hpp","Text":"RemoteBuffer ( )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::RemoteBuffer::RemoteBuffer(const poplar::RemoteBuffer &)","Filename":"poplar/DataStream.hpp","Text":"RemoteBuffer ( const RemoteBuffer & )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::RemoteBuffer::RemoteBuffer(poplar::RemoteBuffer &&)","Filename":"poplar/DataStream.hpp","Text":"RemoteBuffer ( RemoteBuffer && )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::RemoteBuffer::operator=(const poplar::RemoteBuffer &)","Filename":"poplar/DataStream.hpp","Text":"RemoteBuffer & operator = ( const RemoteBuffer & )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::RemoteBuffer::operator=(poplar::RemoteBuffer &&)","Filename":"poplar/DataStream.hpp","Text":"RemoteBuffer & operator = ( RemoteBuffer && )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::RemoteBuffer::handle()","Filename":"poplar/DataStream.hpp","Text":"std :: string handle ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::RemoteBuffer::getIpuToHostStream()","Filename":"poplar/DataStream.hpp","Text":"DataStream getIpuToHostStream ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::RemoteBuffer::getHostToIpuStream()","Filename":"poplar/DataStream.hpp","Text":"DataStream getHostToIpuStream ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::RemoteBuffer::numElements()","Filename":"poplar/DataStream.hpp","Text":"size_t numElements ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::RemoteBuffer::getRepeats()","Filename":"poplar/DataStream.hpp","Text":"size_t getRepeats ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::RemoteBuffer::elementType()","Filename":"poplar/DataStream.hpp","Text":"Type elementType ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::RemoteBuffer::isRearrangeOnHost()","Filename":"poplar/DataStream.hpp","Text":"bool isRearrangeOnHost ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::RemoteBuffer::isOptimisedForMemory()","Filename":"poplar/DataStream.hpp","Text":"bool isOptimisedForMemory ( ) const"}
{"Token type":"CXXConstructor","FaliureReason":"unique_ptr_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::RemoteBuffer::RemoteBuffer(std::unique_ptr<core::RemoteBufferRef>)","Filename":"poplar/DataStream.hpp","Text":"RemoteBuffer ( std :: unique_ptr < core :: RemoteBufferRef > )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::RemoteBuffer::getImpl()","Filename":"poplar/DataStream.hpp","Text":"const core :: RemoteBufferRef & getImpl ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::RemoteBuffer::operator==(const poplar::RemoteBuffer &)","Filename":"poplar/DataStream.hpp","Text":"bool operator == ( const RemoteBuffer & b ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::RemoteBuffer::operator!=(const poplar::RemoteBuffer &)","Filename":"poplar/DataStream.hpp","Text":"bool operator != ( const RemoteBuffer & b ) const"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::OptionFlags","Filename":"poplar/OptionFlags.hpp","Text":"class OptionFlags"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::OptionFlagsIterator","Filename":"poplar/OptionFlags.hpp","Text":"class OptionFlagsIterator"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue","Filename":"poplar/OptionFlags.hpp","Text":"class ProfileValue"}
{"Token type":"CXXConstructor","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::iterator(std::unique_ptr<core::OptionFlagsIterator> &&)","Filename":"poplar/OptionFlags.hpp","Text":"iterator ( std :: unique_ptr < core :: OptionFlagsIterator > && p ) noexcept"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::operator=(const poplar::OptionFlags::iterator &)","Filename":"poplar/OptionFlags.hpp","Text":"iterator & operator = ( const iterator & other )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::iterator(poplar::OptionFlags::iterator &&)","Filename":"poplar/OptionFlags.hpp","Text":"iterator ( iterator && other ) noexcept"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::operator=(poplar::OptionFlags::iterator &&)","Filename":"poplar/OptionFlags.hpp","Text":"iterator & operator = ( iterator && other ) noexcept"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::operator*()","Filename":"poplar/OptionFlags.hpp","Text":"const OptionFlag & operator * ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::operator->()","Filename":"poplar/OptionFlags.hpp","Text":"const OptionFlag * operator -> ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::operator==(const poplar::OptionFlags::iterator &)","Filename":"poplar/OptionFlags.hpp","Text":"bool operator == ( const iterator & other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::operator!=(const poplar::OptionFlags::iterator &)","Filename":"poplar/OptionFlags.hpp","Text":"bool operator != ( const iterator & other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::operator++()","Filename":"poplar/OptionFlags.hpp","Text":"iterator & operator ++ ( )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::operator++(int)","Filename":"poplar/OptionFlags.hpp","Text":"iterator operator ++ ( int )"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::OptionFlags()","Filename":"poplar/OptionFlags.hpp","Text":"OptionFlags ( )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::OptionFlags(poplar::OptionFlags &&)","Filename":"poplar/OptionFlags.hpp","Text":"OptionFlags ( OptionFlags && other )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::operator=(const poplar::OptionFlags &)","Filename":"poplar/OptionFlags.hpp","Text":"OptionFlags & operator = ( const OptionFlags & other )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::operator=(poplar::OptionFlags &&)","Filename":"poplar/OptionFlags.hpp","Text":"OptionFlags & operator = ( OptionFlags && other )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::operator==(const poplar::OptionFlags &)","Filename":"poplar/OptionFlags.hpp","Text":"bool operator == ( const OptionFlags & other ) const"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::OptionFlags(poplar::OptionFlags::initializer_list &&)","Filename":"poplar/OptionFlags.hpp","Text":"OptionFlags ( initializer_list && list )"}
{"Token type":"CXXMethod","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::set(poplar::OptionFlags::initializer_list &&)","Filename":"poplar/OptionFlags.hpp","Text":"void set ( initializer_list && list )"}
{"Token type":"FunctionDecl","FaliureReason":"istream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::readJSON(std::istream &, poplar::OptionFlags &)","Filename":"poplar/OptionFlags.hpp","Text":"void readJSON ( std :: istream & stream , OptionFlags & flags )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::GlobalExchangeFlow::operator==(const poplar::GlobalExchangeFlow &)","Filename":"poplar/GlobalExchangeConstraints.hpp","Text":"bool operator == ( const GlobalExchangeFlow & other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::GlobalExchangeFlow::operator<(const poplar::GlobalExchangeFlow &)","Filename":"poplar/GlobalExchangeConstraints.hpp","Text":"bool operator < ( const GlobalExchangeFlow & other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::GlobalExchangeConstraint::operator==(const poplar::GlobalExchangeConstraint &)","Filename":"poplar/GlobalExchangeConstraints.hpp","Text":"bool operator == ( const GlobalExchangeConstraint & other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::GlobalExchangeConstraint::operator<(const poplar::GlobalExchangeConstraint &)","Filename":"poplar/GlobalExchangeConstraints.hpp","Text":"bool operator < ( const GlobalExchangeConstraint & other ) const"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<<(std::ostream &, poplar::IpuLinkConfiguration)","Filename":"poplar/IpuLinkConfiguration.hpp","Text":"std :: ostream & operator << ( std :: ostream & os , IpuLinkConfiguration ic )"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<<(std::ostream &, poplar::IpuLinkTopology)","Filename":"poplar/IpuLinkTopology.hpp","Text":"std :: ostream & operator << ( std :: ostream & os , IpuLinkTopology topo )"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::Target","Filename":"poplar/Target.hpp","Text":"class Target"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::Target()","Filename":"poplar/Target.hpp","Text":"Target ( )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::Target(poplar::Target &&)","Filename":"poplar/Target.hpp","Text":"Target ( Target && )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::operator=(const poplar::Target &)","Filename":"poplar/Target.hpp","Text":"Target & operator = ( const Target & )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::operator=(poplar::Target &&)","Filename":"poplar/Target.hpp","Text":"Target & operator = ( Target && )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::operator==(const poplar::Target &)","Filename":"poplar/Target.hpp","Text":"bool operator == ( const Target & ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::operator!=(const poplar::Target &)","Filename":"poplar/Target.hpp","Text":"bool operator != ( const Target & ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::operator<(const poplar::Target &)","Filename":"poplar/Target.hpp","Text":"bool operator < ( const Target & ) const"}
{"Token type":"CXXConstructor","FaliureReason":"unique_ptr_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::Target(std::unique_ptr<core::Target>)","Filename":"poplar/Target.hpp","Text":"Target ( std :: unique_ptr < core :: Target > )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::getImpl()","Filename":"poplar/Target.hpp","Text":"core :: Target & getImpl ( ) const"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::Device","Filename":"poplar/Device.hpp","Text":"class Device"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::Device::Device()","Filename":"poplar/Device.hpp","Text":"Device ( )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Device::Device(poplar::Device &&)","Filename":"poplar/Device.hpp","Text":"Device ( Device && )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Device::operator=(poplar::Device &&)","Filename":"poplar/Device.hpp","Text":"Device & operator = ( Device && )"}
{"Token type":"CXXConstructor","FaliureReason":"deleted_method","Implemented":false,"Namespace":"poplar","Name":"poplar::Device::Device(const poplar::Device &)","Filename":"poplar/Device.hpp","Text":"Device ( const Device & ) = delete"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Device::operator=(const poplar::Device &)","Filename":"poplar/Device.hpp","Text":"Device & operator = ( const Device & ) = delete"}
{"Token type":"CXXConstructor","FaliureReason":"unique_ptr_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Device::Device(std::unique_ptr<core::Device>)","Filename":"poplar/Device.hpp","Text":"Device ( std :: unique_ptr < core :: Device > )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Device::getImpl()","Filename":"poplar/Device.hpp","Text":"core :: Device & getImpl ( ) const"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::GraphBuilder","Filename":"poplar/GraphElements.hpp","Text":"class GraphBuilder"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph","Filename":"poplar/GraphElements.hpp","Text":"class Graph"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldRef","Filename":"poplar/GraphElements.hpp","Text":"class FieldRef"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::VertexRef","Filename":"poplar/GraphElements.hpp","Text":"class VertexRef { const core :: GraphBuilder * graph ; vertex_id id ; public : VertexRef ( ) { } /** Access a field by name.\n   *\n   *  Given a vertex reference v, v[name] is a field reference.\n   *  \\param fieldName The name of the field.\n   *  \\returns A reference to the named field.\n   */ FieldRef operator [ ] ( StringRef fieldName ) const ; vertex_id getId ( ) const { return id ; } private : /** Construct a vertex reference from an ID.\n   * \\param graph The graph containing the vertex.\n   * \\ param id The id of the vertex.\n   * \\returns A reference to the vertex.\n   */ VertexRef ( const core :: GraphBuilder * graph , unsigned id ) : graph ( graph ) , id ( id ) { } friend class core :: GraphBuilder ; friend class Graph ; friend class FieldRef ; }"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::VertexRef::VertexRef()","Filename":"poplar/GraphElements.hpp","Text":"VertexRef ( )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::VertexRef::operator[](poplar::StringRef)","Filename":"poplar/GraphElements.hpp","Text":"FieldRef operator [ ] ( StringRef fieldName ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::VertexRef::getId()","Filename":"poplar/GraphElements.hpp","Text":"vertex_id getId ( ) const"}
{"Token type":"CXXConstructor","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::VertexRef::VertexRef(const core::GraphBuilder *, unsigned int)","Filename":"poplar/GraphElements.hpp","Text":"VertexRef ( const core :: GraphBuilder * graph , unsigned id )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::FieldRef","Filename":"poplar/GraphElements.hpp","Text":"class FieldRef { public : // The vertex instance this field ref is for. VertexRef vertex ; // The ID of the field within the vertex. unsigned fieldId ; // If `indexed` is true this gives the value of the index, otherwise // it is ignored. std :: size_t index ; // True if this is a references to a sub-element of the field. bool indexed ; FieldRef ( ) { } /** Access an element of a vector field.\n   *\n   *  Subscript a vector field to access the element at position `index`.\n   *  \\param index The subscript of the field\n   *  \\return A reference to the field.\n   */ FieldRef operator [ ] ( std :: size_t index ) const { return FieldRef ( vertex , fieldId , index ) ; } bool isIndexed ( ) const { return indexed ; } std :: size_t getIndex ( ) const { return index ; } private : /** FieldRef constructor from vertex id and field name.\n   *\n   *  Construct a FieldRef out of a vertex id and the\n   *  name of the field.\n   */ FieldRef ( VertexRef vertex , StringRef fieldName ) ; FieldRef ( VertexRef vertex , unsigned fieldId ) ; /** FieldRef constructor from vertex id, field name and an index.\n   *\n   *  Construct a FieldRef to a Vector field.\n   */ FieldRef ( VertexRef vertex , StringRef fieldName , std :: size_t index ) ; FieldRef ( VertexRef vertex , unsigned fieldId , std :: size_t index ) ; friend class VertexRef ; }"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldRef::FieldRef()","Filename":"poplar/GraphElements.hpp","Text":"FieldRef ( )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldRef::operator[](std::size_t)","Filename":"poplar/GraphElements.hpp","Text":"FieldRef operator [ ] ( std :: size_t index ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::FieldRef::isIndexed()","Filename":"poplar/GraphElements.hpp","Text":"bool isIndexed ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::FieldRef::getIndex()","Filename":"poplar/GraphElements.hpp","Text":"std :: size_t getIndex ( ) const"}
{"Token type":"CXXConstructor","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldRef::FieldRef(poplar::VertexRef, poplar::StringRef)","Filename":"poplar/GraphElements.hpp","Text":"FieldRef ( VertexRef vertex , StringRef fieldName )"}
{"Token type":"CXXConstructor","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldRef::FieldRef(poplar::VertexRef, unsigned int)","Filename":"poplar/GraphElements.hpp","Text":"FieldRef ( VertexRef vertex , unsigned fieldId )"}
{"Token type":"CXXConstructor","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldRef::FieldRef(poplar::VertexRef, poplar::StringRef, std::size_t)","Filename":"poplar/GraphElements.hpp","Text":"FieldRef ( VertexRef vertex , StringRef fieldName , std :: size_t index )"}
{"Token type":"CXXConstructor","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldRef::FieldRef(poplar::VertexRef, unsigned int, std::size_t)","Filename":"poplar/GraphElements.hpp","Text":"FieldRef ( VertexRef vertex , unsigned fieldId , std :: size_t index )"}
{"Token type":"CXXMethod","FaliureReason":"constructor_missing_class","Implemented":false,"Namespace":"poplar","Name":"poplar::operator[](poplar::StringRef)","Filename":"poplar/GraphElements.hpp","Text":"inline FieldRef VertexRef :: operator [ ] ( StringRef fieldName ) const"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::ComputeSet","Filename":"poplar/GraphElements.hpp","Text":"class ComputeSet { unsigned computeset_id ; public : ComputeSet ( ) { } ComputeSet ( unsigned id ) : computeset_id ( id ) { } unsigned getId ( ) const { return computeset_id ; } }"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::ComputeSet::ComputeSet()","Filename":"poplar/GraphElements.hpp","Text":"ComputeSet ( )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::ComputeSet::ComputeSet(unsigned int)","Filename":"poplar/GraphElements.hpp","Text":"ComputeSet ( unsigned id )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::ComputeSet::getId()","Filename":"poplar/GraphElements.hpp","Text":"unsigned getId ( ) const"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Function","Filename":"poplar/GraphElements.hpp","Text":"class Function { unsigned function_id ; public : Function ( ) { } Function ( unsigned id ) : function_id ( id ) { } unsigned getId ( ) const { return function_id ; } }"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::Function::Function()","Filename":"poplar/GraphElements.hpp","Text":"Function ( )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Function::Function(unsigned int)","Filename":"poplar/GraphElements.hpp","Text":"Function ( unsigned id )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Function::getId()","Filename":"poplar/GraphElements.hpp","Text":"unsigned getId ( ) const"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::MutableProfileValue","Filename":"poplar/ProfileValue.hpp","Text":"class MutableProfileValue"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::ProfileValue","Filename":"poplar/ProfileValue.hpp","Text":"class ProfileValue { public : enum class Type { BOOL_ , STRING , NUMBER , VECTOR , MAP , } ; using Boolean = bool ; using Number = double ; using String = std :: string ; using Vector = std :: vector < ProfileValue > ; using Map = std :: map < std :: string , ProfileValue > ; struct Storage { std :: aligned_union < 1 , Boolean , Number , String , Vector , Map > :: type buffer ; } ; // Get the type of this value. Type type ( ) const ; // String access. Throws if type() != Type::STRING. const String & asString ( ) const ; // Boolean access. Throws if type() != Type::BOOL_. Boolean asBool ( ) const ; // Number access (asInt() truncates). Throws if type() != Type::NUMBER. std :: int64_t asInt ( ) const ; // Number access (asUInt() truncates). Throws if type() != Type::NUMBER or not // representable as uint64_t std :: uint64_t asUint ( ) const ; double asDouble ( ) const ; // Map access. // Throws if type() != Type::MAP, or if the key does not exist. const ProfileValue & operator [ ] ( StringRef s ) const ; // Returns nullptr if the key does not exist. const ProfileValue * getOrNull ( StringRef s ) const ; const Map & asMap ( ) const ; // Array access. Throws if type() != Type::VECTOR or if it is out of range. const ProfileValue & operator [ ] ( std :: size_t i ) const ; const Vector & asVector ( ) const ; // Converts each element to std::uint64_t // Throws if type() != Type::VECTOR or element.type() != Type::NUMBER std :: vector < std :: uint64_t > toUintVector ( ) const ; // Array or map size. Throws if type() != Type::MAP && type() != Type::VECTOR. std :: size_t size ( ) const ; // If the value is a vector that only contains numbers, these return // their sum. Otherwise they throw an exception. double sumDouble ( ) const ; std :: int64_t sumInt ( ) const ; std :: uint64_t sumUint ( ) const ; // If the value is a vector of vectors of numbers return their sum. Otherwise // throw an exception. Useful eg to accumulate totals over all compute sets // across  all tiles std :: int64_t sum2DInt ( ) const ; std :: uint64_t sum2DUint ( ) const ; // Compare values for equality. Note this will involve traversing the // entire tree of values until it finds an inequality so it may be slow. bool operator == ( const ProfileValue & other ) const ; bool operator != ( const ProfileValue & other ) const ; // Default value is 0.0. ProfileValue ( ) : ProfileValue ( 0.0 ) { } ProfileValue ( String init ) ; ProfileValue ( Vector init ) ; ProfileValue ( Map init ) ; ProfileValue ( Number init ) ; explicit ProfileValue ( Boolean init ) ; // Disambiguate cast from integral type to Number template < class T , typename = typename std :: enable_if < std :: is_integral < T > :: value > :: type > ProfileValue ( T init ) : ProfileValue ( ProfileValue :: Number ( init ) ) { } // Disambiguate conversion from const char* to bool, which is preferred over // std::string ProfileValue ( const char * init ) : ProfileValue ( ProfileValue :: String ( init ) ) { } ~ ProfileValue ( ) ; ProfileValue ( const ProfileValue & other ) ; ProfileValue ( ProfileValue && other ) noexcept ; ProfileValue & operator = ( const ProfileValue & other ) ; ProfileValue & operator = ( ProfileValue && other ) noexcept ; ProfileValue & operator = ( Boolean init ) ; ProfileValue & operator = ( Number init ) ; ProfileValue & operator = ( String init ) ; ProfileValue & operator = ( Vector init ) ; ProfileValue & operator = ( Map init ) ; // Disambiguate cast from any non-boolean integral type to Number template < class T , typename = typename std :: enable_if < std :: is_integral < T > :: value > :: type > ProfileValue & operator = ( T init ) { return operator = ( ProfileValue :: Number ( init ) ) ; } private : friend class core :: MutableProfileValue ; // Size of this should be about 3 pointers (24 bytes) which uses more memory // than storing a single pointer (8 bytes) but is faster and simpler. Storage v ; Type t ; }"}
{"Token type":"EnumDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::ProfileValue::Type","Filename":"poplar/ProfileValue.hpp","Text":"enum class Type { BOOL_ , STRING , NUMBER , VECTOR , MAP , }"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::ProfileValue::Type::BOOL_","Filename":"poplar/ProfileValue.hpp","Text":"BOOL_"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::ProfileValue::Type::STRING","Filename":"poplar/ProfileValue.hpp","Text":"STRING"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::ProfileValue::Type::NUMBER","Filename":"poplar/ProfileValue.hpp","Text":"NUMBER"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::ProfileValue::Type::VECTOR","Filename":"poplar/ProfileValue.hpp","Text":"VECTOR"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::ProfileValue::Type::MAP","Filename":"poplar/ProfileValue.hpp","Text":"MAP"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::ProfileValue::Storage","Filename":"poplar/ProfileValue.hpp","Text":"struct Storage { std :: aligned_union < 1 , Boolean , Number , String , Vector , Map > :: type buffer ; }"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::ProfileValue::type()","Filename":"poplar/ProfileValue.hpp","Text":"Type type ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::ProfileValue::asString()","Filename":"poplar/ProfileValue.hpp","Text":"const String & asString ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::ProfileValue::asBool()","Filename":"poplar/ProfileValue.hpp","Text":"Boolean asBool ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::ProfileValue::asInt()","Filename":"poplar/ProfileValue.hpp","Text":"std :: int64_t asInt ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::ProfileValue::asUint()","Filename":"poplar/ProfileValue.hpp","Text":"std :: uint64_t asUint ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::ProfileValue::asDouble()","Filename":"poplar/ProfileValue.hpp","Text":"double asDouble ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::operator[](poplar::StringRef)","Filename":"poplar/ProfileValue.hpp","Text":"const ProfileValue & operator [ ] ( StringRef s ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::ProfileValue::getOrNull(poplar::StringRef)","Filename":"poplar/ProfileValue.hpp","Text":"const ProfileValue * getOrNull ( StringRef s ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::ProfileValue::asMap()","Filename":"poplar/ProfileValue.hpp","Text":"const Map & asMap ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::operator[](std::size_t)","Filename":"poplar/ProfileValue.hpp","Text":"const ProfileValue & operator [ ] ( std :: size_t i ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::ProfileValue::asVector()","Filename":"poplar/ProfileValue.hpp","Text":"const Vector & asVector ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::ProfileValue::toUintVector()","Filename":"poplar/ProfileValue.hpp","Text":"std :: vector < std :: uint64_t > toUintVector ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::ProfileValue::size()","Filename":"poplar/ProfileValue.hpp","Text":"std :: size_t size ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::ProfileValue::sumDouble()","Filename":"poplar/ProfileValue.hpp","Text":"double sumDouble ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::ProfileValue::sumInt()","Filename":"poplar/ProfileValue.hpp","Text":"std :: int64_t sumInt ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::ProfileValue::sumUint()","Filename":"poplar/ProfileValue.hpp","Text":"std :: uint64_t sumUint ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::ProfileValue::sum2DInt()","Filename":"poplar/ProfileValue.hpp","Text":"std :: int64_t sum2DInt ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::ProfileValue::sum2DUint()","Filename":"poplar/ProfileValue.hpp","Text":"std :: uint64_t sum2DUint ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::operator==(const poplar::ProfileValue &)","Filename":"poplar/ProfileValue.hpp","Text":"bool operator == ( const ProfileValue & other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::operator!=(const poplar::ProfileValue &)","Filename":"poplar/ProfileValue.hpp","Text":"bool operator != ( const ProfileValue & other ) const"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::ProfileValue()","Filename":"poplar/ProfileValue.hpp","Text":"ProfileValue ( )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::ProfileValue::ProfileValue(poplar::ProfileValue::String)","Filename":"poplar/ProfileValue.hpp","Text":"ProfileValue ( String init )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::ProfileValue::ProfileValue(poplar::ProfileValue::Vector)","Filename":"poplar/ProfileValue.hpp","Text":"ProfileValue ( Vector init )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::ProfileValue::ProfileValue(poplar::ProfileValue::Map)","Filename":"poplar/ProfileValue.hpp","Text":"ProfileValue ( Map init )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::ProfileValue::ProfileValue(poplar::ProfileValue::Number)","Filename":"poplar/ProfileValue.hpp","Text":"ProfileValue ( Number init )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::ProfileValue::ProfileValue(poplar::ProfileValue::Boolean)","Filename":"poplar/ProfileValue.hpp","Text":"explicit ProfileValue ( Boolean init )"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::ProfileValue(T)","Filename":"poplar/ProfileValue.hpp","Text":"template < class T , typename = typename std :: enable_if < std :: is_integral < T > :: value > :: type > ProfileValue ( T init )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::ProfileValue::ProfileValue(const char *)","Filename":"poplar/ProfileValue.hpp","Text":"ProfileValue ( const char * init )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::ProfileValue::ProfileValue(const poplar::ProfileValue &)","Filename":"poplar/ProfileValue.hpp","Text":"ProfileValue ( const ProfileValue & other )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::ProfileValue(poplar::ProfileValue &&)","Filename":"poplar/ProfileValue.hpp","Text":"ProfileValue ( ProfileValue && other ) noexcept"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::operator=(const poplar::ProfileValue &)","Filename":"poplar/ProfileValue.hpp","Text":"ProfileValue & operator = ( const ProfileValue & other )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::operator=(poplar::ProfileValue &&)","Filename":"poplar/ProfileValue.hpp","Text":"ProfileValue & operator = ( ProfileValue && other ) noexcept"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::operator=(poplar::ProfileValue::Boolean)","Filename":"poplar/ProfileValue.hpp","Text":"ProfileValue & operator = ( Boolean init )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::operator=(poplar::ProfileValue::Number)","Filename":"poplar/ProfileValue.hpp","Text":"ProfileValue & operator = ( Number init )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::operator=(poplar::ProfileValue::String)","Filename":"poplar/ProfileValue.hpp","Text":"ProfileValue & operator = ( String init )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::operator=(poplar::ProfileValue::Vector)","Filename":"poplar/ProfileValue.hpp","Text":"ProfileValue & operator = ( Vector init )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::operator=(poplar::ProfileValue::Map)","Filename":"poplar/ProfileValue.hpp","Text":"ProfileValue & operator = ( Map init )"}
{"Token type":"FunctionTemplate","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::operator=(T)","Filename":"poplar/ProfileValue.hpp","Text":"template < class T , typename = typename std :: enable_if < std :: is_integral < T > :: value > :: type > ProfileValue & operator = ( T init )"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::serializeToJSON(std::ostream &, const poplar::ProfileValue &, bool)","Filename":"poplar/ProfileValue.hpp","Text":"void serializeToJSON ( std :: ostream & out , const ProfileValue & val , bool prettyPrint = false )"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::serializeToCBOR(std::ostream &, const poplar::ProfileValue &, bool)","Filename":"poplar/ProfileValue.hpp","Text":"void serializeToCBOR ( std :: ostream & out , const ProfileValue & val , bool withTag = true )"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<<(std::ostream &, const poplar::ProfileValue &)","Filename":"poplar/ProfileValue.hpp","Text":"std :: ostream & operator << ( std :: ostream & os , const ProfileValue & v )"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::printGraphSummary(std::ostream &, const poplar::ProfileValue &, const poplar::OptionFlags &)","Filename":"poplar/ProfileValue.hpp","Text":"void printGraphSummary ( std :: ostream & out , const ProfileValue & graphProfile , const OptionFlags & opts )"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::printExecutionSummary(std::ostream &, const poplar::ProfileValue &, const poplar::ProfileValue &, const poplar::OptionFlags &)","Filename":"poplar/ProfileValue.hpp","Text":"void printExecutionSummary ( std :: ostream & out , const ProfileValue & graphProfile , const ProfileValue & executionProfile , const OptionFlags & opts )"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::printProfileSummary(std::ostream &, const poplar::ProfileValue &, const poplar::ProfileValue &, const poplar::OptionFlags &)","Filename":"poplar/ProfileValue.hpp","Text":"void printProfileSummary ( std :: ostream & out , const ProfileValue & graphProfile , const ProfileValue & executionProfile , const OptionFlags & opts = { } )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::poplar_error","Filename":"poplar/exceptions.hpp","Text":"struct poplar_error : std :: runtime_error { std :: string type ; explicit poplar_error ( const std :: string & s ) ; explicit poplar_error ( const char * s ) ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::poplar_error::poplar_error(const std::string &)","Filename":"poplar/exceptions.hpp","Text":"explicit poplar_error ( const std :: string & s )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::poplar_error::poplar_error(const char *)","Filename":"poplar/exceptions.hpp","Text":"explicit poplar_error ( const char * s )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::graph_program_compilation_error","Filename":"poplar/exceptions.hpp","Text":"struct graph_program_compilation_error : poplar_error { explicit graph_program_compilation_error ( const std :: string & s ) ; explicit graph_program_compilation_error ( const char * s ) ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::graph_program_compilation_error::graph_program_compilation_error(const std::string &)","Filename":"poplar/exceptions.hpp","Text":"explicit graph_program_compilation_error ( const std :: string & s )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::graph_program_compilation_error::graph_program_compilation_error(const char *)","Filename":"poplar/exceptions.hpp","Text":"explicit graph_program_compilation_error ( const char * s )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::graph_object_creation_error","Filename":"poplar/exceptions.hpp","Text":"struct graph_object_creation_error : poplar_error { explicit graph_object_creation_error ( const std :: string & s ) ; explicit graph_object_creation_error ( const char * s ) ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::graph_object_creation_error::graph_object_creation_error(const std::string &)","Filename":"poplar/exceptions.hpp","Text":"explicit graph_object_creation_error ( const std :: string & s )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::graph_object_creation_error::graph_object_creation_error(const char *)","Filename":"poplar/exceptions.hpp","Text":"explicit graph_object_creation_error ( const char * s )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::graph_object_load_error","Filename":"poplar/exceptions.hpp","Text":"struct graph_object_load_error : poplar_error { explicit graph_object_load_error ( const std :: string & path , const std :: string & error ) ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::graph_object_load_error::graph_object_load_error(const std::string &, const std::string &)","Filename":"poplar/exceptions.hpp","Text":"explicit graph_object_load_error ( const std :: string & path , const std :: string & error )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::no_environment","Filename":"poplar/exceptions.hpp","Text":"struct no_environment : poplar_error { explicit no_environment ( const std :: string & s ) ; explicit no_environment ( const char * s ) ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::no_environment::no_environment(const std::string &)","Filename":"poplar/exceptions.hpp","Text":"explicit no_environment ( const std :: string & s )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::no_environment::no_environment(const char *)","Filename":"poplar/exceptions.hpp","Text":"explicit no_environment ( const char * s )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::unknown_vertex_type","Filename":"poplar/exceptions.hpp","Text":"struct unknown_vertex_type : poplar_error { explicit unknown_vertex_type ( const std :: string & name ) ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::unknown_vertex_type::unknown_vertex_type(const std::string &)","Filename":"poplar/exceptions.hpp","Text":"explicit unknown_vertex_type ( const std :: string & name )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::unknown_field","Filename":"poplar/exceptions.hpp","Text":"struct unknown_field : poplar_error { explicit unknown_field ( const std :: string & s ) ; explicit unknown_field ( const char * s ) ; unknown_field ( const std :: string & fieldName , const std :: string & vertexTypeName ) ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::unknown_field::unknown_field(const std::string &)","Filename":"poplar/exceptions.hpp","Text":"explicit unknown_field ( const std :: string & s )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::unknown_field::unknown_field(const char *)","Filename":"poplar/exceptions.hpp","Text":"explicit unknown_field ( const char * s )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::unknown_field::unknown_field(const std::string &, const std::string &)","Filename":"poplar/exceptions.hpp","Text":"unknown_field ( const std :: string & fieldName , const std :: string & vertexTypeName )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::control_program_error","Filename":"poplar/exceptions.hpp","Text":"struct control_program_error : poplar_error { explicit control_program_error ( const std :: string & msg ) ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::control_program_error::control_program_error(const std::string &)","Filename":"poplar/exceptions.hpp","Text":"explicit control_program_error ( const std :: string & msg )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::type_error","Filename":"poplar/exceptions.hpp","Text":"struct type_error : poplar_error { explicit type_error ( const std :: string & s ) ; explicit type_error ( const char * s ) ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::type_error::type_error(const std::string &)","Filename":"poplar/exceptions.hpp","Text":"explicit type_error ( const std :: string & s )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::type_error::type_error(const char *)","Filename":"poplar/exceptions.hpp","Text":"explicit type_error ( const char * s )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::index_error","Filename":"poplar/exceptions.hpp","Text":"struct index_error : poplar_error { explicit index_error ( const std :: string & s ) ; explicit index_error ( const char * s ) ; index_error ( const std :: string & vertexDotField , std :: size_t index ) ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::index_error::index_error(const std::string &)","Filename":"poplar/exceptions.hpp","Text":"explicit index_error ( const std :: string & s )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::index_error::index_error(const char *)","Filename":"poplar/exceptions.hpp","Text":"explicit index_error ( const char * s )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::index_error::index_error(const std::string &, std::size_t)","Filename":"poplar/exceptions.hpp","Text":"index_error ( const std :: string & vertexDotField , std :: size_t index )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::no_size_specified","Filename":"poplar/exceptions.hpp","Text":"struct no_size_specified : poplar_error { explicit no_size_specified ( const std :: string & s ) ; explicit no_size_specified ( const char * s ) ; no_size_specified ( const std :: string & fieldName , const std :: string & vertexName ) ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::no_size_specified::no_size_specified(const std::string &)","Filename":"poplar/exceptions.hpp","Text":"explicit no_size_specified ( const std :: string & s )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::no_size_specified::no_size_specified(const char *)","Filename":"poplar/exceptions.hpp","Text":"explicit no_size_specified ( const char * s )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::no_size_specified::no_size_specified(const std::string &, const std::string &)","Filename":"poplar/exceptions.hpp","Text":"no_size_specified ( const std :: string & fieldName , const std :: string & vertexName )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::graph_connection_error","Filename":"poplar/exceptions.hpp","Text":"struct graph_connection_error : poplar_error { explicit graph_connection_error ( const std :: string & s ) ; explicit graph_connection_error ( const char * s ) ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::graph_connection_error::graph_connection_error(const std::string &)","Filename":"poplar/exceptions.hpp","Text":"explicit graph_connection_error ( const std :: string & s )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::graph_connection_error::graph_connection_error(const char *)","Filename":"poplar/exceptions.hpp","Text":"explicit graph_connection_error ( const char * s )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::graph_cycle_error","Filename":"poplar/exceptions.hpp","Text":"struct graph_cycle_error : poplar_error { explicit graph_cycle_error ( const std :: string & s ) ; explicit graph_cycle_error ( const char * s ) ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::graph_cycle_error::graph_cycle_error(const std::string &)","Filename":"poplar/exceptions.hpp","Text":"explicit graph_cycle_error ( const std :: string & s )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::graph_cycle_error::graph_cycle_error(const char *)","Filename":"poplar/exceptions.hpp","Text":"explicit graph_cycle_error ( const char * s )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::graph_replication_error","Filename":"poplar/exceptions.hpp","Text":"struct graph_replication_error : poplar_error { explicit graph_replication_error ( const std :: string & s ) ; explicit graph_replication_error ( const char * s ) ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::graph_replication_error::graph_replication_error(const std::string &)","Filename":"poplar/exceptions.hpp","Text":"explicit graph_replication_error ( const std :: string & s )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::graph_replication_error::graph_replication_error(const char *)","Filename":"poplar/exceptions.hpp","Text":"explicit graph_replication_error ( const char * s )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::profiling_disabled","Filename":"poplar/exceptions.hpp","Text":"struct profiling_disabled : poplar_error { profiling_disabled ( ) ; }"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::profiling_disabled::profiling_disabled()","Filename":"poplar/exceptions.hpp","Text":"profiling_disabled ( )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::missing_cycle_estimate","Filename":"poplar/exceptions.hpp","Text":"struct missing_cycle_estimate : poplar_error { explicit missing_cycle_estimate ( const std :: string & vertexName ) ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::missing_cycle_estimate::missing_cycle_estimate(const std::string &)","Filename":"poplar/exceptions.hpp","Text":"explicit missing_cycle_estimate ( const std :: string & vertexName )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::invalid_tile_mapping","Filename":"poplar/exceptions.hpp","Text":"struct invalid_tile_mapping : poplar_error { explicit invalid_tile_mapping ( const std :: string & s ) ; explicit invalid_tile_mapping ( const char * s ) ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::invalid_tile_mapping::invalid_tile_mapping(const std::string &)","Filename":"poplar/exceptions.hpp","Text":"explicit invalid_tile_mapping ( const std :: string & s )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::invalid_tile_mapping::invalid_tile_mapping(const char *)","Filename":"poplar/exceptions.hpp","Text":"explicit invalid_tile_mapping ( const char * s )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::tensor_creation_error","Filename":"poplar/exceptions.hpp","Text":"struct tensor_creation_error : poplar_error { explicit tensor_creation_error ( const std :: string & s ) ; explicit tensor_creation_error ( const char * s ) ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::tensor_creation_error::tensor_creation_error(const std::string &)","Filename":"poplar/exceptions.hpp","Text":"explicit tensor_creation_error ( const std :: string & s )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::tensor_creation_error::tensor_creation_error(const char *)","Filename":"poplar/exceptions.hpp","Text":"explicit tensor_creation_error ( const char * s )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::tensor_io_state_error","Filename":"poplar/exceptions.hpp","Text":"struct tensor_io_state_error : poplar_error { explicit tensor_io_state_error ( const std :: string & s ) ; explicit tensor_io_state_error ( const char * s ) ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::tensor_io_state_error::tensor_io_state_error(const std::string &)","Filename":"poplar/exceptions.hpp","Text":"explicit tensor_io_state_error ( const std :: string & s )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::tensor_io_state_error::tensor_io_state_error(const char *)","Filename":"poplar/exceptions.hpp","Text":"explicit tensor_io_state_error ( const char * s )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::stream_connection_error","Filename":"poplar/exceptions.hpp","Text":"struct stream_connection_error : poplar_error { explicit stream_connection_error ( const std :: string & s ) ; explicit stream_connection_error ( const char * s ) ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::stream_connection_error::stream_connection_error(const std::string &)","Filename":"poplar/exceptions.hpp","Text":"explicit stream_connection_error ( const std :: string & s )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::stream_connection_error::stream_connection_error(const char *)","Filename":"poplar/exceptions.hpp","Text":"explicit stream_connection_error ( const char * s )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::overflow_error","Filename":"poplar/exceptions.hpp","Text":"struct overflow_error : poplar_error { explicit overflow_error ( const std :: string & s ) ; explicit overflow_error ( const char * s ) ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::overflow_error::overflow_error(const std::string &)","Filename":"poplar/exceptions.hpp","Text":"explicit overflow_error ( const std :: string & s )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::overflow_error::overflow_error(const char *)","Filename":"poplar/exceptions.hpp","Text":"explicit overflow_error ( const char * s )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::memory_elem_constraints_error","Filename":"poplar/exceptions.hpp","Text":"struct memory_elem_constraints_error : poplar_error { explicit memory_elem_constraints_error ( const std :: string & s ) ; explicit memory_elem_constraints_error ( const char * s ) ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::memory_elem_constraints_error::memory_elem_constraints_error(const std::string &)","Filename":"poplar/exceptions.hpp","Text":"explicit memory_elem_constraints_error ( const std :: string & s )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::memory_elem_constraints_error::memory_elem_constraints_error(const char *)","Filename":"poplar/exceptions.hpp","Text":"explicit memory_elem_constraints_error ( const char * s )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::graph_memory_allocation_error","Filename":"poplar/exceptions.hpp","Text":"struct graph_memory_allocation_error : poplar_error { ProfileValue graphProfile ; explicit graph_memory_allocation_error ( const std :: string & s ) ; explicit graph_memory_allocation_error ( const char * s ) ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::graph_memory_allocation_error::graph_memory_allocation_error(const std::string &)","Filename":"poplar/exceptions.hpp","Text":"explicit graph_memory_allocation_error ( const std :: string & s )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::graph_memory_allocation_error::graph_memory_allocation_error(const char *)","Filename":"poplar/exceptions.hpp","Text":"explicit graph_memory_allocation_error ( const char * s )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::stream_memory_allocation_error","Filename":"poplar/exceptions.hpp","Text":"struct stream_memory_allocation_error : poplar_error { explicit stream_memory_allocation_error ( const std :: string & s ) ; explicit stream_memory_allocation_error ( const char * s ) ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::stream_memory_allocation_error::stream_memory_allocation_error(const std::string &)","Filename":"poplar/exceptions.hpp","Text":"explicit stream_memory_allocation_error ( const std :: string & s )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::stream_memory_allocation_error::stream_memory_allocation_error(const char *)","Filename":"poplar/exceptions.hpp","Text":"explicit stream_memory_allocation_error ( const char * s )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::invalid_machine_model","Filename":"poplar/exceptions.hpp","Text":"struct invalid_machine_model : poplar_error { explicit invalid_machine_model ( const std :: string & s ) ; explicit invalid_machine_model ( const char * s ) ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::invalid_machine_model::invalid_machine_model(const std::string &)","Filename":"poplar/exceptions.hpp","Text":"explicit invalid_machine_model ( const std :: string & s )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::invalid_machine_model::invalid_machine_model(const char *)","Filename":"poplar/exceptions.hpp","Text":"explicit invalid_machine_model ( const char * s )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::invalid_option","Filename":"poplar/exceptions.hpp","Text":"struct invalid_option : poplar_error { explicit invalid_option ( const std :: string & s ) ; explicit invalid_option ( const char * s ) ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::invalid_option::invalid_option(const std::string &)","Filename":"poplar/exceptions.hpp","Text":"explicit invalid_option ( const std :: string & s )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::invalid_option::invalid_option(const char *)","Filename":"poplar/exceptions.hpp","Text":"explicit invalid_option ( const char * s )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::link_error","Filename":"poplar/exceptions.hpp","Text":"struct link_error : poplar_error { std :: string output ; explicit link_error ( const std :: string & s , const std :: string & out = \"\" ) ; explicit link_error ( const char * s , const char * out = \"\" ) ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::link_error::link_error(const std::string &, const std::string &)","Filename":"poplar/exceptions.hpp","Text":"explicit link_error ( const std :: string & s , const std :: string & out = \"\" )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::link_error::link_error(const char *, const char *)","Filename":"poplar/exceptions.hpp","Text":"explicit link_error ( const char * s , const char * out = \"\" )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::runtime_error","Filename":"poplar/exceptions.hpp","Text":"struct runtime_error : poplar_error { explicit runtime_error ( const std :: string & s ) ; explicit runtime_error ( const char * s ) ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::runtime_error::runtime_error(const std::string &)","Filename":"poplar/exceptions.hpp","Text":"explicit runtime_error ( const std :: string & s )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::runtime_error::runtime_error(const char *)","Filename":"poplar/exceptions.hpp","Text":"explicit runtime_error ( const char * s )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::symbol_error","Filename":"poplar/exceptions.hpp","Text":"struct symbol_error : poplar_error { explicit symbol_error ( const std :: string & name , const unsigned tile ) ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::symbol_error::symbol_error(const std::string &, const unsigned int)","Filename":"poplar/exceptions.hpp","Text":"explicit symbol_error ( const std :: string & name , const unsigned tile )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::file_load_error","Filename":"poplar/exceptions.hpp","Text":"struct file_load_error : poplar_error { explicit file_load_error ( const std :: string & path ) ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::file_load_error::file_load_error(const std::string &)","Filename":"poplar/exceptions.hpp","Text":"explicit file_load_error ( const std :: string & path )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::parse_error","Filename":"poplar/exceptions.hpp","Text":"struct parse_error : poplar_error { explicit parse_error ( const std :: string & s ) ; explicit parse_error ( const char * s ) ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::parse_error::parse_error(const std::string &)","Filename":"poplar/exceptions.hpp","Text":"explicit parse_error ( const std :: string & s )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::parse_error::parse_error(const char *)","Filename":"poplar/exceptions.hpp","Text":"explicit parse_error ( const char * s )"}
{"Token type":"CXXConstructor","FaliureReason":"constructor_missing_class","Implemented":false,"Namespace":"poplar","Name":"poplar::GenericInterval<T>::GenericInterval<T>()","Filename":"poplar/Interval.hpp","Text":"GenericInterval ( ) = default"}
{"Token type":"CXXConstructor","FaliureReason":"constructor_missing_class","Implemented":false,"Namespace":"poplar","Name":"poplar::GenericInterval<T>::GenericInterval<T>(T, T)","Filename":"poplar/Interval.hpp","Text":"GenericInterval ( T begin , T end )"}
{"Token type":"CXXMethod","FaliureReason":"constructor_missing_class","Implemented":false,"Namespace":"poplar","Name":"poplar::GenericInterval<T>::begin()","Filename":"poplar/Interval.hpp","Text":"const T & begin ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"constructor_missing_class","Implemented":false,"Namespace":"poplar","Name":"poplar::GenericInterval<T>::end()","Filename":"poplar/Interval.hpp","Text":"const T & end ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"constructor_missing_class","Implemented":false,"Namespace":"poplar","Name":"poplar::GenericInterval<T>::size()","Filename":"poplar/Interval.hpp","Text":"T size ( ) const"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::operator==(const GenericInterval<T> &, const GenericInterval<T> &)","Filename":"poplar/Interval.hpp","Text":"template < class T > inline bool operator == ( const GenericInterval < T > & a , const GenericInterval < T > & b )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<(const GenericInterval<T> &, const GenericInterval<T> &)","Filename":"poplar/Interval.hpp","Text":"template < class T > inline bool operator < ( const GenericInterval < T > & a , const GenericInterval < T > & b )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::operator!=(const GenericInterval<T> &, const GenericInterval<T> &)","Filename":"poplar/Interval.hpp","Text":"template < class T > inline bool operator != ( const GenericInterval < T > & a , const GenericInterval < T > & b )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::operator>=(const GenericInterval<T> &, const GenericInterval<T> &)","Filename":"poplar/Interval.hpp","Text":"template < class T > inline bool operator >= ( const GenericInterval < T > & a , const GenericInterval < T > & b )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::operator>(const GenericInterval<T> &, const GenericInterval<T> &)","Filename":"poplar/Interval.hpp","Text":"template < class T > inline bool operator > ( const GenericInterval < T > & a , const GenericInterval < T > & b )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<=(const GenericInterval<T> &, const GenericInterval<T> &)","Filename":"poplar/Interval.hpp","Text":"template < class T > inline bool operator <= ( const GenericInterval < T > & a , const GenericInterval < T > & b )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<<(std::ostream &, const GenericInterval<T> &)","Filename":"poplar/Interval.hpp","Text":"template < class T > inline std :: ostream & operator << ( std :: ostream & os , const GenericInterval < T > & b )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::VertexEdgeInfo","Filename":"poplar/LateInitCallback.hpp","Text":"struct VertexEdgeInfo { struct StorageInfo { std :: uint64_t startOffs ; // Start addr in dev memory (offs from 0x40000) std :: uint32_t len ; // Length in bytes } ; // A map from field name => StorageInfo[] for all (edge) fields of the vertex. // For a 1D field, the std::vector, value for the map entry, will have a // single element, describing that field. // For a 2D field, it will have as many entries as there are 'rows' in the // field. // Note that this will not discriminate between a 1D vector and a 2D with a // single row, but this should not matter in any case, because the callback // must be aware of the type of the field. std :: map < std :: string , std :: vector < StorageInfo >> storage ; }"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::VertexEdgeInfo::StorageInfo","Filename":"poplar/LateInitCallback.hpp","Text":"struct StorageInfo { std :: uint64_t startOffs ; // Start addr in dev memory (offs from 0x40000) std :: uint32_t len ; // Length in bytes }"}
{"Token type":"EnumDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::SerializationFormat","Filename":"poplar/SerializationFormat.hpp","Text":"enum class SerializationFormat { Binary , ///< Serialise in binary (CapnProto) format JSON , ///< Serialise in JSON format }"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::SerializationFormat::Binary","Filename":"poplar/SerializationFormat.hpp","Text":"Binary"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::SerializationFormat::JSON","Filename":"poplar/SerializationFormat.hpp","Text":"JSON"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::SourceLocation","Filename":"poplar/DebugContext.hpp","Text":"class SourceLocation { const char * functionName { \"\" } ; const char * fileName { \"\" } ; const unsigned lineNumber { } ; const bool valid { false } ; public : SourceLocation ( ) = default ; constexpr SourceLocation ( const char * functionName , const char * fileName , unsigned lineNumber ) : functionName { functionName } , fileName { fileName } , lineNumber { lineNumber } , valid { true } { } constexpr const char * getFunctionName ( ) const { return functionName ; } constexpr const char * getFileName ( ) const { return fileName ; } constexpr unsigned getLineNumber ( ) const { return lineNumber ; } constexpr bool isValid ( ) const { return valid ; } # if SUPPORTS_LOCATION_BUILTINS static SourceLocation Current ( const char * functionName = __builtin_FUNCTION ( ) , const char * fileName = __builtin_FILE ( ) , unsigned lineNumber = __builtin_LINE ( ) ) { return { functionName , fileName , lineNumber } ; } # else static SourceLocation Current ( ) { return { } ; } # endif }"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::SourceLocation::SourceLocation()","Filename":"poplar/DebugContext.hpp","Text":"SourceLocation ( ) = default"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::SourceLocation::SourceLocation(const char *, const char *, unsigned int)","Filename":"poplar/DebugContext.hpp","Text":"constexpr SourceLocation ( const char * functionName , const char * fileName , unsigned lineNumber ) : functionName { functionName } , fileName { fileName } , lineNumber { lineNumber } , valid { true } { }"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::SourceLocation::getFunctionName()","Filename":"poplar/DebugContext.hpp","Text":"constexpr const char * getFunctionName ( ) const { return functionName ; }"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::SourceLocation::getFileName()","Filename":"poplar/DebugContext.hpp","Text":"constexpr const char * getFileName ( ) const { return fileName ; }"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::SourceLocation::getLineNumber()","Filename":"poplar/DebugContext.hpp","Text":"constexpr unsigned getLineNumber ( ) const { return lineNumber ; }"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::SourceLocation::isValid()","Filename":"poplar/DebugContext.hpp","Text":"constexpr bool isValid ( ) const { return valid ; }"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::SourceLocation::Current()","Filename":"poplar/DebugContext.hpp","Text":"static SourceLocation Current ( )"}
{"Token type":"EnumDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::DebugSerializationFormat","Filename":"poplar/DebugContext.hpp","Text":"enum class DebugSerializationFormat { JSON , ///< Serialise in JSON format CBOR , ///< Serialise in CBOR format }"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::DebugSerializationFormat::JSON","Filename":"poplar/DebugContext.hpp","Text":"JSON"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::DebugSerializationFormat::CBOR","Filename":"poplar/DebugContext.hpp","Text":"CBOR"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar","Name":"poplar::DebugContext","Filename":"poplar/DebugContext.hpp","Text":"class DebugContext"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::DebugInfo","Filename":"poplar/DebugContext.hpp","Text":"class DebugInfo"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::DebugInfo","Filename":"poplar/DebugContext.hpp","Text":"class DebugInfo { std :: unique_ptr < core :: DebugInfo > impl ; public : // The layer string indicates an abstraction level (e.g. Poplar, Poplibs, // Popart) DebugInfo ( const DebugContext & debugContext , std :: string layer ) ; DebugInfo & operator = ( const DebugInfo & ) = delete ; DebugInfo ( const DebugInfo & ) = delete ; virtual ~ DebugInfo ( ) ; // Get the unique identifier for this object std :: uint64_t getId ( ) const ; core :: DebugInfo & getImpl ( ) const { return * impl ; } // Initializes the Streamer with a file name // unless it is already initialized (e.g. through env variables) static void initializeStreamer ( const std :: string & fileName , const DebugSerializationFormat & format = DebugSerializationFormat :: CBOR ) ; protected : // Returns true if \"name\" was not already set, false otherwise bool setValue ( std :: string name , ProfileValue value ) ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::DebugInfo::DebugInfo(const poplar::DebugContext &, std::string)","Filename":"poplar/DebugContext.hpp","Text":"DebugInfo ( const DebugContext & debugContext , std :: string layer )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::DebugInfo::operator=(const poplar::DebugInfo &)","Filename":"poplar/DebugContext.hpp","Text":"DebugInfo & operator = ( const DebugInfo & ) = delete"}
{"Token type":"CXXConstructor","FaliureReason":"deleted_method","Implemented":false,"Namespace":"poplar","Name":"poplar::DebugInfo::DebugInfo(const poplar::DebugInfo &)","Filename":"poplar/DebugContext.hpp","Text":"DebugInfo ( const DebugInfo & ) = delete"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::DebugInfo::getId()","Filename":"poplar/DebugContext.hpp","Text":"std :: uint64_t getId ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::DebugInfo::getImpl()","Filename":"poplar/DebugContext.hpp","Text":"core :: DebugInfo & getImpl ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::DebugInfo::initializeStreamer(const std::string &, const poplar::DebugSerializationFormat &)","Filename":"poplar/DebugContext.hpp","Text":"static void initializeStreamer ( const std :: string & fileName , const DebugSerializationFormat & format = DebugSerializationFormat :: CBOR )"}
{"Token type":"CXXMethod","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::DebugInfo::setValue(std::string, poplar::ProfileValue)","Filename":"poplar/DebugContext.hpp","Text":"bool setValue ( std :: string name , ProfileValue value )"}
{"Token type":"StructDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::DebugContext","Filename":"poplar/DebugContext.hpp","Text":"struct DebugContext"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::DebugContext","Filename":"poplar/DebugContext.hpp","Text":"class DebugContext { std :: unique_ptr < core :: DebugContext > impl ; public : DebugContext ( SourceLocation loc = SourceLocation :: Current ( ) ) ; DebugContext ( const char * name , SourceLocation loc = SourceLocation :: Current ( ) ) ; DebugContext ( StringRef name , SourceLocation loc = SourceLocation :: Current ( ) ) ; DebugContext ( std :: string name , SourceLocation loc = SourceLocation :: Current ( ) ) ; DebugContext ( const DebugInfo & debugInfo , std :: string name = \"\" , SourceLocation loc = SourceLocation :: Current ( ) ) ; DebugContext ( DebugContext && ) ; ~ DebugContext ( ) ; std :: string getPathName ( ) const ; core :: DebugContext & getImpl ( ) const { return * impl ; } }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::DebugContext::DebugContext(poplar::SourceLocation)","Filename":"poplar/DebugContext.hpp","Text":"DebugContext ( SourceLocation loc = SourceLocation :: Current ( ) )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::DebugContext::DebugContext(const char *, poplar::SourceLocation)","Filename":"poplar/DebugContext.hpp","Text":"DebugContext ( const char * name , SourceLocation loc = SourceLocation :: Current ( ) )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::DebugContext::DebugContext(poplar::StringRef, poplar::SourceLocation)","Filename":"poplar/DebugContext.hpp","Text":"DebugContext ( StringRef name , SourceLocation loc = SourceLocation :: Current ( ) )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::DebugContext::DebugContext(const poplar::DebugInfo &, std::string, poplar::SourceLocation)","Filename":"poplar/DebugContext.hpp","Text":"DebugContext ( const DebugInfo & debugInfo , std :: string name = \"\" , SourceLocation loc = SourceLocation :: Current ( ) )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::DebugContext::DebugContext(poplar::DebugContext &&)","Filename":"poplar/DebugContext.hpp","Text":"DebugContext ( DebugContext && )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::DebugContext::getPathName()","Filename":"poplar/DebugContext.hpp","Text":"std :: string getPathName ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::DebugContext::getImpl()","Filename":"poplar/DebugContext.hpp","Text":"core :: DebugContext & getImpl ( ) const"}
{"Token type":"EnumDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::SyncType","Filename":"poplar/SyncType.hpp","Text":"enum class SyncType { INTERNAL , ///< Each tile waits until all the other tiles in the same IPU ///  reach the Sync program before continuing. EXTERNAL ///< Each tile waits until all the other tiles in all IPUs in the ///  device reach the Sync program before continuing. }"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::SyncType::INTERNAL","Filename":"poplar/SyncType.hpp","Text":"INTERNAL"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::SyncType::EXTERNAL","Filename":"poplar/SyncType.hpp","Text":"EXTERNAL"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar","Name":"poplar::IeeeHalf","Filename":"poplar/TypeTraits.hpp","Text":"class IeeeHalf"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::TypeTraits","Filename":"poplar/TypeTraits.hpp","Text":"struct TypeTraits { std :: size_t size ; std :: size_t align ; bool isIntegral ; bool isFloat ; bool isSigned ; template < typename T > static TypeTraits make ( ) ; /// Return true if it is a basic numeric type, i.e. std::is_integral<> /// or std::is_floating_point<> is true, or it is IeeeHalf. template < typename T > static constexpr bool isSimpleType ( ) ; bool isSimpleType ( ) const { return isIntegral || isFloat ; } }"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::TypeTraits::make()","Filename":"poplar/TypeTraits.hpp","Text":"template < typename T > static TypeTraits make ( )"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::TypeTraits::isSimpleType()","Filename":"poplar/TypeTraits.hpp","Text":"template < typename T > static constexpr bool isSimpleType ( )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::TypeTraits::isSimpleType()","Filename":"poplar/TypeTraits.hpp","Text":"bool isSimpleType ( ) const"}
{"Token type":"FunctionTemplate","FaliureReason":"constructor_missing_class","Implemented":false,"Namespace":"poplar","Name":"poplar::make()","Filename":"poplar/TypeTraits.hpp","Text":"template < typename T > TypeTraits TypeTraits :: make ( )"}
{"Token type":"CXXMethod","FaliureReason":"constructor_missing_class","Implemented":false,"Namespace":"poplar","Name":"poplar::make<>()","Filename":"poplar/TypeTraits.hpp","Text":"template < > inline TypeTraits TypeTraits :: make < IeeeHalf > ( )"}
{"Token type":"FunctionTemplate","FaliureReason":"constructor_missing_class","Implemented":false,"Namespace":"poplar","Name":"poplar::isSimpleType()","Filename":"poplar/TypeTraits.hpp","Text":"template < typename T > constexpr bool TypeTraits :: isSimpleType ( ) { return std :: is_integral < T > :: value || std :: is_floating_point < T > :: value ; }"}
{"Token type":"CXXMethod","FaliureReason":"constructor_missing_class","Implemented":false,"Namespace":"poplar","Name":"poplar::isSimpleType<>()","Filename":"poplar/TypeTraits.hpp","Text":"template < > constexpr bool TypeTraits :: isSimpleType < IeeeHalf > ( ) { return true ; }"}
{"Token type":"StructDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar","Name":"poplar::VariableInterval","Filename":"poplar/Tensor.hpp","Text":"struct VariableInterval"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::Tensor","Filename":"poplar/Tensor.hpp","Text":"class Tensor"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Tensor","Filename":"poplar/Tensor.hpp","Text":"class Tensor { public : Tensor ( ) ; Tensor ( const Tensor & other ) ; Tensor ( Tensor && other ) ; const Tensor & operator = ( const Tensor & other ) & ; Tensor & operator = ( Tensor && other ) & ; ~ Tensor ( ) ; /** Get the element type information for this tensor.\n   *   \\returns  The element type.\n   */ Type elementType ( ) const ; /** Get the sub-tensor indexed by i in the first dimension of the\n   *  tensor.\n   *\n   *  \\param i  The index into the first dimension of the tensor.\n   */ Tensor operator [ ] ( std :: size_t i ) const & ; Tensor && operator [ ] ( std :: size_t i ) && ; /** Get the sub-tensor given by a specific range [begin, end)\n   *  in one dimension of the tensor.\n   *\n   *  \\param begin The first element of the range\n   *  \\param end   The upper bound to the range (the last element + 1)\n   *  \\param dimension The dimension to slice in\n   */ Tensor slice ( std :: size_t begin , std :: size_t end , unsigned dimension ) const & ; Tensor && slice ( std :: size_t begin , std :: size_t end , unsigned dimension ) && ; /** Get the sub-tensor given by a specific range [begin, end)\n   *  in the first dimension of the tensor.\n   *\n   *  \\param begin The first element of the range\n   *  \\param end   The upper bound to the range (the last element + 1)\n   */ Tensor slice ( std :: size_t begin , std :: size_t end ) const { return slice ( begin , end , 0 ) ; } /** Get the sub-tensor given by a specific range [begin, end)\n   *  in one dimension of the tensor.\n   *\n   *  \\param region The region to slice\n   *  \\param dimension The dimension to slice in\n   */ Tensor slice ( const Interval & region , unsigned dimension = 0 ) const { return slice ( region . begin ( ) , region . end ( ) , dimension ) ; } /** Get the sub-tensor given by slicing the tensor in multiple dimensions,\n   *  starting at dimension 0. Each pair begin[i], end[i] specifies that the\n   *  tensor is sliced in dimension i by the range [begin[i], end[i]). The rank\n   *  of the returned tensor is the same as the input tensor.\n   *\n   * \\param begin The lower bounds of the ranges used to slice the tensor\n   * \\param end The upper bounds of the ranges used to slice the tensor\n   */ Tensor slice ( ArrayRef < std :: size_t > begin , ArrayRef < std :: size_t > end ) const ; /** Get a vector of slices.\n   *\n   * \\param intervals A list of intervals.\n   * \\param dimension The dimension to slice in\n   * \\returns A vector of slices where each slice is obtained by slicing\n   *          this tensor between the two points in the given interval list.\n   */ std :: vector < Tensor > slices ( ArrayRef < Interval > intervals , unsigned dimension = 0 ) const ; /** Get a vector of slices.\n   *\n   * \\param intervals A list of sequences of intervals.\n   * \\param dimension The dimension to slice in\n   * \\returns A vector of tensors where each tensor is the concatenation of\n   *          the sequence of several slices, each slice being\n   *          this tensor between the two\n   *          point in the corresponding interval in the sequences given as\n   *          input.\n   */ std :: vector < Tensor > slices ( const std :: vector < std :: vector < Interval >> & intervals , unsigned dimension = 0 ) const ; /**\n   * Get the sub-tensor indexed by the specified indices. This is equivalent\n   * to repeatedly applying operator[] for each index in the vector of indices.\n   *\n   * \\param indices The indices used to index into the tensor.\n   * \\returns The sub-tensor indexed by the indices.\n   */ Tensor index ( ArrayRef < std :: size_t > indices ) const ; /** Flatten the tensor.\n   *\n   *  \\returns A tensor consisting of all elements of the original tensor but\n   *           with a single dimension.\n   */ Tensor flatten ( ) const ; /**\n   * Flatten the a subset of the dimensions of a tensor.\n   *\n   * \\param dimBegin The first dimension to flatten\n   * \\param dimEnd One past the last dimension to flatten.\n   * \\returns A tensor consisting of all elements of the original tensor with\n   *          the specified dimension range flattened into one dimension.\n   */ Tensor flatten ( unsigned dimBegin , unsigned dimEnd ) const ; /** Reshape the tensor.\n   *\n   *  The reshaping operation changes the shape of the tensor but cannot\n   *  change the total number of elements.\n   *\n   *  \\param shape  The new shape of the tensor.\n   *  \\returns A tensor consisting of all elements of the original\n   *           but with new dimensions.\n   */ Tensor reshape ( ArrayRef < std :: size_t > shape ) const ; /** Permute the dimensions of a tensor.\n   *\n   * The dimShuffle operation reorders the tensor to a permutation of its\n   * dimensions. It can be seen as the generalized form of a matrix transpose.\n   *\n   * Note that this operation does not create a copy of the tensor but returns\n   * a reordered view on this tensor's data.\n   *\n   *   \\param permutation The permutation vector specifies a mapping from\n   *                      the output dimension to the input dimension. For\n   *                      example the permutation of {2, 0, 1} specifies that\n   *                      element element [a][b][c] in the original tensor is\n   *                      remapped to element [c][a][b] in the new tensor.\n   *   \\returns The shuffled tensor\n   */ Tensor dimShuffle ( ArrayRef < unsigned > permutation ) const ; /** Permute some of a tensor's dimensions\n   *\n   * dimShufflePartial reorders the tensors dimensions. The unspecified\n   * dimensions stay in the same relative order.\n   *\n   * Note that this operation does not create a copy of the tensor but returns\n   * a reordered view on this tensor's data.\n   *\n   *  \\param source       The dimensions to move.\n   *  \\param destination  The index at which to move each source dimension.\n   *\n   *  \\returns            The shuffled tensor.\n   */ Tensor dimShufflePartial ( ArrayRef < unsigned > source , ArrayRef < unsigned > destination ) const ; /** Roll a specified dimension to the specified dimension\n   *\n   * The other dimensions remain in the same relative order\n   *\n   * Note that this operation does not create a copy of the tensor but returns\n   * a reordered view on this tensor's data.\n   *\n   *  \\param dimIdx     The dimension to move.\n   *  \\param newIdx     Its new location, default 0.\n   *  \\returns          The shuffled .\n   */ Tensor dimRoll ( unsigned dimIdx , unsigned newIdx = 0 ) const { return dimShufflePartial ( { dimIdx } , { newIdx } ) ; } /** Reshape a range of dimensions of a tensor\n   *\n   *  reshapePartial reshapes the input tensor such that the total number of\n   *  elements of the resultant tensor is the same as the input tensor.\n   *\n   *  Note that this operation does not create a copy of the tensor but returns\n   *  a reshaped view on the input tensor's data.\n   *\n   *  The following conditions define the valid use of this function:\n   *\n   *  1) beginIndex == endIndex\n   *\n   *     beginIndex and endIndex must each lie in the closed interval  [0,\n   *     rank()]. Singleton dimensions are added before beginIndex.\n   *     The number of dimensions added is equal to the length of the newDims\n   *     vector. For example:\n   *\n   *         reshapePartial(0, {1, 1})\n   *     Adds two singleton dimensions at indicies 0 and 1\n   *\n   * 2) size(newDims) == 0 and beginIndex != endIndex\n   *\n   *    beginIndex must lie in the half closed interval [0, rank())\n   *    endIndex must lie in the half closed interval (0, rank()] The product of\n   *    vector newDims must be 1. For example:\n   *\n   *        reshapePartial(1, 3, {})\n   *    Removes singleton dimensions 1 and 2 from the tensor\n   *\n   * 3) size(newDims) != 0 and beginIndex != endIndex\n   *\n   *    beginIndex must lie in the half closed interval [0, rank())\n   *    endIndex must lie in the half close interval (0, rank()]\n   *    The product of vector newDims must be equal to the product of the number\n   *    of elements in the interval [beginIndex, endIndex)\n   *\n   *    The input dimensions [0, beginIndex) and [endIndex, rank()) are\n   *    prepended and appended at the end of the tensor respectively. For\n   *    example:\n   *\n   *        reshapePartial(1, 3, {10, 20, 30})\n   *        reshapePartial(1, 3, {10})\n   *\n   *  \\param beginIndex   Index of the dimension from which reshape starts\n   *\n   *  \\param endIndex     Index of the first dimension after reshape ends\n   *\n   *  \\param newDims      The new dimensions of the partial tensor\n   *\n   *  \\return Reshaped view of tensor\n   */ Tensor reshapePartial ( unsigned beginIndex , unsigned endIndex , ArrayRef < std :: size_t > newDims ) const ; /** Expand tensor by adding singleton dimensions at specified indices of\n   *  tensor. The rank is expanded by the size of dimensions to be added. To add\n   *  more than one dimension at a given position, the same index shall be\n   *  repeated.\n   *\n   *  \\param indices    Dimension indices before which the singleton dimensions\n   *                    are added\n   *\n   *  \\return           A view of expanded tensor\n   */ Tensor expand ( ArrayRef < std :: size_t > indices ) const ; /** Reduce dimension of tensor by removing singleton dimensions at specified\n   *  indices of tensor.\n   *\n   *  \\param indices    Indices of singleton dimensions which are removed\n   *\n   *  \\return           A view of squeezed tensor\n   */ Tensor squeeze ( ArrayRef < std :: size_t > indices ) const ; /** Transpose a 2-dimensional tensor.\n   *\n   *  \\returns The transposed tensor.\n   */ Tensor transpose ( ) const { return dimShuffle ( { 1 , 0 } ) ; } /** Sub-sample the tensor.\n   *\n   *  Sub-sample this tensor by selecting every stride-th element of the\n   *  tensor in a specified dimension\n   *\n   *  \\param stride The size of the stride\n   *  \\param dimension The dimension to sub-sample in\n   *  \\returns The sub-sampled tensor\n   */ Tensor subSample ( unsigned stride , unsigned dimension ) const ; /** Broadcast/repeat the tensor along a specified dimension.\n   *\n   *  Create a view with this tensor repeated N times along a specified\n   *  dimension.\n   *\n   *  \\param N         The number of times to repeat.\n   *  \\param dimension The dimension to broadcast in.\n   *  \\returns         The broadcast tensor.\n   */ Tensor broadcast ( unsigned N , unsigned dimension ) const ; /** Reinterpret the tensor as a new type.\n   *\n   * The new type must be the same size as the old type. See elementType()\n   * for a list of valid types and their sizes.\n   *\n   *  \\param type   The type to reinterpret to\n   *  \\returns A tensor with the same shape and referencing the same data\n   *           but of the new type.\n   */ Tensor reinterpret ( const Type & type ) const ; /** reverse this tensor along a specified dimension.\n   *\n   * \\param dimension  The dimension to reverse.\n   * \\returns          The reversed tensor.\n   */ Tensor reverse ( unsigned dimensions ) const ; /** Get the total number of elements in the tensor. */ std :: size_t numElements ( ) const ; /** Get a dimension of the tensor.\n   *\n   *  \\param i   The index of the dimension to get.\n   */ std :: size_t dim ( unsigned i ) const ; /** Get the shape of the tensor.\n   *\n   *  \\returns A vector of all the dimensions of the tensor.\n   */ std :: vector < std :: size_t > shape ( ) const ; /** Get the rank of the tensor.\n   *\n   *  \\returns The number of dimensions a tensor has.\n   */ unsigned rank ( ) const ; /** Get whether the tensor is contiguous. */ bool isContiguous ( ) const ; /** Get whether the tensor contains an alias to the same storage\n   *  location.\n   *\n   *  \\returns True if the tensor contains an alias to the same storage\n   *           location.\n   */ bool containsAliases ( ) const ; /** Get whether the tensor contains any constant tensors.\n   *\n   *  \\returns True if the tensor contains any constant tensors.\n   */ bool containsConstant ( ) const ; /** Get whether the elements of this tensor can be written in parallel.\n   *\n   *  This is equivalent to !(containsAliases() || containsConstant()).\n   *\n   *  \\returns True if the tensor can be written in parallel.\n   */ bool isParallelWriteable ( ) const ; /** Get the contiguous regions of a tensor\n   *\n   *  \\returns A vector of intervals in order representing regions of\n   *           the tensor that are contiguous in the tensors storage\n   *           ordering.\n   */ const std :: vector < Interval > getContiguousRegions ( ) const ; /** Get the contiguous regions of a tensor with reference to the\n   *  variables allocated in the graph.\n   *\n   *  \\returns A vector of variable intervals (variable id, interval\n   *           pairs) representing the regions of the tensor.\n   */ const std :: vector < VariableInterval > getVarRegions ( ) const ; /** Read a single element of data from a tensor if it is a constant\n   *\n   * \\param val         Buffer to which tensor data is copied to\n   *\n   * \\return True if tensor is constant and data is read\n   */ template < typename T > bool getConstantValue ( T * val ) const { return getConstantData ( val , TypeTraits :: make < T > ( ) ) ; } /** Return whether this tensor intersects with another tensor.\n   *  \\param other The tensor to compare with.\n   *  \\returns True if this tensor intersects with the other tensor.\n   */ bool intersectsWith ( const Tensor & other ) const ; /** Display the expression representing the tensor on a stream\n   *  \\param os The ostream to output to\n   *  \\returns The ostream written to\n   */ std :: ostream & output ( std :: ostream & os ) const ; /** Display the regions of the tensor on a stream\n   *  \\param os The ostream to output to\n   *  \\returns The ostream written to\n   */ std :: ostream & outputRegions ( std :: ostream & os ) const ; /** Display the expression representing the tensor */ void dump ( ) const ; /** Display the regions of the tensor */ void dumpRegions ( ) const ; // Implementation Tensor ( std :: unique_ptr < core :: Tensor > ) ; core :: Tensor & getImpl ( ) const { return * impl ; } std :: unique_ptr < core :: Tensor > * getPImpl ( ) { return & impl ; } bool valid ( ) const { return impl . get ( ) != nullptr ; } private : std :: unique_ptr < core :: Tensor > impl ; bool getConstantData ( void * dst , const TypeTraits & traits ) const ; }"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::Tensor()","Filename":"poplar/Tensor.hpp","Text":"Tensor ( )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Tensor::Tensor(const poplar::Tensor &)","Filename":"poplar/Tensor.hpp","Text":"Tensor ( const Tensor & other )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::Tensor(poplar::Tensor &&)","Filename":"poplar/Tensor.hpp","Text":"Tensor ( Tensor && other )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::operator=(const poplar::Tensor &)","Filename":"poplar/Tensor.hpp","Text":"const Tensor & operator = ( const Tensor & other ) &"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::operator=(poplar::Tensor &&)","Filename":"poplar/Tensor.hpp","Text":"Tensor & operator = ( Tensor && other ) &"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Tensor::elementType()","Filename":"poplar/Tensor.hpp","Text":"Type elementType ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::operator[](std::size_t)","Filename":"poplar/Tensor.hpp","Text":"Tensor operator [ ] ( std :: size_t i ) const &"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::operator[](std::size_t)","Filename":"poplar/Tensor.hpp","Text":"Tensor && operator [ ] ( std :: size_t i ) &&"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Tensor::slice(std::size_t, std::size_t, unsigned int)","Filename":"poplar/Tensor.hpp","Text":"Tensor slice ( std :: size_t begin , std :: size_t end , unsigned dimension ) const &"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Tensor::slice(std::size_t, std::size_t)","Filename":"poplar/Tensor.hpp","Text":"Tensor slice ( std :: size_t begin , std :: size_t end ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Tensor::slice(const poplar::Interval &, unsigned int)","Filename":"poplar/Tensor.hpp","Text":"Tensor slice ( const Interval & region , unsigned dimension = 0 ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Tensor::slice(ArrayRef<std::size_t>, ArrayRef<std::size_t>)","Filename":"poplar/Tensor.hpp","Text":"Tensor slice ( ArrayRef < std :: size_t > begin , ArrayRef < std :: size_t > end ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Tensor::slices(ArrayRef<poplar::Interval>, unsigned int)","Filename":"poplar/Tensor.hpp","Text":"std :: vector < Tensor > slices ( ArrayRef < Interval > intervals , unsigned dimension = 0 ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Tensor::slices(const std::vector<std::vector<Interval> > &, unsigned int)","Filename":"poplar/Tensor.hpp","Text":"std :: vector < Tensor > slices ( const std :: vector < std :: vector < Interval >> & intervals , unsigned dimension = 0 ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Tensor::index(ArrayRef<std::size_t>)","Filename":"poplar/Tensor.hpp","Text":"Tensor index ( ArrayRef < std :: size_t > indices ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Tensor::flatten()","Filename":"poplar/Tensor.hpp","Text":"Tensor flatten ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Tensor::flatten(unsigned int, unsigned int)","Filename":"poplar/Tensor.hpp","Text":"Tensor flatten ( unsigned dimBegin , unsigned dimEnd ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Tensor::reshape(ArrayRef<std::size_t>)","Filename":"poplar/Tensor.hpp","Text":"Tensor reshape ( ArrayRef < std :: size_t > shape ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Tensor::dimShuffle(ArrayRef<unsigned int>)","Filename":"poplar/Tensor.hpp","Text":"Tensor dimShuffle ( ArrayRef < unsigned > permutation ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Tensor::dimShufflePartial(ArrayRef<unsigned int>, ArrayRef<unsigned int>)","Filename":"poplar/Tensor.hpp","Text":"Tensor dimShufflePartial ( ArrayRef < unsigned > source , ArrayRef < unsigned > destination ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Tensor::dimRoll(unsigned int, unsigned int)","Filename":"poplar/Tensor.hpp","Text":"Tensor dimRoll ( unsigned dimIdx , unsigned newIdx = 0 ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Tensor::reshapePartial(unsigned int, unsigned int, ArrayRef<std::size_t>)","Filename":"poplar/Tensor.hpp","Text":"Tensor reshapePartial ( unsigned beginIndex , unsigned endIndex , ArrayRef < std :: size_t > newDims ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Tensor::expand(ArrayRef<std::size_t>)","Filename":"poplar/Tensor.hpp","Text":"Tensor expand ( ArrayRef < std :: size_t > indices ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Tensor::squeeze(ArrayRef<std::size_t>)","Filename":"poplar/Tensor.hpp","Text":"Tensor squeeze ( ArrayRef < std :: size_t > indices ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Tensor::transpose()","Filename":"poplar/Tensor.hpp","Text":"Tensor transpose ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Tensor::subSample(unsigned int, unsigned int)","Filename":"poplar/Tensor.hpp","Text":"Tensor subSample ( unsigned stride , unsigned dimension ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Tensor::broadcast(unsigned int, unsigned int)","Filename":"poplar/Tensor.hpp","Text":"Tensor broadcast ( unsigned N , unsigned dimension ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Tensor::reinterpret(const poplar::Type &)","Filename":"poplar/Tensor.hpp","Text":"Tensor reinterpret ( const Type & type ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Tensor::reverse(unsigned int)","Filename":"poplar/Tensor.hpp","Text":"Tensor reverse ( unsigned dimensions ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Tensor::numElements()","Filename":"poplar/Tensor.hpp","Text":"std :: size_t numElements ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Tensor::dim(unsigned int)","Filename":"poplar/Tensor.hpp","Text":"std :: size_t dim ( unsigned i ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Tensor::shape()","Filename":"poplar/Tensor.hpp","Text":"std :: vector < std :: size_t > shape ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Tensor::rank()","Filename":"poplar/Tensor.hpp","Text":"unsigned rank ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Tensor::isContiguous()","Filename":"poplar/Tensor.hpp","Text":"bool isContiguous ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Tensor::containsAliases()","Filename":"poplar/Tensor.hpp","Text":"bool containsAliases ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Tensor::containsConstant()","Filename":"poplar/Tensor.hpp","Text":"bool containsConstant ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Tensor::isParallelWriteable()","Filename":"poplar/Tensor.hpp","Text":"bool isParallelWriteable ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Tensor::getContiguousRegions()","Filename":"poplar/Tensor.hpp","Text":"const std :: vector < Interval > getContiguousRegions ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Tensor::getVarRegions()","Filename":"poplar/Tensor.hpp","Text":"const std :: vector < VariableInterval > getVarRegions ( ) const"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::getConstantValue(T *)","Filename":"poplar/Tensor.hpp","Text":"template < typename T > bool getConstantValue ( T * val ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Tensor::intersectsWith(const poplar::Tensor &)","Filename":"poplar/Tensor.hpp","Text":"bool intersectsWith ( const Tensor & other ) const"}
{"Token type":"CXXMethod","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::output(std::ostream &)","Filename":"poplar/Tensor.hpp","Text":"std :: ostream & output ( std :: ostream & os ) const"}
{"Token type":"CXXMethod","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::outputRegions(std::ostream &)","Filename":"poplar/Tensor.hpp","Text":"std :: ostream & outputRegions ( std :: ostream & os ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Tensor::dump()","Filename":"poplar/Tensor.hpp","Text":"void dump ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Tensor::dumpRegions()","Filename":"poplar/Tensor.hpp","Text":"void dumpRegions ( ) const"}
{"Token type":"CXXConstructor","FaliureReason":"unique_ptr_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::Tensor(std::unique_ptr<core::Tensor>)","Filename":"poplar/Tensor.hpp","Text":"Tensor ( std :: unique_ptr < core :: Tensor > )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::getImpl()","Filename":"poplar/Tensor.hpp","Text":"core :: Tensor & getImpl ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::getPImpl()","Filename":"poplar/Tensor.hpp","Text":"std :: unique_ptr < core :: Tensor > * getPImpl ( )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Tensor::valid()","Filename":"poplar/Tensor.hpp","Text":"bool valid ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::getConstantData(void *, const poplar::TypeTraits &)","Filename":"poplar/Tensor.hpp","Text":"bool getConstantData ( void * dst , const TypeTraits & traits ) const"}
{"Token type":"FunctionDecl","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::operator==(const poplar::Tensor &, const poplar::Tensor &)","Filename":"poplar/Tensor.hpp","Text":"bool operator == ( const Tensor & a , const Tensor & b )"}
{"Token type":"FunctionDecl","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::operator!=(const poplar::Tensor &, const poplar::Tensor &)","Filename":"poplar/Tensor.hpp","Text":"bool inline operator != ( const Tensor & a , const Tensor & b )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::concat(ArrayRef<poplar::Tensor>, unsigned int)","Filename":"poplar/Tensor.hpp","Text":"Tensor concat ( ArrayRef < Tensor > ts , unsigned dimension = 0 )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::concat(const poplar::Tensor &, const poplar::Tensor &, unsigned int)","Filename":"poplar/Tensor.hpp","Text":"inline Tensor concat ( const Tensor & first , const Tensor & second , unsigned dimension = 0 )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::append(const poplar::Tensor &, const poplar::Tensor &, unsigned int)","Filename":"poplar/Tensor.hpp","Text":"Tensor append ( const Tensor & first , const Tensor & second , unsigned dimension )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::append(const poplar::Tensor &, const poplar::Tensor &)","Filename":"poplar/Tensor.hpp","Text":"inline Tensor append ( const Tensor & first , const Tensor & second )"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<<(std::ostream &, const poplar::Tensor &)","Filename":"poplar/Tensor.hpp","Text":"std :: ostream & operator << ( std :: ostream & os , const Tensor & tensor )"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::ProgramImpl","Filename":"poplar/Program.hpp","Text":"class ProgramImpl"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar::program","Name":"poplar::program::Program","Filename":"poplar/Program.hpp","Text":"class Program { public : Program ( ) ; Program ( const Program & p ) ; Program ( Program && p ) ; Program & operator = ( const Program & p ) ; Program & operator = ( Program && p ) ; virtual ~ Program ( ) ; // Check if program is empty bool isEmpty ( ) const { return impl . get ( ) == nullptr ; } // Implementation core :: ProgramImpl & getImpl ( ) const { return * impl ; } protected : std :: unique_ptr < core :: ProgramImpl > impl ; }"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Program::Program()","Filename":"poplar/Program.hpp","Text":"Program ( )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar::program","Name":"poplar::program::Program::Program(const poplar::program::Program &)","Filename":"poplar/Program.hpp","Text":"Program ( const Program & p )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Program::Program(poplar::program::Program &&)","Filename":"poplar/Program.hpp","Text":"Program ( Program && p )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Program::operator=(const poplar::program::Program &)","Filename":"poplar/Program.hpp","Text":"Program & operator = ( const Program & p )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Program::operator=(poplar::program::Program &&)","Filename":"poplar/Program.hpp","Text":"Program & operator = ( Program && p )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar::program","Name":"poplar::program::Program::isEmpty()","Filename":"poplar/Program.hpp","Text":"bool isEmpty ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Program::getImpl()","Filename":"poplar/Program.hpp","Text":"core :: ProgramImpl & getImpl ( ) const"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar::program","Name":"poplar::program::Execute","Filename":"poplar/Program.hpp","Text":"class Execute : public Program { public : /** Construct a graph execution program.\n   *  \\param cs  The compute set to execute.\n   */ explicit Execute ( ComputeSet cs ) ; /** Construct a graph execution program and write the exit status to\n   *  a scalar tensor. The exit status is the logical and of the return\n   *  values of the vertices in the compute set.\n   \\param cs  The compute set to execute.\n   \\param t   The tensor to write the exit status to.\n  */ Execute ( ComputeSet cs , Tensor t ) ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar::program","Name":"poplar::program::Execute::Execute(poplar::ComputeSet)","Filename":"poplar/Program.hpp","Text":"explicit Execute ( ComputeSet cs )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar::program","Name":"poplar::program::Execute::Execute(poplar::ComputeSet, poplar::Tensor)","Filename":"poplar/Program.hpp","Text":"Execute ( ComputeSet cs , Tensor t )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar::program","Name":"poplar::program::Sequence","Filename":"poplar/Program.hpp","Text":"class Sequence : public Program { template < class ... T > void add_many ( const Program & first , T && ... rest ) { add ( first ) ; add_many ( rest ... ) ; } void add_many ( ) { } void init ( ) ; public : /** Construct a sequence program. */ Sequence ( ) ; /** Construct an execution sequence from a list of programs.\n   *\n   *  This variadic constructor is used to create a sequence of programs where\n   *  the programs are provided as arguments to the constructor. For example:\n   *\n   *  \\code\n   *    Sequence(prog1, prog2, prog3)\n   *  \\endcode\n   */ template < class ... T > Sequence ( T && ... args ) { init ( ) ; add_many ( args ... ) ; } /** Add a program to the end of the sequence.\n   *  \\param p  The program to add.\n   */ void add ( const Program & p ) ; }"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Sequence::add_many(const poplar::program::Program &, T &&...)","Filename":"poplar/Program.hpp","Text":"template < class ... T > void add_many ( const Program & first , T && ... rest )"}
{"Token type":"CXXMethod","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Sequence::add_many()","Filename":"poplar/Program.hpp","Text":"void add_many ( )"}
{"Token type":"CXXMethod","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Sequence::init()","Filename":"poplar/Program.hpp","Text":"void init ( )"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Sequence::Sequence()","Filename":"poplar/Program.hpp","Text":"Sequence ( )"}
{"Token type":"FunctionTemplate","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Sequence::Sequence(T &&...)","Filename":"poplar/Program.hpp","Text":"template < class ... T > Sequence ( T && ... args )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar::program","Name":"poplar::program::Sequence::add(const poplar::program::Program &)","Filename":"poplar/Program.hpp","Text":"void add ( const Program & p )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar::program","Name":"poplar::program::Repeat","Filename":"poplar/Program.hpp","Text":"class Repeat : public Program { public : /** Construct a repeat program.\n   *  \\param count  The number of iterations to repeat for.\n   *  \\param prog   The program to repeatedly execute.\n   */ Repeat ( unsigned count , const Program & prog ) ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar::program","Name":"poplar::program::Repeat::Repeat(unsigned int, const poplar::program::Program &)","Filename":"poplar/Program.hpp","Text":"Repeat ( unsigned count , const Program & prog )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar::program","Name":"poplar::program::RepeatWhileFalse","Filename":"poplar/Program.hpp","Text":"class RepeatWhileFalse : public Program { public : /** Construct a repeat while false program.\n   *  \\param cond The program evaluated before the body is evaluated.\n   *  \\param predicate The scalar tensor that determines whether to execute\n   *                   the body.\n   *  \\param body The body to execute when the predicate is false.\n   */ RepeatWhileFalse ( const Program & cond , Tensor predicate , const Program & body ) ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar::program","Name":"poplar::program::RepeatWhileFalse::RepeatWhileFalse(const poplar::program::Program &, poplar::Tensor, const poplar::program::Program &)","Filename":"poplar/Program.hpp","Text":"RepeatWhileFalse ( const Program & cond , Tensor predicate , const Program & body )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar::program","Name":"poplar::program::RepeatWhileTrue","Filename":"poplar/Program.hpp","Text":"class RepeatWhileTrue : public Program { public : /** Construct a repeat while true program.\n   *  \\param cond The program evaluated before the body is evaluated.\n   *  \\param predicate The scalar tensor that determines whether to execute\n   *                   the body.\n   *  \\param body The body to execute when the predicate is true.\n   */ RepeatWhileTrue ( const Program & cond , Tensor predicate , const Program & body ) ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar::program","Name":"poplar::program::RepeatWhileTrue::RepeatWhileTrue(const poplar::program::Program &, poplar::Tensor, const poplar::program::Program &)","Filename":"poplar/Program.hpp","Text":"RepeatWhileTrue ( const Program & cond , Tensor predicate , const Program & body )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar::program","Name":"poplar::program::If","Filename":"poplar/Program.hpp","Text":"class If : public Program { public : /** A program that executes the trueBody or falseBody depending on the value\n   * of the predicate. You can pass an empty Sequence to either trueBody or\n   * falseBody if you don't want either branch to do anything.\n   *\n   *  \\param predicate The scalar tensor that determines which branch to\n   *                   execute.\n   *  \\param trueBody  This program is run if the predicate is true.\n   *  \\param falseBody This program is run if the predicate is false.\n   */ If ( Tensor predicate , const Program & trueBody , const Program & falseBody ) ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar::program","Name":"poplar::program::If::If(poplar::Tensor, const poplar::program::Program &, const poplar::program::Program &)","Filename":"poplar/Program.hpp","Text":"If ( Tensor predicate , const Program & trueBody , const Program & falseBody )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar::program","Name":"poplar::program::Switch","Filename":"poplar/Program.hpp","Text":"class Switch : public Program { Switch ( Tensor control , const Program & defaultCaseBody , const bool unreachableDefault ) ; public : /// Construct a switch with the specified set of cases and an empty /// default case. /// \\param control The controlling tensor. /// \\param cases The cases of the switch. Switch ( Tensor control , const std :: vector < std :: pair < std :: int32_t , Program >> & cases ) ; /// Construct a switch with the specified set of cases and default case. /// \\param control The controlling tensor. /// \\param cases The cases of the switch. /// \\param defaultCaseBody The body of the default case. Switch ( Tensor control , const std :: vector < std :: pair < std :: int32_t , Program >> & cases , const Program & defaultCaseBody ) ; /// Construct a switch with no cases and an empty default case. The add() /// method can be used to add cases after the switch is constructed. /// \\param control The controlling tensor. Switch ( Tensor control ) ; /// Construct a switch with no cases and the specified default case. The add() /// method can be used to add cases after the switch is constructed. /// \\param control The controlling tensor. /// \\param defaultCaseBody The body of the default case. Switch ( Tensor control , const Program & defaultCaseBody ) ; /// Add a case with the specified case value and body. /// \\param value The case value. /// \\param body The case body. /// \\return A reference to the switch program. Switch & add ( std :: int32_t value , const Program & body ) ; /// A helper function that causes the default case to throw an error. static Switch switchWithBoundsChecking ( Tensor control , const std :: vector < std :: pair < std :: int32_t , Program >> & cases ) ; /// This function lets the compiler assume the default case is unreachable. /// %If the control value is something other than one of the cases, it results /// in undefined behaviour (although there is some very minimal error checking /// at runtime). static Switch switchWithUnreachableDefault ( Tensor control ) ; }"}
{"Token type":"CXXConstructor","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Switch::Switch(poplar::Tensor, const poplar::program::Program &, const bool)","Filename":"poplar/Program.hpp","Text":"Switch ( Tensor control , const Program & defaultCaseBody , const bool unreachableDefault )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar::program","Name":"poplar::program::Switch::Switch(poplar::Tensor, const std::vector<std::pair<std::int32_t, Program> > &)","Filename":"poplar/Program.hpp","Text":"Switch ( Tensor control , const std :: vector < std :: pair < std :: int32_t , Program >> & cases )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar::program","Name":"poplar::program::Switch::Switch(poplar::Tensor, const std::vector<std::pair<std::int32_t, Program> > &, const poplar::program::Program &)","Filename":"poplar/Program.hpp","Text":"Switch ( Tensor control , const std :: vector < std :: pair < std :: int32_t , Program >> & cases , const Program & defaultCaseBody )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar::program","Name":"poplar::program::Switch::Switch(poplar::Tensor)","Filename":"poplar/Program.hpp","Text":"Switch ( Tensor control )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar::program","Name":"poplar::program::Switch::Switch(poplar::Tensor, const poplar::program::Program &)","Filename":"poplar/Program.hpp","Text":"Switch ( Tensor control , const Program & defaultCaseBody )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar::program","Name":"poplar::program::Switch::add(std::int32_t, const poplar::program::Program &)","Filename":"poplar/Program.hpp","Text":"Switch & add ( std :: int32_t value , const Program & body )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar::program","Name":"poplar::program::Switch::switchWithBoundsChecking(poplar::Tensor, const std::vector<std::pair<std::int32_t, Program> > &)","Filename":"poplar/Program.hpp","Text":"static Switch switchWithBoundsChecking ( Tensor control , const std :: vector < std :: pair < std :: int32_t , Program >> & cases )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar::program","Name":"poplar::program::Switch::switchWithUnreachableDefault(poplar::Tensor)","Filename":"poplar/Program.hpp","Text":"static Switch switchWithUnreachableDefault ( Tensor control )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar::program","Name":"poplar::program::Copy","Filename":"poplar/Program.hpp","Text":"class Copy : public Program { Copy ( const DataStream & stream , Tensor dst , bool rearrangeOnHost , Tensor offset , size_t repeats , bool optimiseMemory , const OptionFlags & options = { } ) ; Copy ( Tensor src , const DataStream & stream , bool rearrangeOnHost , Tensor offset , size_t repeats , bool optimiseMemory , const OptionFlags & options = { } ) ; public : /** Construct a program to copy data from one tensor to another.\n   *\n   *  This constructor creates a program that will copy data from the \\p src\n   *  tensor to the \\p dst tensor.\n   *\n   *  \\param src The tensor to copy from.\n   *  \\param dst The tensor to copy to.\n   *  \\param dontOutline Do not outline this copy as a function call.\n   *                     Default is false (the copy will be outlined).\n   */ Copy ( Tensor src , Tensor dst , bool dontOutline = false ) ; /** Construct a program to copy from a data stream to a tensor.\n   *\n   *  \\param stream The stream to copy from.\n   *  \\param dst    The tensor to copy to.\n   *  \\param optimiseMemory  if set to true will sacrifice speed in\n   *                         order to reduce memory use. For example,\n   *                         rearranging data on host and outlining writes.\n   */ Copy ( const DataStream & stream , Tensor dst , bool optimiseMemory = false ) ; /** Construct a program to copy a Tensor to a data stream.\n   *\n   *  \\param src       The tensor to copy from.\n   *  \\param stream    The stream to copy to.\n   *  \\param optimiseMemory  Set to true to sacrifice speed in order to\n   *                         reduce memory usage.\n   */ Copy ( Tensor src , const DataStream & stream , bool optimiseMemory = false ) ; /** Construct a program to copy a remote buffer to a tensor.\n   *\n   *  \\param buffer The remote buffer to copy from.\n   *  \\param dst    The tensor to copy to.\n   */ Copy ( const RemoteBuffer & buffer , Tensor dst ) ; /** Construct a program to copy a remote buffer to a tensor.\n   *\n   * The data to be transferred is controlled by the definition of the buffer\n   * and the \\p offset parameter.\n   *\n   * The buffer has \\c repeat data-transfer \"rows\" each containing\n   * \\c numElements data items (these are not necessarily the same as rows in\n   * the destination tensor.)\n   * The size of \\p offset defines the number of rows to copy.\n   * The rows to be copied are defined by \\p offset: each element of\n   * \\p offset is the index of a row to be copied.\n   *\n   * The size of \\p dst must be equal to the data transfer size:\n   * \\c sizeof(offset) * \\c numElements.\n   *\n   * \\sa Graph::addRemoteBuffer\n   *\n   *  \\param buffer The remote buffer to copy from.\n   *  \\param dst    The tensor to copy to.\n   *  \\param offset The \"rows\"\" in the remote buffer to copy from.\n   */ Copy ( const RemoteBuffer & buffer , Tensor dst , Tensor offset ) ; /** Construct a program to copy a tensor to a remote buffer.\n   *\n   *  \\param src    The tensor to copy from.\n   *  \\param buffer The remote buffer buffer to copy to.\n   */ Copy ( Tensor src , const RemoteBuffer & buffer ) ; /** Construct a program to copy a tensor to a remote buffer.\n   *\n   * The data that is transferred is controlled by the definition of the buffer\n   * and the \\p offset parameter.\n   *\n   * The buffer has \\c repeat data transfer \"rows\" each containing\n   * \\c numElements data items. (These are not necessarily the same as rows in\n   * the source tensor) The rows to be copied are defined by \\p offset.\n   * The size of \\p offset defines the number of rows to copy. Each element of\n   * \\p offset is the index of a row to be copied.\n   *\n   * The size of \\p src must be equal to the data transfer size:\n   * \\c sizeof(offset) * \\c numElements.\n   *\n   * \\sa Graph::addRemoteBuffer\n   *\n   *  \\param src    The tensor to copy from.\n   *  \\param buffer The remote buffer buffer to copy to.\n   *  \\param offset The \"rows\" in the remote buffer to copy to.\n   */ Copy ( Tensor src , const RemoteBuffer & buffer , Tensor offset ) ; /** Construct a program to copy from a data stream to a tensor.\n   *\n   *  \\param stream The data stream to copy from.\n   *  \\param dst    The tensor to copy to.\n   *  \\param expectedIndex\n   *  \\param rearrangeOnHost\n   *  \\param options\n   */ Copy ( const DataStream & stream , Tensor dst , Tensor expectedIndex , bool rearrangeOnHost = false , const OptionFlags & options = { } ) ; /** Construct a program to copy a tensor to a data stream.\n   *\n   *  \\param src    The tensor to copy from.\n   *  \\param stream The data stream to copy to.\n   *  \\param index\n   *  \\param rearrangeOnHost\n   *  \\param options\n   */ Copy ( Tensor src , const DataStream & stream , Tensor index , bool rearrangeOnHost = false , const OptionFlags & options = { } ) ; }"}
{"Token type":"CXXConstructor","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Copy::Copy(const poplar::DataStream &, poplar::Tensor, bool, poplar::Tensor, size_t, bool, const poplar::OptionFlags &)","Filename":"poplar/Program.hpp","Text":"Copy ( const DataStream & stream , Tensor dst , bool rearrangeOnHost , Tensor offset , size_t repeats , bool optimiseMemory , const OptionFlags & options = { } )"}
{"Token type":"CXXConstructor","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Copy::Copy(poplar::Tensor, const poplar::DataStream &, bool, poplar::Tensor, size_t, bool, const poplar::OptionFlags &)","Filename":"poplar/Program.hpp","Text":"Copy ( Tensor src , const DataStream & stream , bool rearrangeOnHost , Tensor offset , size_t repeats , bool optimiseMemory , const OptionFlags & options = { } )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar::program","Name":"poplar::program::Copy::Copy(poplar::Tensor, poplar::Tensor, bool)","Filename":"poplar/Program.hpp","Text":"Copy ( Tensor src , Tensor dst , bool dontOutline = false )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar::program","Name":"poplar::program::Copy::Copy(const poplar::DataStream &, poplar::Tensor, bool)","Filename":"poplar/Program.hpp","Text":"Copy ( const DataStream & stream , Tensor dst , bool optimiseMemory = false )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar::program","Name":"poplar::program::Copy::Copy(poplar::Tensor, const poplar::DataStream &, bool)","Filename":"poplar/Program.hpp","Text":"Copy ( Tensor src , const DataStream & stream , bool optimiseMemory = false )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar::program","Name":"poplar::program::Copy::Copy(const poplar::RemoteBuffer &, poplar::Tensor)","Filename":"poplar/Program.hpp","Text":"Copy ( const RemoteBuffer & buffer , Tensor dst )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar::program","Name":"poplar::program::Copy::Copy(const poplar::RemoteBuffer &, poplar::Tensor, poplar::Tensor)","Filename":"poplar/Program.hpp","Text":"Copy ( const RemoteBuffer & buffer , Tensor dst , Tensor offset )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar::program","Name":"poplar::program::Copy::Copy(poplar::Tensor, const poplar::RemoteBuffer &)","Filename":"poplar/Program.hpp","Text":"Copy ( Tensor src , const RemoteBuffer & buffer )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar::program","Name":"poplar::program::Copy::Copy(poplar::Tensor, const poplar::RemoteBuffer &, poplar::Tensor)","Filename":"poplar/Program.hpp","Text":"Copy ( Tensor src , const RemoteBuffer & buffer , Tensor offset )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar::program","Name":"poplar::program::Copy::Copy(const poplar::DataStream &, poplar::Tensor, poplar::Tensor, bool, const poplar::OptionFlags &)","Filename":"poplar/Program.hpp","Text":"Copy ( const DataStream & stream , Tensor dst , Tensor expectedIndex , bool rearrangeOnHost = false , const OptionFlags & options = { } )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar::program","Name":"poplar::program::Copy::Copy(poplar::Tensor, const poplar::DataStream &, poplar::Tensor, bool, const poplar::OptionFlags &)","Filename":"poplar/Program.hpp","Text":"Copy ( Tensor src , const DataStream & stream , Tensor index , bool rearrangeOnHost = false , const OptionFlags & options = { } )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar::program","Name":"poplar::program::CrossReplicaCopy","Filename":"poplar/Program.hpp","Text":"class CrossReplicaCopy : public Program { public : /** Constructor to create a program to copy a tensor to the equivalent\n   * tensor in a different replica sub-graph. When the replicated graphs are\n   * created, this will create a Copy program in each replica. Each replica\n   * sends to exactly one other replica and receives from exactly one other\n   * replica. A replica may not copy to itself.\n   *\n   *  \\param src Replicated tensor to copy from.\n   *  \\param dst Replicated tensor to copy to.\n   *  \\param replicaMap Each \\a key in this map specifies the\n   *                    sub-graph or replica that contains the source tensor.\n   *                    The corresponding \\a value is the replica that\n   *                    contains the destination tensor.\\n\n   *                    The size of the replica map is equal to the graph\n   *                    replication factor.\\n\n   *                    Each replica must be represented once as a key (source)\n   *                    and once as a value (destination).\n   **/ CrossReplicaCopy ( Tensor src , Tensor dst , std :: map < unsigned , unsigned > replicaMap ) ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar::program","Name":"poplar::program::CrossReplicaCopy::CrossReplicaCopy(poplar::Tensor, poplar::Tensor, std::map<unsigned int, unsigned int>)","Filename":"poplar/Program.hpp","Text":"CrossReplicaCopy ( Tensor src , Tensor dst , std :: map < unsigned , unsigned > replicaMap )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar::program","Name":"poplar::program::WriteUndef","Filename":"poplar/Program.hpp","Text":"class WriteUndef : public Program { public : explicit WriteUndef ( Tensor t ) ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar::program","Name":"poplar::program::WriteUndef::WriteUndef(poplar::Tensor)","Filename":"poplar/Program.hpp","Text":"explicit WriteUndef ( Tensor t )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar::program","Name":"poplar::program::Sync","Filename":"poplar/Program.hpp","Text":"class Sync : public Program { public : /// \\param type The type of sync to perform. explicit Sync ( SyncType type ) ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar::program","Name":"poplar::program::Sync::Sync(poplar::SyncType)","Filename":"poplar/Program.hpp","Text":"explicit Sync ( SyncType type )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar::program","Name":"poplar::program::Call","Filename":"poplar/Program.hpp","Text":"class Call : public Program { public : /// Call the function /// \\param f  A program that has been added to the ///           graph using Graph::addFunction. explicit Call ( Function f ) ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar::program","Name":"poplar::program::Call::Call(poplar::Function)","Filename":"poplar/Program.hpp","Text":"explicit Call ( Function f )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar::program","Name":"poplar::program::PrintTensor","Filename":"poplar/Program.hpp","Text":"class PrintTensor : public Program { public : /** Print the contents of a tensor.\n   * You can send the output to a different stream by using\n   * the Engine::setPrintTensorStream function.\n   *\n   *  \\param t The tensor to print.\n   */ explicit PrintTensor ( Tensor t ) ; /** Print the name and contents of a Tensor.\n   *  \\param title The name of the tensor\n   *  \\param t     The tensor to print.\n   */ PrintTensor ( StringRef title , Tensor t ) ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar::program","Name":"poplar::program::PrintTensor::PrintTensor(poplar::Tensor)","Filename":"poplar/Program.hpp","Text":"explicit PrintTensor ( Tensor t )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar::program","Name":"poplar::program::PrintTensor::PrintTensor(poplar::StringRef, poplar::Tensor)","Filename":"poplar/Program.hpp","Text":"PrintTensor ( StringRef title , Tensor t )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar::program","Name":"poplar::program::ErrorProgram","Filename":"poplar/Program.hpp","Text":"class ErrorProgram : public Program { public : /** Throw an error.\n   *  Prints out a message and then throws an error.\n   *  \\param message String to print.\n   *  \\param debugTensor Tensor that will be printed after the message\n   *                     to aid debugging.\n   *\n   */ ErrorProgram ( StringRef message , Tensor debugTensor ) ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar::program","Name":"poplar::program::ErrorProgram::ErrorProgram(poplar::StringRef, poplar::Tensor)","Filename":"poplar/Program.hpp","Text":"ErrorProgram ( StringRef message , Tensor debugTensor )"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::dumpProgram(const poplar::Graph &, const poplar::program::Program &, std::ostream &)","Filename":"poplar/Program.hpp","Text":"void dumpProgram ( const Graph & graph , const Program & program , std :: ostream & out )"}
{"Token type":"EnumDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::TensorCloneMethod","Filename":"poplar/TensorCloneMethod.hpp","Text":"enum class TensorCloneMethod { PRESERVE_ORDER_AND_ALIASES , ///< Preserve the ordering and aliasing within ///  the original tensor reference . CREATE_NEW_ORDER , ///< Create a new tensor with natural ordering based on ///  the dimensions of the cloned tensor (in the same ///  way as addTensor). PRESERVE_ORDER_UNLESS_ALIASES ///< Preserve the ordering of the original ///  tensor unless it contains aliases. In ///  the case of aliases, create a new ///  tensor ordering and duplicate the ///  aliased elements. }"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::TensorCloneMethod::PRESERVE_ORDER_AND_ALIASES","Filename":"poplar/TensorCloneMethod.hpp","Text":"PRESERVE_ORDER_AND_ALIASES"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::TensorCloneMethod::CREATE_NEW_ORDER","Filename":"poplar/TensorCloneMethod.hpp","Text":"CREATE_NEW_ORDER"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::TensorCloneMethod::PRESERVE_ORDER_UNLESS_ALIASES","Filename":"poplar/TensorCloneMethod.hpp","Text":"PRESERVE_ORDER_UNLESS_ALIASES"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::toString(const poplar::TensorCloneMethod &)","Filename":"poplar/TensorCloneMethod.hpp","Text":"std :: string toString ( const TensorCloneMethod & method )"}
{"Token type":"EnumDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::TensorCloneDuplicationMethod","Filename":"poplar/TensorCloneMethod.hpp","Text":"enum class TensorCloneDuplicationMethod { DUPLICATE_BY_OUTER_DIMENSION , ///< The multiple clones are concatenated ///  in their outermost dimension. i.e. the ///  result is the same as ///  concat(clone1, clone2, ..., cloneN); ///  There is no guarantee of any ordering ///  constraints in memory between the clones. DUPLICATE_BY_TILE_CONTIGUOUS_REGION , ///< The underlying variables of the clones are contenated for ///  each contiguous region on each tile. ///  Each clone will have the same contiguous regions on each tile ///  but each of those regions will also form bigger ///  contiguous regions across the N duplicates. ///  This option is particular useful for efficient slicing/copying ///  between the duplicates being cloned. }"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::TensorCloneDuplicationMethod::DUPLICATE_BY_OUTER_DIMENSION","Filename":"poplar/TensorCloneMethod.hpp","Text":"DUPLICATE_BY_OUTER_DIMENSION"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::TensorCloneDuplicationMethod::DUPLICATE_BY_TILE_CONTIGUOUS_REGION","Filename":"poplar/TensorCloneMethod.hpp","Text":"DUPLICATE_BY_TILE_CONTIGUOUS_REGION"}
{"Token type":"EnumDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::VariableMappingMethod","Filename":"poplar/VariableMappingMethod.hpp","Text":"enum class VariableMappingMethod { NONE , ///< No mapping is created. The tile mapping will be set /// later via Graph::setTileMapping. LINEAR ///< The variable will be spread evenly across the tiles /// with the element ordering matching the tile number /// ordering. The tile mapping can also be overridden /// later via Graph::setTileMapping. }"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::VariableMappingMethod::NONE","Filename":"poplar/VariableMappingMethod.hpp","Text":"NONE"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::VariableMappingMethod::LINEAR","Filename":"poplar/VariableMappingMethod.hpp","Text":"LINEAR"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::toString(const poplar::VariableMappingMethod &)","Filename":"poplar/VariableMappingMethod.hpp","Text":"std :: string toString ( const VariableMappingMethod & method )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::VariableRef","Filename":"poplar/VariableRef.hpp","Text":"class VariableRef { unsigned id ; unsigned replicationFactor ; public : VariableRef ( unsigned id , unsigned replicationFactor ) : id ( id ) , replicationFactor ( replicationFactor ) { } VariableRef ( ) = default ; VariableRef ( const VariableRef & other ) = default ; VariableRef ( VariableRef && other ) = default ; VariableRef & operator = ( const VariableRef & other ) = default ; VariableRef & operator = ( VariableRef && other ) = default ; friend bool operator == ( const VariableRef & a , const VariableRef & b ) { return std :: tie ( a . id , a . replicationFactor ) == std :: tie ( b . id , b . replicationFactor ) ; } friend bool operator < ( const VariableRef & a , const VariableRef & b ) { return std :: tie ( a . id , a . replicationFactor ) < std :: tie ( b . id , b . replicationFactor ) ; } std :: size_t hash ( ) const ; friend class Graph ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::VariableRef::VariableRef(unsigned int, unsigned int)","Filename":"poplar/VariableRef.hpp","Text":"VariableRef ( unsigned id , unsigned replicationFactor )"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::VariableRef::VariableRef()","Filename":"poplar/VariableRef.hpp","Text":"VariableRef ( ) = default"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::VariableRef::VariableRef(const poplar::VariableRef &)","Filename":"poplar/VariableRef.hpp","Text":"VariableRef ( const VariableRef & other ) = default"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::VariableRef::VariableRef(poplar::VariableRef &&)","Filename":"poplar/VariableRef.hpp","Text":"VariableRef ( VariableRef && other ) = default"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::VariableRef::operator=(const poplar::VariableRef &)","Filename":"poplar/VariableRef.hpp","Text":"VariableRef & operator = ( const VariableRef & other ) = default"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::VariableRef::operator=(poplar::VariableRef &&)","Filename":"poplar/VariableRef.hpp","Text":"VariableRef & operator = ( VariableRef && other ) = default"}
{"Token type":"FunctionDecl","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::VariableRef::operator==(const poplar::VariableRef &, const poplar::VariableRef &)","Filename":"poplar/VariableRef.hpp","Text":"friend bool operator == ( const VariableRef & a , const VariableRef & b )"}
{"Token type":"FunctionDecl","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::VariableRef::operator<(const poplar::VariableRef &, const poplar::VariableRef &)","Filename":"poplar/VariableRef.hpp","Text":"friend bool operator < ( const VariableRef & a , const VariableRef & b )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::VariableRef::hash()","Filename":"poplar/VariableRef.hpp","Text":"std :: size_t hash ( ) const"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::VariableInterval","Filename":"poplar/VariableRef.hpp","Text":"struct VariableInterval { VariableRef var ; Interval interval ; VariableInterval ( VariableRef var , Interval interval ) : var ( var ) , interval ( std :: move ( interval ) ) { } VariableInterval ( ) = default ; VariableInterval ( const VariableInterval & other ) = default ; VariableInterval ( VariableInterval && other ) = default ; VariableInterval & operator = ( const VariableInterval & other ) = default ; VariableInterval & operator = ( VariableInterval && other ) = default ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::VariableInterval::VariableInterval(poplar::VariableRef, poplar::Interval)","Filename":"poplar/VariableRef.hpp","Text":"VariableInterval ( VariableRef var , Interval interval )"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::VariableInterval::VariableInterval()","Filename":"poplar/VariableRef.hpp","Text":"VariableInterval ( ) = default"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::VariableInterval::VariableInterval(const poplar::VariableInterval &)","Filename":"poplar/VariableRef.hpp","Text":"VariableInterval ( const VariableInterval & other ) = default"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::VariableInterval::VariableInterval(poplar::VariableInterval &&)","Filename":"poplar/VariableRef.hpp","Text":"VariableInterval ( VariableInterval && other ) = default"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::VariableInterval::operator=(const poplar::VariableInterval &)","Filename":"poplar/VariableRef.hpp","Text":"VariableInterval & operator = ( const VariableInterval & other ) = default"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::VariableInterval::operator=(poplar::VariableInterval &&)","Filename":"poplar/VariableRef.hpp","Text":"VariableInterval & operator = ( VariableInterval && other ) = default"}
{"Token type":"FunctionDecl","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::operator==(const poplar::VariableInterval &, const poplar::VariableInterval &)","Filename":"poplar/VariableRef.hpp","Text":"bool operator == ( const VariableInterval & a , const VariableInterval & b )"}
{"Token type":"FunctionDecl","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<(const poplar::VariableInterval &, const poplar::VariableInterval &)","Filename":"poplar/VariableRef.hpp","Text":"bool operator < ( const VariableInterval & a , const VariableInterval & b )"}
{"Token type":"StructDecl","FaliureReason":"not_allowed_namespace","Implemented":false,"Namespace":"std","Name":"std::hash<poplar::VariableRef>","Filename":"poplar/VariableRef.hpp","Text":"template < > struct hash < poplar :: VariableRef > { size_t operator ( ) ( const poplar :: VariableRef & v ) const { return v . hash ( ) ; } }"}
{"Token type":"CXXMethod","FaliureReason":"not_allowed_namespace","Implemented":false,"Namespace":"std","Name":"std::hash<poplar::VariableRef>::operator()(const poplar::VariableRef &)","Filename":"poplar/VariableRef.hpp","Text":"size_t operator ( ) ( const poplar :: VariableRef & v ) const"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar::layout","Name":"poplar::layout::operator<<(std::ostream &, const poplar::layout::Vector)","Filename":"poplar/VectorLayout.hpp","Text":"std :: ostream & operator << ( std :: ostream & os , const Vector v )"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar::layout","Name":"poplar::layout::operator<<(std::ostream &, const poplar::layout::VectorList)","Filename":"poplar/VectorLayout.hpp","Text":"std :: ostream & operator << ( std :: ostream & os , const VectorList v )"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::VertexIntrospector","Filename":"poplar/VertexIntrospector.hpp","Text":"class VertexIntrospector"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::FieldData","Filename":"poplar/VertexIntrospector.hpp","Text":"class FieldData"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::FieldData","Filename":"poplar/VertexIntrospector.hpp","Text":"class FieldData { public : struct SizeT { std :: size_t value ; std :: size_t size ( ) const { return value ; } } ; FieldData ( const FieldData & ) = delete ; FieldData ( FieldData && ) ; virtual ~ FieldData ( ) ; /// Return the rank of the field: 0 for scalar fields, 1 for 1D and 2 for 2D. unsigned rank ( ) const ; /// Return the size of the field. For scalar fields it returns 1, for /// 1D fields it returns the size of the vector, and for 2D fields it returns /// the number of sub-vectors. std :: size_t size ( ) const ; /// For 2D fields, return the size of the sub-vector. Throws an error /// if called on non-2D fields. /// \\param i Index of sub-vector to return size of std :: size_t getSizeAtIndex ( std :: size_t i ) const ; /// For Vector fields return the layout. /// \\param i The dimension to query, 0 for the outer vector, 1 for the inner. layout :: Vector getProfilerVectorLayout ( std :: size_t nestingLevel ) const ; /// For VectorList fields return the layout. We only support introspecting /// a VectorList that is the outermost vector. layout :: VectorList getProfilerVectorListLayout ( ) const ; /// Instead of field.getSizeAtIndex(i) you can alternatively use /// field[i].size(). SizeT operator [ ] ( std :: size_t i ) const { return SizeT { getSizeAtIndex ( i ) } ; } /// Return the name of the vertex field. std :: string name ( ) const ; /// Get the inital value for a scalar field. T should be a scalar type. /// Throws an error if this is not a scalar field. template < typename T > T getInitialValue ( const Target & target ) const { static_assert ( TypeTraits :: isSimpleType < T > ( ) , \"getInitialValue() called with invalid type\" ) ; if ( rank ( ) != 0 ) { throw poplar_error ( \"You may not call getInitialValue() on a non-scalar \" \"(use getInitalValues() - with an 's')\" ) ; } T result ; const auto traits = TypeTraits :: make < T > ( ) ; getInitialValues ( target , reinterpret_cast < void * > ( & result ) , traits ) ; return result ; } /// Get the initial value for a 1D or 2D vector field. T should be a scalar /// type (e.g. float) for 1D fields and std::vector<> for 2D fields. /// Throws an error if this is a scalar field. template < typename T > std :: vector < T > getInitialValues ( const Target & target ) const { if ( rank ( ) == 0 ) { throw poplar_error ( \"You may not call getInitialValues() on a scalar \" \"(use getInitalValue() - no 's')\" ) ; } std :: vector < T > result ( size ( ) ) ; // The following resolves whether this function was called // with T := SCALAR or T := std::vector<SCALAR>: getInitialValuesOverload ( target , result ) ; return result ; } // Implementation FieldData ( std :: unique_ptr < core :: FieldData > fd ) ; private : std :: unique_ptr < core :: FieldData > impl ; // This overload retrieves the initial value of any field with one index. template < typename T > void getInitialValuesOverload ( const Target & target , std :: vector < T > & result ) const { static_assert ( TypeTraits :: isSimpleType < T > ( ) , \"getInitialValues() called with invalid type\" ) ; if ( rank ( ) != 1 ) { throw poplar_error ( \"getInitialValues() must be called with a \" \"std::vector<T> for 1D fields\" ) ; } auto traits = TypeTraits :: make < T > ( ) ; getInitialValues ( target , result . data ( ) , traits ) ; } // This overload retrieves the initial values of any field with // two indices e.g. Vector<Input<Vector<scalar>>> template < typename T > void getInitialValuesOverload ( const Target & target , std :: vector < std :: vector < T >> & result ) const { static_assert ( TypeTraits :: isSimpleType < T > ( ) , \"getInitialValues() called with invalid type\" ) ; if ( rank ( ) != 2 ) { throw poplar_error ( \"getInitialValues() must be called with a \" \"std::vector<std::vector<T>> for 1D fields\" ) ; } auto traits = TypeTraits :: make < T > ( ) ; for ( auto i = 0u ; i < result . size ( ) ; ++ i ) { result [ i ] = std :: vector < T > ( getSizeAtIndex ( i ) ) ; // It is not an error to return empty vectors here // (e.g. some tests in poplin generate empty worklists). if ( ! result [ i ] . empty ( ) ) { getInitialValues ( target , result [ i ] . data ( ) , traits , i ) ; } } } void getInitialValues ( const Target & target , void * dst , const TypeTraits & traits , std :: size_t index = std :: numeric_limits < std :: size_t > :: max ( ) ) const ; }"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::FieldData::SizeT","Filename":"poplar/VertexIntrospector.hpp","Text":"struct SizeT { std :: size_t value ; std :: size_t size ( ) const { return value ; } }"}
{"Token type":"CXXMethod","FaliureReason":"filedata_size_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldData::SizeT::size()","Filename":"poplar/VertexIntrospector.hpp","Text":"std :: size_t size ( ) const"}
{"Token type":"CXXConstructor","FaliureReason":"deleted_method","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldData::FieldData(const poplar::FieldData &)","Filename":"poplar/VertexIntrospector.hpp","Text":"FieldData ( const FieldData & ) = delete"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldData::FieldData(poplar::FieldData &&)","Filename":"poplar/VertexIntrospector.hpp","Text":"FieldData ( FieldData && )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::FieldData::rank()","Filename":"poplar/VertexIntrospector.hpp","Text":"unsigned rank ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::FieldData::size()","Filename":"poplar/VertexIntrospector.hpp","Text":"std :: size_t size ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::FieldData::getSizeAtIndex(std::size_t)","Filename":"poplar/VertexIntrospector.hpp","Text":"std :: size_t getSizeAtIndex ( std :: size_t i ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::FieldData::getProfilerVectorLayout(std::size_t)","Filename":"poplar/VertexIntrospector.hpp","Text":"layout :: Vector getProfilerVectorLayout ( std :: size_t nestingLevel ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::FieldData::getProfilerVectorListLayout()","Filename":"poplar/VertexIntrospector.hpp","Text":"layout :: VectorList getProfilerVectorListLayout ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldData::operator[](std::size_t)","Filename":"poplar/VertexIntrospector.hpp","Text":"SizeT operator [ ] ( std :: size_t i ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::FieldData::name()","Filename":"poplar/VertexIntrospector.hpp","Text":"std :: string name ( ) const"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldData::getInitialValue(const poplar::Target &)","Filename":"poplar/VertexIntrospector.hpp","Text":"template < typename T > T getInitialValue ( const Target & target ) const"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldData::getInitialValues(const poplar::Target &)","Filename":"poplar/VertexIntrospector.hpp","Text":"template < typename T > std :: vector < T > getInitialValues ( const Target & target ) const"}
{"Token type":"CXXConstructor","FaliureReason":"unique_ptr_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldData::FieldData(std::unique_ptr<core::FieldData>)","Filename":"poplar/VertexIntrospector.hpp","Text":"FieldData ( std :: unique_ptr < core :: FieldData > fd )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldData::getInitialValuesOverload(const poplar::Target &, std::vector<T> &)","Filename":"poplar/VertexIntrospector.hpp","Text":"template < typename T > void getInitialValuesOverload ( const Target & target , std :: vector < T > & result ) const"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldData::getInitialValuesOverload(const poplar::Target &, std::vector<std::vector<T> > &)","Filename":"poplar/VertexIntrospector.hpp","Text":"template < typename T > void getInitialValuesOverload ( const Target & target , std :: vector < std :: vector < T >> & result ) const"}
{"Token type":"CXXMethod","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldData::getInitialValues(const poplar::Target &, void *, const poplar::TypeTraits &, std::size_t)","Filename":"poplar/VertexIntrospector.hpp","Text":"void getInitialValues ( const Target & target , void * dst , const TypeTraits & traits , std :: size_t index = std :: numeric_limits < std :: size_t > :: max ( ) ) const"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::VertexIntrospector","Filename":"poplar/VertexIntrospector.hpp","Text":"class VertexIntrospector { public : /// Return information about the vertex's field. /// //// \\param name   The name of the vertex field as defined in its codelet. FieldData getFieldInfo ( const std :: string & name ) const ; /// Return the compute set that this vertex is in. ComputeSet getComputeSet ( ) const ; // Implementation VertexIntrospector ( std :: unique_ptr < core :: VertexIntrospector > impl ) ; VertexIntrospector ( VertexIntrospector && ) ; const core :: VertexIntrospector & getImpl ( ) const { return * impl ; } private : std :: unique_ptr < core :: VertexIntrospector > impl ; }"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::VertexIntrospector::getFieldInfo(const std::string &)","Filename":"poplar/VertexIntrospector.hpp","Text":"FieldData getFieldInfo ( const std :: string & name ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::VertexIntrospector::getComputeSet()","Filename":"poplar/VertexIntrospector.hpp","Text":"ComputeSet getComputeSet ( ) const"}
{"Token type":"CXXConstructor","FaliureReason":"unique_ptr_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::VertexIntrospector::VertexIntrospector(std::unique_ptr<core::VertexIntrospector>)","Filename":"poplar/VertexIntrospector.hpp","Text":"VertexIntrospector ( std :: unique_ptr < core :: VertexIntrospector > impl )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::VertexIntrospector::VertexIntrospector(poplar::VertexIntrospector &&)","Filename":"poplar/VertexIntrospector.hpp","Text":"VertexIntrospector ( VertexIntrospector && )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::VertexIntrospector::getImpl()","Filename":"poplar/VertexIntrospector.hpp","Text":"const core :: VertexIntrospector & getImpl ( ) const"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::replication_factor","Filename":"poplar/replication_factor.hpp","Text":"struct replication_factor { unsigned value ; explicit constexpr replication_factor ( unsigned v ) : value ( v ) { } replication_factor & operator ++ ( ) { ++ value ; return * this ; } bool operator == ( const replication_factor other ) const { return value == other . value ; } bool operator != ( const replication_factor other ) const { return value != other . value ; } bool operator < ( const replication_factor other ) const { return value < other . value ; } }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::replication_factor::replication_factor(unsigned int)","Filename":"poplar/replication_factor.hpp","Text":"explicit constexpr replication_factor ( unsigned v ) : value ( v ) { }"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::replication_factor::operator++()","Filename":"poplar/replication_factor.hpp","Text":"replication_factor & operator ++ ( )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::replication_factor::operator==(const poplar::replication_factor)","Filename":"poplar/replication_factor.hpp","Text":"bool operator == ( const replication_factor other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::replication_factor::operator!=(const poplar::replication_factor)","Filename":"poplar/replication_factor.hpp","Text":"bool operator != ( const replication_factor other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::replication_factor::operator<(const poplar::replication_factor)","Filename":"poplar/replication_factor.hpp","Text":"bool operator < ( const replication_factor other ) const"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::GraphBuilder","Filename":"poplar/Graph.hpp","Text":"class GraphBuilder"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::versionString()","Filename":"poplar/Graph.hpp","Text":"StringRef versionString ( )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::packageHash()","Filename":"poplar/Graph.hpp","Text":"StringRef packageHash ( )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph","Filename":"poplar/Graph.hpp","Text":"class Graph { public : /** Construct a graph object.\n   *\n   *  This constructor creates a Graph object using the given\n   *  graph programming environment.\n   *\n   *  \\param target  The target the graph is being constructed to work with.\n   *  \\param r  Number of times graph is to be replicated (default is no\n   *                                    replication)\n   */ Graph ( const Target & target , replication_factor r = replication_factor ( 1 ) ) ; /** Construct a graph object.\n   *\n   *  This constructor creates a Graph object using the given\n   *  graph programming environment.\n   *\n   *  \\param device  The device the graph is being constructed to work with.\n   *  \\param r  Number of times graph is to be replicated (default is no\n   *                                    replication)\n   */ Graph ( const Device & device , replication_factor r = replication_factor ( 1 ) ) ; Graph ( Graph && ) ; Graph & operator = ( Graph && ) ; ~ Graph ( ) ; /** Retrieve the target that this graph is targeting. */ const Target & getTarget ( ) const ; /** Add a codelet to the graph. A codelet is either a C, C++, or assembly\n   * source file, or a .gp object file. If a source file is given it is\n   * compiled for the graph's target and then loaded into the graph. If it is\n   * an object file then it is loaded into the graph.\n   *\n   * Symbols that codelets use are not resolved until the engine is built, so\n   * codelets can use symbols from each other by calling addCodelets() for\n   * each source or object file (or passing a list of files as a vector).\n   *\n   * \\param src   The path to a source or object file containing codelets.\n   * \\param type  Specify the type of the codelet (source or precompiled). If\n   *              Auto is used, the type is determined from the filename\n   *              extension.\n   * \\param compileFlags   Additional flags to pass to the compiler if\n   *                       using source code. For example, `-g` to generate\n   *                       debug info.\n   * \\return True if the codelet is added to the graph successfully,\n   *         or false if the codelet already existed in the graph.\n   */ bool addCodelets ( StringRef src , CodeletFileType type = CodeletFileType :: Auto , StringRef compileFlags = \"\" ) ; /** Add a codelet to the graph and write error messages from the compilation\n   * process to the given output stream. By default they are printed to cerr.\n   */ bool addCodelets ( StringRef src , CodeletFileType type , StringRef compileFlags , std :: ostream & compileOutput ) ; /** Add a set of codelets to the graph. These codelets can depend on each\n   * other, for example symbols defined in one can be used by any other.\n   * The order is not important.\n   *\n   * \\return True if all the codelets are added successfully, or false if\n   *         any of the codelets are not added because they already exist\n   *         in the graph.\n   */ bool addCodelets ( ArrayRef < std :: string > xs , StringRef compileFlags = \"\" ) { bool allAdded = true ; for ( const auto & x : xs ) allAdded &= addCodelets ( x , CodeletFileType :: Auto , compileFlags ) ; return allAdded ; } // Take a C++ codelet contained within the |stream| and store it in a // temporary file which we then use to compile the codelet. // // Note that this is not idempotent, i.e. this function will throw an // exception if called twice with the same stream, unlike the overload // that takes a file path instead. void addCodelets ( std :: stringstream & stream , StringRef compileFlags = \"\" ) ; void addCodelets ( std :: stringstream & stream , StringRef compileFlags , std :: ostream & compileOutput ) ; class ConnectionDesc { enum class Kind { TensorEdge , ValueEdge , VectorTensorEdge } ; Kind kind ; std :: string field ; std :: vector < Tensor > ts ; std :: unique_ptr < char [ ] > val ; TypeTraits traits ; void connect ( Graph & g , const VertexRef & v ) const { switch ( kind ) { case Kind :: TensorEdge : g . connect ( v [ field ] , ts [ 0 ] ) ; break ; case Kind :: ValueEdge : g . connect ( v [ field ] , val . get ( ) , traits ) ; break ; case Kind :: VectorTensorEdge : g . connect ( v [ field ] , ts ) ; } } public : ConnectionDesc ( StringRef field , Tensor t ) : kind ( Kind :: TensorEdge ) , field ( field . begin ( ) , field . end ( ) ) , ts ( { std :: move ( t ) } ) { } ConnectionDesc ( StringRef field , ArrayRef < Tensor > tsArr ) : kind ( Kind :: VectorTensorEdge ) , field ( field . begin ( ) , field . end ( ) ) , ts ( tsArr . begin ( ) , tsArr . end ( ) ) { } template < typename T > ConnectionDesc ( StringRef field , T v , typename std :: enable_if < TypeTraits :: isSimpleType < T > ( ) > :: type * = nullptr ) : kind ( Kind :: ValueEdge ) , field ( field . begin ( ) , field . end ( ) ) , traits ( TypeTraits :: make < T > ( ) ) { val . reset ( new char [ traits . size ] ) ; std :: memcpy ( & val [ 0 ] , & v , traits . size ) ; } friend class Graph ; } ; /** Add a vertex to the graph.\n   *\n   *  \\param cs         The compute set to add the vertex to.\n   *  \\param vertexType The name of the type of the vertex. This must\n   *                    be a declared vertex type in the graph programming\n   *                    environment used to create the graph builder.\n   */ VertexRef addVertex ( ComputeSet cs , StringRef vertexType ) ; /** Add a vertex to the graph and connect graph elements to some of\n   *  its fields.\n   *\n   *  This variant of add vertex allows you to pass in a list of\n   *  connection descriptions to connect graph elements to fields of the\n   *  newly created vertex. The connection descriptions can be\n   *  initialized with:\n   *\n   *   * { string, Tensor }  - connect a tensor to a field.\n   *   * { string, FieldRef, bool } - connect a vertex field to a field.\n   *   * { string, T v } - connect a constant value to an input field.\n   *\n   *  For example, the following:\n   *\n   *    \\code\n   *    addVertex(cs, \"MyVertex\", {{\"x\", tensor[4]}, {\"y\", v[\"z\"], false}});\n   *    \\endcode\n   *\n   *  Will create a vertex and connect a tensor to its x field\n   *  and the vertex field v[\"z\"] to its y field.\n   *\n   *  \\param cs          The compute set to add the vertex to.\n   *  \\param vertexType  The name of the type of the vertex. This must\n   *                     be a declared vertex type in the graph programming\n   *                     environment used to create the graph builder.\n   *  \\param connections A list of connection descriptions\n   */ VertexRef addVertex ( ComputeSet cs , StringRef vertexType , ArrayRef < ConnectionDesc > connections ) { auto v = addVertex ( cs , vertexType ) ; for ( const auto & c : connections ) { c . connect ( * this , v ) ; } return v ; } /**\n   * Add an external exchange vertex to the graph. A compute set can contain\n   * at most one external exchange vertex per tile. External exchange vertices\n   * cannot be mixed with non external exchange vertices in the same compute\n   * set. Before an external vertex is called we set the INCOMING_DCOUNT\n   * and INCOMING_MUX mux registers and synchronize all tiles containing\n   * external exchange vertices.\n   * \\param cs                The compute set to add the vertex to.\n   * \\param vertexType        The name of the type of the vertex. This must\n   *                          be a declared vertex type in the graph\n   *                          programming environment used to create the graph\n   *                          builder.\n   * \\param incomingDownCount The value to set the INCOMING_DCOUNT register\n   *                          to.\n   * \\param usesEastEdge      Whether the vertex uses an east edge exchange\n   *                          block. The INCOMING_MUX register is set\n   *                          to point to either the east edge or west edge\n   *                          depending on this argument.\n   * \\param sendsXReq         Whether this vertex is responsible for sending\n   *                          the XREQ packet. There must be at most one tile\n   *                          per exchange block context that sends the XREQ\n   *                          and the tile must be the same in every compute\n   *                          set containing external exchange vertices.\n   */ VertexRef addExternalExchangeVertex ( ComputeSet cs , StringRef vertexType , unsigned incomingDownCount , bool usesEastEdge , bool sendsXReq ) ; /** Add a variable to the graph.\n   *\n   *  \\param type       The type of the elements of the variable.\n   *  \\param shape      The shape of the variable.\n   *  \\param name       An optional name to identify the variable for\n   *                    debugging/profiling purposes\n   *  \\param returns    A Tensor referring to the variable in the graph.\n   *\n   *  If using this function with a target with multiple tiles then\n   *  the variable will initially have no tile mapping under the expectation\n   *  that the tile mapping will be set later with Graph::setTileMapping.\n   *  If the target of the graph has only one tile then the tensor will\n   *  be automatically mapped to that tile.\n   *\n   */ Tensor addVariable ( const Type & type , ArrayRef < std :: size_t > shape , const DebugContext & debugContext = { } ) ; /** Add a variable to the graph.\n   *\n   *  \\param type       The type of the elements of the variable.\n   *  \\param shape      The shape of the variable.\n   *  \\param mappingMethod\n   *                    The method to use to initially map the variable\n   *                    to tiles.\n   *  \\param name       An optional name to identify the variable for\n   *                    debugging/profiling purposes\n   *  \\returns    A Tensor referring to the variable in the graph.\n   */ Tensor addVariable ( const Type & type , ArrayRef < std :: size_t > shape , VariableMappingMethod mappingMethod , const DebugContext & debugContext = { } ) ; /** Add a constant to the graph.\n   *\n   *  A constant tensor is a tensor with every element initialized.\n   *\n   *  \\param type       The type of the elements of the constant.\n   *  \\param shape      The shape of the constant.\n   *  \\param values     Vector of values to initialize tensor elements to.\n   *  \\param name       An optional name to identify the variable for\n   *                    debugging/profiling purposes\n   */ template < typename T > Tensor addConstant ( const Type & type , ArrayRef < std :: size_t > shape , ArrayRef < T > values , const DebugContext & debugContext = { \"<const>\" } ) { const auto elements = std :: accumulate ( shape . begin ( ) , shape . end ( ) , std :: size_t ( 1 ) , std :: multiplies < size_t > ( ) ) ; if ( values . size ( ) != elements ) { throw poplar_error ( \"The number of constant values (\" + std :: to_string ( values . size ( ) ) + \") does not match \" \"the number of Tensor elements (\" + std :: to_string ( elements ) + \")\" ) ; } return addConstant ( type , shape , reinterpret_cast < const void * > ( values . data ( ) ) , TypeTraits :: make < T > ( ) , false , debugContext ) ; } /** Add a constant to the graph.\n   *\n   *  A constant tensor is a tensor with every element initialized to\n   *  the same value. It cannot be connected to a vertex output.\n   *\n   *  \\param type       The type of the elements of the constant.\n   *  \\param shape      The shape of the constant.\n   *  \\param val        The value to initialize tensor elements to.\n   *  \\param name       An optional name to identify the variable for\n   *                    debugging/profiling purposes\n   */ template < typename T > Tensor addConstant ( const Type & type , ArrayRef < std :: size_t > shape , T val , const DebugContext & debugContext = { \"<const>\" } , typename std :: enable_if < TypeTraits :: isSimpleType < T > ( ) > :: type * = nullptr ) { return addConstant ( type , shape , reinterpret_cast < const void * > ( & val ) , TypeTraits :: make < T > ( ) , true , debugContext ) ; } /** Add a constant to the graph with multiple cell values.\n   *\n   *  A constant tensor is a tensor with every element initialized to\n   *  the same value. It cannot be connected to a vertex output.\n   *\n   *  \\param type       The type of the elements of the constant.\n   *  \\param shape      The shape of the constant.\n   *  \\param val        The value to initialize tensor elements to.\n   *  \\param name       An optional name to identify the variable for\n   *                    debugging/profiling purposes\n   */ template < typename T > Tensor addConstant ( const Type & type , ArrayRef < std :: size_t > shape , const T * val , const DebugContext & debugContext = { \"<const>\" } , typename std :: enable_if < TypeTraits :: isSimpleType < T > ( ) > :: type * = nullptr ) { return addConstant ( type , shape , reinterpret_cast < const void * > ( val ) , TypeTraits :: make < T > ( ) , false , debugContext ) ; } Tensor addConstant ( const Type & type , ArrayRef < std :: size_t > shape , const void * val , const TypeTraits & traits , bool broadcast , const DebugContext & debugContext = { \"<const>\" } ) ; /** Add a constant to the graph, where the host data is type IEEE half.\n   *\n   *  A constant tensor is a tensor with every element initialized to\n   *  the same value. It cannot be connected to a vertex output.\n   *\n   *  \\param type       The type of the elements of the constant.\n   *  \\param shape      The shape of the constant.\n   *  \\param val        The value to initialize tensor elements to.\n   */ Tensor addConstantHalf ( const Type & type , ArrayRef < std :: size_t > shape , uint16_t val , const DebugContext & debugContext = { \"<const>\" } ) { return addConstant ( type , shape , reinterpret_cast < const void * > ( & val ) , TypeTraits :: make < IeeeHalf > ( ) , true , debugContext ) ; } /** Add a constant to the graph with multiple cell values, where the host\n   *  data is type IEEE half.\n   *\n   *  A constant tensor is a tensor with every element initialized to\n   *  the same value. It cannot be connected to a vertex output.\n   *\n   *  \\param type       The type of the elements of the constant.\n   *  \\param shape      The shape of the constant.\n   *  \\param val        The value to initialize tensor elements to.\n   */ Tensor addConstantHalf ( const Type & type , ArrayRef < std :: size_t > shape , const uint16_t * val , const DebugContext & debugContext = { \"<const>\" } ) { return addConstant ( type , shape , reinterpret_cast < const void * > ( val ) , TypeTraits :: make < IeeeHalf > ( ) , false , debugContext ) ; } /** Add a tensor to the graph that has the same size and tile mapping as\n   *  Tensor t.\n   *\n   *  \\param type        The element type of the new tensor.\n   *  \\param t           The tensor to be cloned.\n   *  \\param name        A debug name to give to any new tensors allocated\n   *                     in the graph during the clone. If this is\n   *                     empty then the debug names will be derived from\n   *                     existing tensor debug names.\n   *  \\param method      The method to use for the cloning (decides whether\n   *                     to preserve ordering/aliasing in the new tensor).\n   */ Tensor clone ( const Type & type , const Tensor & t , const DebugContext & debugContext = { } , TensorCloneMethod method = TensorCloneMethod :: PRESERVE_ORDER_UNLESS_ALIASES ) ; /** Clone a tensor N times.\n   *\n   *  Given a tensor of shape [D1, D2, ... Dn], this function will create a new\n   *  tensor of shape [N, D1, D2, ..., Dn] where each of the N sub-tensors\n   *  is a clone of the original tensor (i.e. has the same layout and\n   *  tile mapping).\n   *\n   *  \\param type               The element type of the new tensor.\n   *  \\param t                  The tensor to clone\n   *  \\param N                  The replication factor to clone with\n   *  \\param name               The name for the new variables created\n   *  \\param method             The tensor cloning method (see Graph::clone)\n   *  \\param duplicationMethod  The behaviour used when a Tensor is cloned.\n   *                            \\sa TensorCloneDuplicationMethod\n   */ Tensor cloneN ( const Type & type , const Tensor & t , std :: size_t N , const DebugContext & debugContext = { } , TensorCloneMethod method = TensorCloneMethod :: PRESERVE_ORDER_UNLESS_ALIASES , TensorCloneDuplicationMethod duplicationMethod = TensorCloneDuplicationMethod :: DUPLICATE_BY_OUTER_DIMENSION ) ; /** Add a tensor to the graph that has the same size and tile mapping as\n   *  Tensor t.\n   *\n   *  \\param t           The tensor to be cloned.\n   *  \\param name        A debug name to give to any new tensors allocated\n   *                     in the graph during the clone. If this is\n   *                     empty then the debug names will be derived from\n   *                     existing tensor debug names.\n   *  \\param method      The method to use for the cloning (decides whether\n   *                     to preserve ordering/aliasing in the new tensor).\n   */ Tensor clone ( const Tensor & t , const DebugContext & debugContext = { } , TensorCloneMethod method = TensorCloneMethod :: PRESERVE_ORDER_UNLESS_ALIASES ) { return clone ( t . elementType ( ) , t , debugContext , method ) ; } /** Clone a tensor N times.\n   *\n   *  Given a tensor of shape [D1, D2, ... Dn], this function will create a new\n   *  tensor of shape [N, D1, D2, ..., Dn] where each of the N sub-tensors\n   *  is a clone of the original tensor (i.e. has the same layout and\n   *  tile mapping).\n   *\n   *  \\param t                  The tensor to clone\n   *  \\param N                  The replication factor to clone with\n   *  \\param name               The name for the new variables created\n   *  \\param method             The tensor cloning method (see Graph::clone)\n   *  \\param duplicationMethod  The behaviour used when a Tensor is cloned.\n   *                            \\sa TensorCloneDuplicationMethod\n   */ Tensor cloneN ( const Tensor & t , std :: size_t N , const DebugContext & debugContext = { } , TensorCloneMethod method = TensorCloneMethod :: PRESERVE_ORDER_UNLESS_ALIASES , TensorCloneDuplicationMethod duplicationMethod = TensorCloneDuplicationMethod :: DUPLICATE_BY_OUTER_DIMENSION ) { return cloneN ( t . elementType ( ) , t , N , debugContext , method , duplicationMethod ) ; } /** Connect a tensor to a vertex field.\n   *\n   * This function connects an a tensor with a vertex field.\n   * If the vertex field is an scalar input/output\n   * then a simple edge is added (and the tensor must be of zero dimension;\n   * in other words, a scalar).\n   * If the vertex field is an input/output of a vector then a vector edge\n   * is added (and the tensor must be of dimension 1).\n   * If the vertex field is a vector of inputs or outputs then the size of\n   * the field is set to the correct size and edges are\n   * added for every element of the tensor tensor (and the tensor must\n   * be of dimension 1).\n   * If the vertex field is a vector of input or output vectors\n   * then the tensor must be 2-dimensional. In this case,\n   * the size of the vector field\n   * is set to the size of the first dimension and\n   * vector edges are added for every sub-vector of the two dimensional\n   * tensor.\n   *\n   * \\param tensor         The tensor.\n   * \\param field          Reference to the vertex field to connect.\n   */ void connect ( FieldRef field , const Tensor & tensor ) ; /** Connect a constant value to an input field.\n   *\n   *  This method creates a single-element tensor containing a specified\n   *  value and connects that tensor element to an input field.\n   *\n   *  \\param v       The value to connect.\n   *  \\param field   The field to connect to.\n   */ template < typename T > void connect ( FieldRef field , T v , typename std :: enable_if < TypeTraits :: isSimpleType < T > ( ) > :: type * = nullptr ) { connect ( field , & v , TypeTraits :: make < T > ( ) ) ; } /** Connect a vector of tensors to a vertex field.\n   *\n   * This function connects an vector a tensors with a vertex field.\n   * The field must be a vector of inputs or outputs.\n   * The field will be sized to the provided vector and each element will\n   * be connect to the corresponding element of the field.\n   *\n   * \\param tensors        The vector of tensors.\n   * \\param field          Reference to the vertex field to connect.\n   */ void connect ( FieldRef field , ArrayRef < Tensor > tensors ) { setFieldSize ( field , tensors . size ( ) ) ; for ( unsigned i = 0 ; i < tensors . size ( ) ; ++ i ) { connect ( field [ i ] , tensors [ i ] ) ; } } /** Set the cycle estimate for a vertex.\n   *\n   *  \\param v       The vertex to set the estimate for.\n   *  \\param cycles  The number of cycles that this vertex will use when run.\n   */ void setCycleEstimate ( const VertexRef & v , std :: uint64_t cycles ) ; /** Get the cycle estimate for the specified vertex.\n   *\n   *  \\param v The vertex to get the estimate for.\n   *  \\return The number of cycles used when this vertex is run.\n   *  \\throws missing_cycle_estimate if the cycle estimate is not available\n   *          (for example, because the graph hasn't been executed yet).\n   */ std :: uint64_t getCycleEstimate ( const VertexRef & v ) const ; /**\n   * \\param vertexTypeName Type of vertex to register the estimator for.\n   * \\param f Callback function that will compute a cycles estimate for\n   *          all vertices of this type.\n   */ void registerCycleEstimator ( StringRef vertexTypeName , CycleEstimateFunc f ) ; /**\n   * Get the number of vertices currently in the graph.\n   *\n   * \\returns The numbers of vertices currently in the graph.\n   */ unsigned getNumVertices ( void ) const ; /** Create a compute set within the graph.\n   *\n   *  \\param name   An optional identifier for the compute set that may\n   *                be used during profiling/debugging.\n   *  \\returns      The reference to the compute set.\n   */ ComputeSet addComputeSet ( const DebugContext & debugContext = { } ) ; /** Set the size of a vector field.\n   *\n   *  \\param field       The reference to the field.\n   *  \\param size        The size of the field.\n   */ void setFieldSize ( FieldRef field , std :: size_t size ) ; /** Get the size of a vector field.\n   *\n   *  \\param field       The reference to the field.\n   *  \\returns           The size of the field.\n   */ std :: size_t getFieldSize ( FieldRef field ) const ; /** Find the maximum size for a dimension of a field\n   *\n   *  \\param  vertexType   The type of vertex\n   *  \\param  field        The field\n   *  \\param  dimIndex     The index of the dimension\n   *  \\throws index_error  If there is no such dimension\n   *  \\throws poplar_error If the field is not indexable\n   */ std :: size_t getMaxFieldDim ( StringRef vertexName , StringRef fieldName , unsigned dimIndex ) const ; /** Find the maximum value that can be represented by an element of a field\n   * \\param vertexType  The type of vertex\n   * \\param field       The field\n   */ double getMaxVertexFieldValue ( StringRef vertexName , StringRef fieldName ) const ; /** Set the initial value of a field.\n   *\n   *  \\param field       The reference to the field.\n   *  \\param val         The value to set the field to when the graph\n   *                     engine is created.\n   */ template < typename T > void setInitialValue ( FieldRef field , T val , typename std :: enable_if < TypeTraits :: isSimpleType < T > ( ) > :: type * = nullptr ) { setInitialValue ( field , reinterpret_cast < const void * > ( & val ) , TypeTraits :: make < T > ( ) ) ; } /** Set the init callback for a field; the callback function will be called\n   *  after graph construction and must return the init value of the field.\n   *\n   *  This can be called *instead* of calling setInitialValue(), or both\n   *  can be called for the field, to ensure that the field has a (at least\n   *  partially) valid starting value, for instance it if needs to be\n   *  retrieved in an early stage of graph compilation, before storage\n   *  allocation (for instance during cycle estimation)\n   *\n   *  Note that you must explicitly provide the template parameter T in the\n   *  specialisation, when using this function, e.g.:\n   *    setInitCallback<uint16_t>(vertex[\"size\"], sizeCallback)\n   *  because the compiler will not be able to detect the correct type from\n   *  the callback parameter.\n   *\n   *  \\param field     The reference to the field.\n   *  \\param callback  The callback that will return the value for the field.\n   *  \\param <unnamed> This exists only to allow to insert the\n   *                   'is_arithmetic<T>' check for the type T.\n   */ template < typename T > void setInitCallback ( FieldRef field , LateInitCallback < T > callback , typename std :: enable_if < std :: is_arithmetic < T > :: value > :: type * = nullptr ) { setInitCallback < T > ( field , callback , TypeTraits :: make < T > ( ) ) ; } // Work arounds for template overload resolution limitations: // explicitly convert to ArrayRef ourselves: template < typename T > void setInitialValue ( FieldRef field , const std :: vector < T > & v ) { setInitialValue ( field , ArrayRef < T > ( v ) ) ; } template < typename T > void setInitialValue ( FieldRef field , const std :: initializer_list < T > & l ) { setInitialValue ( field , ArrayRef < T > ( l ) ) ; } /** Set the initial value of a field of type IEEE half.\n   *\n   *  \\param field       The reference to the field.\n   *  \\param val         The value to set the field to when the graph\n   *                     engine is created.\n   */ void setInitialValueHalf ( FieldRef field , uint16_t val ) { setInitialValue ( field , reinterpret_cast < const void * > ( & val ) , TypeTraits :: make < IeeeHalf > ( ) ) ; } /** Set initial values of a vector field.\n   *\n   *  \\param field       The reference to the vector field.\n   *  \\param val         A vector value to set the field to when the graph\n   *                     engine is created.\n   */ template < typename T > void setInitialValue ( FieldRef field , ArrayRef < T > val ) { setFieldSize ( field , val . size ( ) ) ; for ( unsigned i = 0 ; i < val . size ( ) ; ++ i ) { setInitialValue < T > ( field [ i ] , val [ i ] ) ; } } /** Set initial values of a vector field of type IEEE half.\n   *\n   *  \\param field       The reference to the vector field.\n   *  \\param val         A vector value to set the field to when the graph\n   *                     engine is created.\n   */ void setInitialValueHalf ( FieldRef field , ArrayRef < uint16_t > val ) { setFieldSize ( field , val . size ( ) ) ; for ( unsigned i = 0 ; i < val . size ( ) ; ++ i ) { setInitialValueHalf ( field [ i ] , val [ i ] ) ; } } /** Set the initial value of a tensor element.\n   *\n   *  \\param t           The tensor representing the value to set.\n   *  \\param val         The value to set the field to when the graph\n   *                     engine is created. A buffer of values can be\n   *                     provided to set the elements of a non-scalar\n   *                     tensor.\n   */ template < typename T > void setInitialValue ( const Tensor & t , T val , typename std :: enable_if < TypeTraits :: isSimpleType < T > ( ) > :: type * = nullptr ) { setInitialValue ( t , reinterpret_cast < const void * > ( & val ) , TypeTraits :: make < T > ( ) ) ; } template < typename T > void setInitialValue ( const Tensor & t , ArrayRef < T > values ) { Tensor f = t . flatten ( ) ; if ( f . numElements ( ) != values . size ( ) ) { throw poplar_error ( \"The number of values (\" + std :: to_string ( values . size ( ) ) + \") does not match \" \"the number of Tensor elements (\" + std :: to_string ( f . numElements ( ) ) + \")\" ) ; } for ( std :: size_t e = 0 ; e < f . numElements ( ) ; ++ e ) { setInitialValue ( f [ e ] , reinterpret_cast < const void * > ( & values [ e ] ) , TypeTraits :: make < T > ( ) ) ; } } /** Set the initial value of a tensor element of type IEEE half.\n   *\n   *  \\param t           The tensor representing the value to set.\n   *  \\param val         The value to set the field to when the graph\n   *                     engine is created. A buffer of values can be\n   *                     provided to set the elements of a non-scalar\n   *                     tensor.\n   */ void setInitialValueHalf ( const Tensor & t , uint16_t val ) { setInitialValue ( t , reinterpret_cast < const void * > ( & val ) , TypeTraits :: make < IeeeHalf > ( ) ) ; } void setInitialValueHalf ( const Tensor & t , ArrayRef < uint16_t > values ) { Tensor f = t . flatten ( ) ; if ( f . numElements ( ) != values . size ( ) ) { throw poplar_error ( \"The number of values (\" + std :: to_string ( values . size ( ) ) + \") does not match \" \"the number of Tensor elements (\" + std :: to_string ( f . numElements ( ) ) + \")\" ) ; } for ( std :: size_t e = 0 ; e < f . numElements ( ) ; ++ e ) { setInitialValue ( f [ e ] , reinterpret_cast < const void * > ( & values [ e ] ) , TypeTraits :: make < IeeeHalf > ( ) ) ; } } /** Mark a Tensor as being available as the destination of host\n   * to device copies. This is a convenience function that creates a\n   * host-to-device FIFO, and a Copy program that copies data from the FIFO\n   * to the tensor. When you call Engine::writeTensor() it copies the\n   * input data to the FIFO and then executes the Copy program on the device.\n   *\n   *  \\sa Engine::writeTensor()\n   *\n   * \\param handle A name to be associated with this host copy.\n   * \\param t The tensor to be marked as an input.\n   * \\param rearrangeOnHost Save IPU memory at the cost of exchange speed by\n   *                        rearranging the data on the host before sending\n   *                        it to the IPU, rather than doing an internal\n   *                        exchange. Note that due to alignment and size\n   *                        requirements of host exchange packets this may\n   *                        still require part of the transfer to be received\n   *                        to a temporary variable and copied to its\n   *                        destination.\n   */ void createHostWrite ( StringRef handle , const Tensor & t , bool rearrangeOnHost = false ) ; /** Mark a Tensor as being available as the source of device\n   *  to host copies. This is a convenience function that creates a\n   * device-to-host FIFO, and a Copy program that copies data to the FIFO\n   * from the tensor. When you call Engine::writeTensor() it executes the\n   * Copy program on the device and then outputs the data from the FIFO.\n   *\n   *  \\sa Engine::readTensor()\n   *\n   * \\param handle A name to be associated with this host copy.\n   * \\param t The tensor to be marked as an output.\n   * \\param rearrangeOnHost Save IPU memory at the cost of exchange speed by\n   *                        sending data in any order and rearranging it on\n   *                        the host, rather than doing an internal\n   *                        exchange before sending it.\n   */ void createHostRead ( StringRef handle , const Tensor & t , bool rearrangeOnHost = false ) ; /** Add a data stream to the graph for copying data from the host\n   *  to the device.\n   *\n   *  \\param handle         A name to be associated with this stream\n   *  \\param elementType    The type of data in the stream\n   *  \\param numElements    The number of elements to be transferred from the\n   *                        stream by a Copy program.\n   *  \\param replicatedMode How the stream is replicated if this is a\n   *                        replicated graph.\n   *  \\param options        List of options\n   *   Supported options:\n   *    * `splitLimit` Integer [=50 * 1024 * 1024]\n   *\n   *    The maximum size of the FIFO before being split into multiple FIFOs.\n   *    This is a useful option to avoid exceeding the stream buffer size limit.\n   *    If the original FIFO is larger than the specified split limit, then it\n   *    is replaced by a number of FIFOs which represent chunks of the original\n   *    FIFO, and are read from sequentially. Setting `splitLimit` to 0 or\n   *    UINT_MAX disables this option.\n   *\n   *    * `bufferingDepth` Integer [=1]\n   *\n   *    The depth of the FIFO which may be prefetched before being read by the\n   *    device. By default the FIFO size is 1, so prefetches a single entry\n   *    after it has been read to refill the FIFO. Increasing the size of the\n   *    FIFO allows for prefetching of multiple entries, increasing the\n   *    probability there will be a valid entry in the FIFO for the device to\n   *    read before falling back to synchronously fetching the next entry.\n   */ DataStream addHostToDeviceFIFO ( StringRef handle , const Type & elementType , std :: size_t numElements , ReplicatedStreamMode replicatedMode = ReplicatedStreamMode :: REPLICATE , const OptionFlags & options = { } ) ; /** Add a data stream to the graph for copying data from the device\n   *  to the host.\n   *\n   *  \\param handle       A name to be associated with this stream\n   *  \\param elementType  The type of data in the stream\n   *  \\param numElements  The number of elements to be transferred to the\n   *                      stream by a Copy program.\n   *  \\param options      List of options\n   *   Supported options:\n   *    * `splitLimit` Integer [=50 * 1024 * 1024]\n   *\n   *    The maximum size of the FIFO before being split into multiple FIFOs.\n   *    This is a useful option to avoid exceeding the stream buffer size limit.\n   *    If the original FIFO is larger than the specified split limit, then it\n   *    is replaced by a number of FIFOs which represent chunks of the original\n   *    FIFO, and are read from sequentially. Setting `splitLimit` to 0 or\n   *    UINT_MAX disables this option.\n   */ DataStream addDeviceToHostFIFO ( StringRef handle , const Type & elementType , std :: size_t numElements , const OptionFlags & options = { } ) ; /** Add a remote buffer to the graph. A remote buffer is memory outside\n   *  the IPU which can be read and written by the IPU. A read returns the\n   *  last written value. The remote buffer is (\\p repeats * \\p numElements *\n   *  sizeof(\\p elementType) + padding) bytes in size. Padding is added to meet\n   *  any alignment constraints of the hardware.\n   *\n   *  \\param handle          A name to be associated with this remote buffer.\n   *  \\param elementType     The type of data in the remote buffer.\n   *  \\param numElements     The number of elements to be transferred to the\n   *                         remote buffer by a Copy program.\n   *  \\param repeats         The buffer can store multiple blocks of data to\n   *                         be transferred. The total number of data elements\n   *                         in the buffer is \\p numElements * \\p repeats.\n   *  \\param rearrangeOnHost Perform any necessary data rearrangement on the\n   *                         on the host instead of on the IPU.\n   *  \\param optimiseMemory  Optimise for memory use rather than speed.\n   */ RemoteBuffer addRemoteBuffer ( StringRef handle , const Type & elementType , std :: size_t numElements , std :: size_t repeats = 1 , bool rearrangeOnHost = false , bool optimiseMemory = false ) ; /** Output to a stream the vertex graph in dot file format.\n   *\n   *  \\param outputStream The C++ stream to output the dot file onto.\n   */ void outputVertexGraph ( std :: ostream & outputStream , ArrayRef < program :: Program > progs = { } ) const ; /** Output to a stream the compute graph in dot file format.\n   *\n   *  \\param outputStream The C++ stream to output the dot file onto.\n   */ void outputComputeGraph ( std :: ostream & outputStream , ArrayRef < program :: Program > progs = { } ) const ; /** Map a vertex to a specific tile on the device.\n   *\n   * \\param v Reference to the vertex to map\n   * \\param tileNum The tile number to map the vertex to.\n   */ void setTileMapping ( VertexRef v , unsigned tileNum ) ; /** Map a tensor slice to a specific tile on the device.\n   *\n   * \\param t The tensor or tensor slice to map.\n   * \\param tileNum The tile number to map to.\n   */ void setTileMapping ( const Tensor & t , unsigned tileNum ) ; using TileToTensorMapping = std :: vector < std :: vector < Interval >> ; /** Inspect the tile mapping of a tensor.\n   *\n   * \\param t             The tensor to inspect\n   * \\param requireComplete  If \\p t is not fully mapped and\n   *                         \\p requireComplete is true then an\n   *                         invalid_tile_mapping exception will be thrown.\n   * \\returns The mapping from tiles to a vector of intervals mapped to the\n   *          tile (implemented as vector indexed by the tile number).\n   *          The lower and upper bound of each\n   *          interval are elements number in the flattened tensor.\n   */ TileToTensorMapping getTileMapping ( const Tensor & t , bool requireComplete = true ) const ; /** Inspect the tile mapping of a tensor.\n   *\n   * \\param t             The tensor to inspect\n   * \\param isComplete    If non-null, updated to indicate whether the\n   *                      mapping is complete.\n   * \\returns The mapping from tiles to a vector of intervals mapped to the\n   *          tile (implemented as vector indexed by the tile number).\n   *          The lower and upper bound of each\n   *          interval are elements number in the flattened tensor.\n   */ TileToTensorMapping getTileMapping ( const Tensor & t , bool * isComplete ) const ; /** Inspect the tile mapping of a tensor. This excludes any constant regions.\n   *\n   * \\param t The tensor to inspect\n   * \\returns The mapping from tiles to a vector of intervals mapped to the\n   *          tile (implemented as vector indexed by the tile number).\n   *          The lower and upper bound of each\n   *          interval are elements number in the flattened tensor.\n   */ TileToTensorMapping getVariableTileMapping ( const Tensor & t ) const ; /** Set the tile mapping of a tensor based on an explicit map from tiles\n   *  to tensor intervals.\n   *\n   * \\param t The tensor to map\n   * \\param mapping The mapping from tiles to a vector of intervals to be\n   *                placed on that tile (implemented as vector indexed by\n   *                the tile number). The lower and upper bound of each\n   *                interval are elements number in the flattened tensor.\n   */ void setTileMapping ( const Tensor & t , const TileToTensorMapping & mapping ) ; /** Get a tensor representing an entire variable.\n   *\n   *  \\param v The variable to retrieve.\n   *  \\returns A Tensor object representing that variable.\n   */ Tensor getVariable ( VariableRef v ) const ; /** Check whether a variable reference refers represents a constant.\n   *\n   *  When Graph::addConstant() is called a variable is created to\n   *  represent that constant. This call checks whether a variable was\n   *  created by that method or by Graph::addVariable().\n   *\n   *  \\param v The variable to examine.\n   *  \\returns True if and only if the variable refers to a constant.\n   */ bool isConstant ( VariableRef v ) const ; /** Get a list of sequences of intervals over a tensor such that each\n   *  sequence represents a contiguous region of memory.\n   *\n   *  \\param t                      The tensor to get intervals over.\n   *  \\param regions                A list of intervals representing the\n   *                                elements to sort into memory contiguous\n   *                                sequences.\n   *  \\param removeAliasedIntervals If true, remove intervals which alias\n   *                                others in the given regions from the\n   *                                result.\n   *  \\param aliases                Optional list of indices for each region\n   *                                in the returned intervals where an\n   *                                index is always the same for a region\n   *                                representing the same underlying elements\n   *                                in memory. If this is nullptr, then\n   *                                no aliases will be returned.\n   *\n   *  \\returns A list of sequences of intervals. The intervals will cover the\n   *           same elements of the tensor as provided as input.\n   */ std :: vector < std :: vector < Interval >> getSortedContiguousRegions ( const Tensor & t , ArrayRef < Interval > regions , bool removeAliasedIntervals = false , std :: vector < std :: size_t > * aliases = nullptr ) const ; /** Reorder a set of tensors in order to simplify the view on\n   *  data.\n   *\n   *  This function will update 't' to be a (simpler) reordered view on the\n   *  same data. The same reordering will be applied to all elements of 'ts'.\n   *  The reordering will be the same for all tensors so\n   *  order-invariant or element-wise operations on 't' and 'ts' can still be\n   *  performed.\n   *\n   *  The main purpose of this function is to provide a way to implement more\n   *  efficient graph construction of element-wise or order-invariant\n   *  operations.\n   *\n   *  If 'requireSimplestOrder' is set to true then after execution\n   *  t will consist of the minimum number of possible\n   *  contiguous regions. If not, then no guarantee is give on\n   *  the order of t.\n   *\n   *  All the tensors provided to this function must be of rank 1 (i.e\n   *  flattened tensors) and have the same number of elements.\n   */ void reorderToSimplify ( Tensor * t , ArrayRef < Tensor * > ts , bool requireSimplestOrder = true ) const ; /** Attempt to determine the shape of a Tensor prior to it having been\n   *  broadcast.  Under some circumstances this may not be possible, failure\n   *  is indicated by the returned tensor having the same shape as the\n   *  input tensor\n   *\n   *  \\param t  The input tensor\n   *\n   * \\returns   A tensor which will be set to the unbroadcast (sliced from 't')\n   *            tensor if it is possible to do so. Each dimension of the\n   *            returned tensor will be a factor of the same dimension of the\n   *            input tensor.  The returned tensor will have the same rank as\n   *            the input tensor.\n   *            If it is not possible to determine the shape of the unbroadcast\n   *            tensor the input tensor will be returned.\n   */ Tensor findUnbroadcastTensor ( const Tensor & t ) const ; /** Serialize a set of tensors to JSON or CapnProto. The tensors must\n   * all be from this graph or an exception is thrown. The information\n   * saved is:\n   *\n   * - The type, shape and expression of the tensors.\n   * - The type and number of elements of any variables used.\n   *\n   * This is intended to be used for debugging, testing and visualisation.\n   *\n   * \\param out      Stream to write to.\n   * \\param tensors  A set of tensors to serialize.\n   * \\param format   Serialize in JSON or CapnProto format. JSON is pretty\n   *                 printed.\n   *\n   * \\throws poplar_error if any tensor is not from this graph. CapnProto\n   *         may also throw an exception if serialization fails.\n   */ void serializeTensors ( std :: ostream & out , ArrayRef < Tensor > tensors , SerializationFormat format ) const ; /** Deserialize a set of tensors from a CapnProto message.\n   * JSON deserialization is not currently supported and an exception will\n   * be thrown if format is SerializationFormat::JSON.\n   *\n   * This will recreate the tensors in this graph. It throws an exception\n   * on failure (for example, if the tensor type does not match the variable\n   * types).\n   * Whenever a variable is used by a tensor a new variable is added to\n   * the graph.\n   *\n   * The layout of the tensors and variables should be the same as when they\n   * were serialized.\n   *\n   * This function is primarily intended for testing and benchmarks. You\n   * should not use it as a general method of creating tensors.\n   *\n   * \\param in      A stream from which serialised tensor data can be\n   *                read.\n   * \\param format  Must be SerializationFormat::Binary\n   *\n   * \\returns The deserialized set of tensors.\n   */ std :: vector < Tensor > deserializeTensors ( std :: istream & in , SerializationFormat format ) ; /** Create a \"virtual\" graph working over a subset of the target's tile.\n   *\n   *  This method returns a graph object that references the same state as\n   *  this graph but has a virtual target than only uses a subset of the\n   *  target's tiles.\n   *\n   *  If the getTarget() method is called on the new graph it will return\n   *  a target with the new number of tiles.\n   *\n   *  \\param   numTilesPerIPU The number of tiles per IPU\n   *                          for the new graph to work over.\n   *  \\returns The virtual graph object\n   */ Graph createVirtualGraph ( unsigned numTilesPerIPU ) ; /** Create a \"virtual\" graph working over a subset of the target's tiles.\n   *\n   *  This method returns a graph object that references the same state as\n   *  this graph but has a virtual target than only uses a subset of the\n   *  target's tiles.\n   *\n   *  This variant of the method takes a tile range for the new virtual graph\n   *  to work over. This is the range [lowerTile:upperTile).\n   *  This tile range must be contained within a single IPU.\n   *\n   *  If the getTarget() method is called on the new graph it will return\n   *  a target with the new number of tiles.\n   *\n   *  \\param   lowerTile The starting tile of the tile range for the\n   *                     virtual graph to work over.\n   *  \\param   upperTile The upper bound of the tile range for the virtual\n   *                     graph to work over. This is a non-inclusive\n   *                     upper bound.\n   *  \\returns The virtual graph object\n   */ Graph createVirtualGraph ( unsigned lowerTile , unsigned upperTile ) ; /** Create a \"virtual\" graph working over a subset of the target's tiles.\n   *\n   *  This method returns a graph object that references the same state as\n   *  this graph but has a virtual target than only uses a subset of the\n   *  target's tiles.\n   *\n   *  This variant of the method takes the set of tiles in each IPU that\n   *  should be included in the new graph.\n   *\n   *  If the getTarget() method is called on the new graph it will return\n   *  a target with the new number of tiles.\n   *\n   *  \\param   perIpuTiles The tiles to include in the graph. Tiles are\n   *                       specified by their index in the IPU. Each tile\n   *                       index must be unique and less than the number of\n   *                       tiles per IPU.\n   *  \\returns The virtual graph object\n   */ Graph createVirtualGraph ( const std :: vector < unsigned > & perIpuTiles ) ; /**\n   * Create a replicated graph.\n   *\n   * The replicated graph is a view on \\p replicationFactor virtual subgraphs.\n   * Operations on the replicated graph are implicitly applied to each virtual\n   * subgraph, for example adding a variable to the replicated graph\n   * implicitly creates a variable in all of the underlying subgraphs.\n   *\n   * The replication factor must divide the number of tiles in the graph. If\n   * \\a n is the number of tiles in this graph the first subgraph contains\n   * tiles [0, \\a n / replicationFactor), the second subgraph contains tiles\n   * [\\a n / replicationFactor, 2\\a n / replicationFactor) and so on.\n   */ Graph createReplicatedGraph ( unsigned replicationFactor ) ; /**\n   * Return the top level graph. The createVirtualGraph() and\n   * createReplicatedGraph() methods can be used to create graph objects that\n   * are views on an underlying graph. If this is a virtual or replicated\n   * graph then this function returns the top level underlying graph,\n   * otherwise it returns the current graph.\n   */ Graph getTopLevelGraph ( ) ; /**\n   * Return the replication factor of the graph.\n   */ unsigned getReplicationFactor ( ) const ; /**\n   * Add a constant that is initialized with the replication index.\n   */ Tensor addReplicationIndexConstant ( ) ; /**\n   * Given a replicated tensor return the underlying tensors in this graph\n   * that the replicated tensor is a placeholder for.\n   *\n   * The tensor returned by\n   * this function has an extra outer dimension equal to the replication\n   * factor of the tensor in this graph and it is formed by concatenating the\n   * underlying tensors for each replicated subgraph in this dimension.\n   *\n   * This function can only be used with replicated graphs created by\n   * the createReplicatedGraph function, not when the Graph is constructed.\n   */ Tensor getNonReplicatedTensor ( const Tensor & t ) const ; /** Serialize a graph to JSON or binary (CapnProto) format. This is equivalent\n   * to serialize(out, {}, format).\n   *\n   * Note that this does not currently serialize every bit of graph data, so\n   * it cannot be used to save and reload a graph.\n   *\n   * \\param out      Stream to write to.\n   * \\param format   Serialize in JSON or CapnProto format. JSON is pretty\n   *                 printed.\n   */ void serialize ( std :: ostream & out , SerializationFormat format ) const ; /** Serialize a graph to JSON or binary (CapnProto) format.\n   * Progs can be passed so that information about Copy programs can be\n   * serialized (the Graph class itself does not know about them).\n   *\n   * Note that this does not currently serialize every bit of graph data, so\n   * it cannot be used to save and reload a graph.\n   *\n   * \\param out      Stream to write to.\n   * \\param progs    A set of programs that are searched for Copy programs.\n   *                 Information about the variables copied is serialised.\n   * \\param format   Serialize in JSON or CapnProto format. JSON is pretty\n   *                 printed.\n   */ void serialize ( std :: ostream & out , ArrayRef < program :: Program > progs , SerializationFormat format ) const ; /** Add a function to the graph.\n   *\n   *  A function is a partial control program that can be reused.\n   *  By registering a repeated program as a function and calling it,\n   *  less control code is generated than repeating the sequence.\n   *\n   *  \\param program    The control program to register as a callable\n   *                    function\n   *  \\returns          The Function object that can be used by a Call\n   *                    program.\n   */ Function addFunction ( const program :: Program & program ) ; /** Convert Virtual Tile ID into Physical Tile ID\n   *\n   *  A function provides conversion interface required by the Graphcore\n   *  communication library to know\n   *  what exchange block context a tile is associated with.\n   *\n   *  \\param  Virtual Tile ID\n   *  \\return Physical Tile ID\n   */ unsigned convertVirtualTileToPhysicalTile ( unsigned virtualTileId ) const ; /** Convert Physical Tile ID to Virtual Tile ID\n   *\n   *  This function provides a conversion interface required by the Graphcore\n   *  communication library to know\n   *  what exchange block context a tile is associated with.\n   *\n   *  \\param  Physical Tile ID\n   *  \\return Virtual Tile ID\n   */ unsigned convertPhysicalTileToVirtualTile ( unsigned physicalTileId ) const ; /** Convert Physical Tile ID to Virtual Tile ID.\n   *\n   *  A function returns Virtual Tile ID based on a parameters pair of IPU and\n   *  and Physical Tile ID. This conversion interface is required by the\n   *  Graphcore communication library to know\n   *  what exchange block context a tile is associated with.\n   *\n   *  \\param  IPU ID\n   *  \\param  Physical Tile ID\n   *  \\return Virtual Tile ID\n   */ unsigned convertPhysicalTileToVirtualTile ( unsigned ipuId , unsigned physicalTileId ) const ; /** Check if graph contains codelet of this name\n   *\n   * \\param string codelet name\n   * \\return bool is codelet is in graph\n   */ bool hasCodelet ( StringRef codeletName ) const ; // Implementation Graph ( std :: unique_ptr < core :: GraphBuilder > , Target target ) ; core :: GraphBuilder & getImpl ( ) const { return * impl ; } private : std :: unique_ptr < core :: GraphBuilder > impl ; Target target ; void setInitialValue ( FieldRef field , const void * val , const TypeTraits & ) ; template < typename T > void setInitCallback ( FieldRef field , LateInitCallback < T > callback , const TypeTraits & ) ; void setInitialValue ( const Tensor & t , const void * val , const TypeTraits & ) ; void connect ( FieldRef field , void * val , const TypeTraits & ) ; void checkFieldSubgraph ( const FieldRef & f ) const ; void checkVertexSubgraph ( const VertexRef & v ) const ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::Graph(const poplar::Target &, poplar::replication_factor)","Filename":"poplar/Graph.hpp","Text":"Graph ( const Target & target , replication_factor r = replication_factor ( 1 ) )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::Graph(const poplar::Device &, poplar::replication_factor)","Filename":"poplar/Graph.hpp","Text":"Graph ( const Device & device , replication_factor r = replication_factor ( 1 ) )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::Graph(poplar::Graph &&)","Filename":"poplar/Graph.hpp","Text":"Graph ( Graph && )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::operator=(poplar::Graph &&)","Filename":"poplar/Graph.hpp","Text":"Graph & operator = ( Graph && )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::getTarget()","Filename":"poplar/Graph.hpp","Text":"const Target & getTarget ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::addCodelets(poplar::StringRef, poplar::CodeletFileType, poplar::StringRef)","Filename":"poplar/Graph.hpp","Text":"bool addCodelets ( StringRef src , CodeletFileType type = CodeletFileType :: Auto , StringRef compileFlags = \"\" )"}
{"Token type":"CXXMethod","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::addCodelets(poplar::StringRef, poplar::CodeletFileType, poplar::StringRef, std::ostream &)","Filename":"poplar/Graph.hpp","Text":"bool addCodelets ( StringRef src , CodeletFileType type , StringRef compileFlags , std :: ostream & compileOutput )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::addCodelets(ArrayRef<std::string>, poplar::StringRef)","Filename":"poplar/Graph.hpp","Text":"bool addCodelets ( ArrayRef < std :: string > xs , StringRef compileFlags = \"\" )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::addCodelets(std::stringstream &, poplar::StringRef)","Filename":"poplar/Graph.hpp","Text":"void addCodelets ( std :: stringstream & stream , StringRef compileFlags = \"\" )"}
{"Token type":"CXXMethod","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::addCodelets(std::stringstream &, poplar::StringRef, std::ostream &)","Filename":"poplar/Graph.hpp","Text":"void addCodelets ( std :: stringstream & stream , StringRef compileFlags , std :: ostream & compileOutput )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::ConnectionDesc","Filename":"poplar/Graph.hpp","Text":"class ConnectionDesc { enum class Kind { TensorEdge , ValueEdge , VectorTensorEdge } ; Kind kind ; std :: string field ; std :: vector < Tensor > ts ; std :: unique_ptr < char [ ] > val ; TypeTraits traits ; void connect ( Graph & g , const VertexRef & v ) const { switch ( kind ) { case Kind :: TensorEdge : g . connect ( v [ field ] , ts [ 0 ] ) ; break ; case Kind :: ValueEdge : g . connect ( v [ field ] , val . get ( ) , traits ) ; break ; case Kind :: VectorTensorEdge : g . connect ( v [ field ] , ts ) ; } } public : ConnectionDesc ( StringRef field , Tensor t ) : kind ( Kind :: TensorEdge ) , field ( field . begin ( ) , field . end ( ) ) , ts ( { std :: move ( t ) } ) { } ConnectionDesc ( StringRef field , ArrayRef < Tensor > tsArr ) : kind ( Kind :: VectorTensorEdge ) , field ( field . begin ( ) , field . end ( ) ) , ts ( tsArr . begin ( ) , tsArr . end ( ) ) { } template < typename T > ConnectionDesc ( StringRef field , T v , typename std :: enable_if < TypeTraits :: isSimpleType < T > ( ) > :: type * = nullptr ) : kind ( Kind :: ValueEdge ) , field ( field . begin ( ) , field . end ( ) ) , traits ( TypeTraits :: make < T > ( ) ) { val . reset ( new char [ traits . size ] ) ; std :: memcpy ( & val [ 0 ] , & v , traits . size ) ; } friend class Graph ; }"}
{"Token type":"EnumDecl","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::ConnectionDesc::Kind","Filename":"poplar/Graph.hpp","Text":"enum class Kind { TensorEdge , ValueEdge , VectorTensorEdge }"}
{"Token type":"EnumConstantDecl","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::ConnectionDesc::Kind::TensorEdge","Filename":"poplar/Graph.hpp","Text":"TensorEdge"}
{"Token type":"EnumConstantDecl","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::ConnectionDesc::Kind::ValueEdge","Filename":"poplar/Graph.hpp","Text":"ValueEdge"}
{"Token type":"EnumConstantDecl","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::ConnectionDesc::Kind::VectorTensorEdge","Filename":"poplar/Graph.hpp","Text":"VectorTensorEdge"}
{"Token type":"CXXMethod","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::ConnectionDesc::connect(poplar::Graph &, const poplar::VertexRef &)","Filename":"poplar/Graph.hpp","Text":"void connect ( Graph & g , const VertexRef & v ) const"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::ConnectionDesc::ConnectionDesc(poplar::StringRef, poplar::Tensor)","Filename":"poplar/Graph.hpp","Text":"ConnectionDesc ( StringRef field , Tensor t )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::ConnectionDesc::ConnectionDesc(poplar::StringRef, ArrayRef<poplar::Tensor>)","Filename":"poplar/Graph.hpp","Text":"ConnectionDesc ( StringRef field , ArrayRef < Tensor > tsArr )"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::ConnectionDesc::ConnectionDesc(poplar::StringRef, T, typename std::enable_if<TypeTraits::isSimpleType<T>()>::type *)","Filename":"poplar/Graph.hpp","Text":"template < typename T > ConnectionDesc ( StringRef field , T v , typename std :: enable_if < TypeTraits :: isSimpleType < T > ( ) > :: type * = nullptr )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::addVertex(poplar::ComputeSet, poplar::StringRef)","Filename":"poplar/Graph.hpp","Text":"VertexRef addVertex ( ComputeSet cs , StringRef vertexType )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::addVertex(poplar::ComputeSet, poplar::StringRef, ArrayRef<poplar::Graph::ConnectionDesc>)","Filename":"poplar/Graph.hpp","Text":"VertexRef addVertex ( ComputeSet cs , StringRef vertexType , ArrayRef < ConnectionDesc > connections )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::addExternalExchangeVertex(poplar::ComputeSet, poplar::StringRef, unsigned int, bool, bool)","Filename":"poplar/Graph.hpp","Text":"VertexRef addExternalExchangeVertex ( ComputeSet cs , StringRef vertexType , unsigned incomingDownCount , bool usesEastEdge , bool sendsXReq )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::addVariable(const poplar::Type &, ArrayRef<std::size_t>, const poplar::DebugContext &)","Filename":"poplar/Graph.hpp","Text":"Tensor addVariable ( const Type & type , ArrayRef < std :: size_t > shape , const DebugContext & debugContext = { } )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::addVariable(const poplar::Type &, ArrayRef<std::size_t>, poplar::VariableMappingMethod, const poplar::DebugContext &)","Filename":"poplar/Graph.hpp","Text":"Tensor addVariable ( const Type & type , ArrayRef < std :: size_t > shape , VariableMappingMethod mappingMethod , const DebugContext & debugContext = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::addConstant(const poplar::Type &, ArrayRef<std::size_t>, ArrayRef<T>, const poplar::DebugContext &)","Filename":"poplar/Graph.hpp","Text":"template < typename T > Tensor addConstant ( const Type & type , ArrayRef < std :: size_t > shape , ArrayRef < T > values , const DebugContext & debugContext = { \"<const>\" } )"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::addConstant(const poplar::Type &, ArrayRef<std::size_t>, T, const poplar::DebugContext &, typename std::enable_if<TypeTraits::isSimpleType<T>()>::type *)","Filename":"poplar/Graph.hpp","Text":"template < typename T > Tensor addConstant ( const Type & type , ArrayRef < std :: size_t > shape , T val , const DebugContext & debugContext = { \"<const>\" } , typename std :: enable_if < TypeTraits :: isSimpleType < T > ( ) > :: type * = nullptr )"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::addConstant(const poplar::Type &, ArrayRef<std::size_t>, const T *, const poplar::DebugContext &, typename std::enable_if<TypeTraits::isSimpleType<T>()>::type *)","Filename":"poplar/Graph.hpp","Text":"template < typename T > Tensor addConstant ( const Type & type , ArrayRef < std :: size_t > shape , const T * val , const DebugContext & debugContext = { \"<const>\" } , typename std :: enable_if < TypeTraits :: isSimpleType < T > ( ) > :: type * = nullptr )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::addConstant(const poplar::Type &, ArrayRef<std::size_t>, const void *, const poplar::TypeTraits &, bool, const poplar::DebugContext &)","Filename":"poplar/Graph.hpp","Text":"Tensor addConstant ( const Type & type , ArrayRef < std :: size_t > shape , const void * val , const TypeTraits & traits , bool broadcast , const DebugContext & debugContext = { \"<const>\" } )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::addConstantHalf(const poplar::Type &, ArrayRef<std::size_t>, uint16_t, const poplar::DebugContext &)","Filename":"poplar/Graph.hpp","Text":"Tensor addConstantHalf ( const Type & type , ArrayRef < std :: size_t > shape , uint16_t val , const DebugContext & debugContext = { \"<const>\" } )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::addConstantHalf(const poplar::Type &, ArrayRef<std::size_t>, const uint16_t *, const poplar::DebugContext &)","Filename":"poplar/Graph.hpp","Text":"Tensor addConstantHalf ( const Type & type , ArrayRef < std :: size_t > shape , const uint16_t * val , const DebugContext & debugContext = { \"<const>\" } )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::clone(const poplar::Type &, const poplar::Tensor &, const poplar::DebugContext &, poplar::TensorCloneMethod)","Filename":"poplar/Graph.hpp","Text":"Tensor clone ( const Type & type , const Tensor & t , const DebugContext & debugContext = { } , TensorCloneMethod method = TensorCloneMethod :: PRESERVE_ORDER_UNLESS_ALIASES )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::cloneN(const poplar::Type &, const poplar::Tensor &, std::size_t, const poplar::DebugContext &, poplar::TensorCloneMethod, poplar::TensorCloneDuplicationMethod)","Filename":"poplar/Graph.hpp","Text":"Tensor cloneN ( const Type & type , const Tensor & t , std :: size_t N , const DebugContext & debugContext = { } , TensorCloneMethod method = TensorCloneMethod :: PRESERVE_ORDER_UNLESS_ALIASES , TensorCloneDuplicationMethod duplicationMethod = TensorCloneDuplicationMethod :: DUPLICATE_BY_OUTER_DIMENSION )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::clone(const poplar::Tensor &, const poplar::DebugContext &, poplar::TensorCloneMethod)","Filename":"poplar/Graph.hpp","Text":"Tensor clone ( const Tensor & t , const DebugContext & debugContext = { } , TensorCloneMethod method = TensorCloneMethod :: PRESERVE_ORDER_UNLESS_ALIASES )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::cloneN(const poplar::Tensor &, std::size_t, const poplar::DebugContext &, poplar::TensorCloneMethod, poplar::TensorCloneDuplicationMethod)","Filename":"poplar/Graph.hpp","Text":"Tensor cloneN ( const Tensor & t , std :: size_t N , const DebugContext & debugContext = { } , TensorCloneMethod method = TensorCloneMethod :: PRESERVE_ORDER_UNLESS_ALIASES , TensorCloneDuplicationMethod duplicationMethod = TensorCloneDuplicationMethod :: DUPLICATE_BY_OUTER_DIMENSION )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::connect(poplar::FieldRef, const poplar::Tensor &)","Filename":"poplar/Graph.hpp","Text":"void connect ( FieldRef field , const Tensor & tensor )"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::connect(poplar::FieldRef, T, typename std::enable_if<TypeTraits::isSimpleType<T>()>::type *)","Filename":"poplar/Graph.hpp","Text":"template < typename T > void connect ( FieldRef field , T v , typename std :: enable_if < TypeTraits :: isSimpleType < T > ( ) > :: type * = nullptr )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::connect(poplar::FieldRef, ArrayRef<poplar::Tensor>)","Filename":"poplar/Graph.hpp","Text":"void connect ( FieldRef field , ArrayRef < Tensor > tensors )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::setCycleEstimate(const poplar::VertexRef &, std::uint64_t)","Filename":"poplar/Graph.hpp","Text":"void setCycleEstimate ( const VertexRef & v , std :: uint64_t cycles )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::getCycleEstimate(const poplar::VertexRef &)","Filename":"poplar/Graph.hpp","Text":"std :: uint64_t getCycleEstimate ( const VertexRef & v ) const"}
{"Token type":"CXXMethod","FaliureReason":"calls_deleted_function","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::registerCycleEstimator(poplar::StringRef, poplar::CycleEstimateFunc)","Filename":"poplar/Graph.hpp","Text":"void registerCycleEstimator ( StringRef vertexTypeName , CycleEstimateFunc f )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::getNumVertices()","Filename":"poplar/Graph.hpp","Text":"unsigned getNumVertices ( void ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::addComputeSet(const poplar::DebugContext &)","Filename":"poplar/Graph.hpp","Text":"ComputeSet addComputeSet ( const DebugContext & debugContext = { } )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::setFieldSize(poplar::FieldRef, std::size_t)","Filename":"poplar/Graph.hpp","Text":"void setFieldSize ( FieldRef field , std :: size_t size )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::getFieldSize(poplar::FieldRef)","Filename":"poplar/Graph.hpp","Text":"std :: size_t getFieldSize ( FieldRef field ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::getMaxFieldDim(poplar::StringRef, poplar::StringRef, unsigned int)","Filename":"poplar/Graph.hpp","Text":"std :: size_t getMaxFieldDim ( StringRef vertexName , StringRef fieldName , unsigned dimIndex ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::getMaxVertexFieldValue(poplar::StringRef, poplar::StringRef)","Filename":"poplar/Graph.hpp","Text":"double getMaxVertexFieldValue ( StringRef vertexName , StringRef fieldName ) const"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::setInitialValue(poplar::FieldRef, T, typename std::enable_if<TypeTraits::isSimpleType<T>()>::type *)","Filename":"poplar/Graph.hpp","Text":"template < typename T > void setInitialValue ( FieldRef field , T val , typename std :: enable_if < TypeTraits :: isSimpleType < T > ( ) > :: type * = nullptr )"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::setInitCallback(poplar::FieldRef, LateInitCallback<T>, typename std::enable_if<std::is_arithmetic<T>::value>::type *)","Filename":"poplar/Graph.hpp","Text":"template < typename T > void setInitCallback ( FieldRef field , LateInitCallback < T > callback , typename std :: enable_if < std :: is_arithmetic < T > :: value > :: type * = nullptr )"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::setInitialValue(poplar::FieldRef, const std::vector<T> &)","Filename":"poplar/Graph.hpp","Text":"template < typename T > void setInitialValue ( FieldRef field , const std :: vector < T > & v )"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::setInitialValue(poplar::FieldRef, const std::initializer_list<T> &)","Filename":"poplar/Graph.hpp","Text":"template < typename T > void setInitialValue ( FieldRef field , const std :: initializer_list < T > & l )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::setInitialValueHalf(poplar::FieldRef, uint16_t)","Filename":"poplar/Graph.hpp","Text":"void setInitialValueHalf ( FieldRef field , uint16_t val )"}
{"Token type":"FunctionTemplate","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::setInitialValue(poplar::FieldRef, ArrayRef<T>)","Filename":"poplar/Graph.hpp","Text":"template < typename T > void setInitialValue ( FieldRef field , ArrayRef < T > val )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::setInitialValueHalf(poplar::FieldRef, ArrayRef<uint16_t>)","Filename":"poplar/Graph.hpp","Text":"void setInitialValueHalf ( FieldRef field , ArrayRef < uint16_t > val )"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::setInitialValue(const poplar::Tensor &, T, typename std::enable_if<TypeTraits::isSimpleType<T>()>::type *)","Filename":"poplar/Graph.hpp","Text":"template < typename T > void setInitialValue ( const Tensor & t , T val , typename std :: enable_if < TypeTraits :: isSimpleType < T > ( ) > :: type * = nullptr )"}
{"Token type":"FunctionTemplate","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::setInitialValue(const poplar::Tensor &, ArrayRef<T>)","Filename":"poplar/Graph.hpp","Text":"template < typename T > void setInitialValue ( const Tensor & t , ArrayRef < T > values )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::setInitialValueHalf(const poplar::Tensor &, uint16_t)","Filename":"poplar/Graph.hpp","Text":"void setInitialValueHalf ( const Tensor & t , uint16_t val )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::setInitialValueHalf(const poplar::Tensor &, ArrayRef<uint16_t>)","Filename":"poplar/Graph.hpp","Text":"void setInitialValueHalf ( const Tensor & t , ArrayRef < uint16_t > values )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::createHostWrite(poplar::StringRef, const poplar::Tensor &, bool)","Filename":"poplar/Graph.hpp","Text":"void createHostWrite ( StringRef handle , const Tensor & t , bool rearrangeOnHost = false )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::createHostRead(poplar::StringRef, const poplar::Tensor &, bool)","Filename":"poplar/Graph.hpp","Text":"void createHostRead ( StringRef handle , const Tensor & t , bool rearrangeOnHost = false )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::addHostToDeviceFIFO(poplar::StringRef, const poplar::Type &, std::size_t, poplar::ReplicatedStreamMode, const poplar::OptionFlags &)","Filename":"poplar/Graph.hpp","Text":"DataStream addHostToDeviceFIFO ( StringRef handle , const Type & elementType , std :: size_t numElements , ReplicatedStreamMode replicatedMode = ReplicatedStreamMode :: REPLICATE , const OptionFlags & options = { } )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::addDeviceToHostFIFO(poplar::StringRef, const poplar::Type &, std::size_t, const poplar::OptionFlags &)","Filename":"poplar/Graph.hpp","Text":"DataStream addDeviceToHostFIFO ( StringRef handle , const Type & elementType , std :: size_t numElements , const OptionFlags & options = { } )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::addRemoteBuffer(poplar::StringRef, const poplar::Type &, std::size_t, std::size_t, bool, bool)","Filename":"poplar/Graph.hpp","Text":"RemoteBuffer addRemoteBuffer ( StringRef handle , const Type & elementType , std :: size_t numElements , std :: size_t repeats = 1 , bool rearrangeOnHost = false , bool optimiseMemory = false )"}
{"Token type":"CXXMethod","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::outputVertexGraph(std::ostream &, ArrayRef<program::Program>)","Filename":"poplar/Graph.hpp","Text":"void outputVertexGraph ( std :: ostream & outputStream , ArrayRef < program :: Program > progs = { } ) const"}
{"Token type":"CXXMethod","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::outputComputeGraph(std::ostream &, ArrayRef<program::Program>)","Filename":"poplar/Graph.hpp","Text":"void outputComputeGraph ( std :: ostream & outputStream , ArrayRef < program :: Program > progs = { } ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::setTileMapping(poplar::VertexRef, unsigned int)","Filename":"poplar/Graph.hpp","Text":"void setTileMapping ( VertexRef v , unsigned tileNum )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::setTileMapping(const poplar::Tensor &, unsigned int)","Filename":"poplar/Graph.hpp","Text":"void setTileMapping ( const Tensor & t , unsigned tileNum )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::getTileMapping(const poplar::Tensor &, bool)","Filename":"poplar/Graph.hpp","Text":"TileToTensorMapping getTileMapping ( const Tensor & t , bool requireComplete = true ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::getTileMapping(const poplar::Tensor &, bool *)","Filename":"poplar/Graph.hpp","Text":"TileToTensorMapping getTileMapping ( const Tensor & t , bool * isComplete ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::getVariableTileMapping(const poplar::Tensor &)","Filename":"poplar/Graph.hpp","Text":"TileToTensorMapping getVariableTileMapping ( const Tensor & t ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::setTileMapping(const poplar::Tensor &, const poplar::Graph::TileToTensorMapping &)","Filename":"poplar/Graph.hpp","Text":"void setTileMapping ( const Tensor & t , const TileToTensorMapping & mapping )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::getVariable(poplar::VariableRef)","Filename":"poplar/Graph.hpp","Text":"Tensor getVariable ( VariableRef v ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::isConstant(poplar::VariableRef)","Filename":"poplar/Graph.hpp","Text":"bool isConstant ( VariableRef v ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::getSortedContiguousRegions(const poplar::Tensor &, ArrayRef<poplar::Interval>, bool, std::vector<std::size_t> *)","Filename":"poplar/Graph.hpp","Text":"std :: vector < std :: vector < Interval >> getSortedContiguousRegions ( const Tensor & t , ArrayRef < Interval > regions , bool removeAliasedIntervals = false , std :: vector < std :: size_t > * aliases = nullptr ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::reorderToSimplify(poplar::Tensor *, ArrayRef<poplar::Tensor *>, bool)","Filename":"poplar/Graph.hpp","Text":"void reorderToSimplify ( Tensor * t , ArrayRef < Tensor * > ts , bool requireSimplestOrder = true ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::findUnbroadcastTensor(const poplar::Tensor &)","Filename":"poplar/Graph.hpp","Text":"Tensor findUnbroadcastTensor ( const Tensor & t ) const"}
{"Token type":"CXXMethod","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::serializeTensors(std::ostream &, ArrayRef<poplar::Tensor>, poplar::SerializationFormat)","Filename":"poplar/Graph.hpp","Text":"void serializeTensors ( std :: ostream & out , ArrayRef < Tensor > tensors , SerializationFormat format ) const"}
{"Token type":"CXXMethod","FaliureReason":"istream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::deserializeTensors(std::istream &, poplar::SerializationFormat)","Filename":"poplar/Graph.hpp","Text":"std :: vector < Tensor > deserializeTensors ( std :: istream & in , SerializationFormat format )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::createVirtualGraph(unsigned int)","Filename":"poplar/Graph.hpp","Text":"Graph createVirtualGraph ( unsigned numTilesPerIPU )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::createVirtualGraph(unsigned int, unsigned int)","Filename":"poplar/Graph.hpp","Text":"Graph createVirtualGraph ( unsigned lowerTile , unsigned upperTile )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::createVirtualGraph(const std::vector<unsigned int> &)","Filename":"poplar/Graph.hpp","Text":"Graph createVirtualGraph ( const std :: vector < unsigned > & perIpuTiles )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::createReplicatedGraph(unsigned int)","Filename":"poplar/Graph.hpp","Text":"Graph createReplicatedGraph ( unsigned replicationFactor )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::getTopLevelGraph()","Filename":"poplar/Graph.hpp","Text":"Graph getTopLevelGraph ( )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::getReplicationFactor()","Filename":"poplar/Graph.hpp","Text":"unsigned getReplicationFactor ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::addReplicationIndexConstant()","Filename":"poplar/Graph.hpp","Text":"Tensor addReplicationIndexConstant ( )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::getNonReplicatedTensor(const poplar::Tensor &)","Filename":"poplar/Graph.hpp","Text":"Tensor getNonReplicatedTensor ( const Tensor & t ) const"}
{"Token type":"CXXMethod","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::serialize(std::ostream &, poplar::SerializationFormat)","Filename":"poplar/Graph.hpp","Text":"void serialize ( std :: ostream & out , SerializationFormat format ) const"}
{"Token type":"CXXMethod","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::serialize(std::ostream &, ArrayRef<program::Program>, poplar::SerializationFormat)","Filename":"poplar/Graph.hpp","Text":"void serialize ( std :: ostream & out , ArrayRef < program :: Program > progs , SerializationFormat format ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::addFunction(const program::Program &)","Filename":"poplar/Graph.hpp","Text":"Function addFunction ( const program :: Program & program )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::convertVirtualTileToPhysicalTile(unsigned int)","Filename":"poplar/Graph.hpp","Text":"unsigned convertVirtualTileToPhysicalTile ( unsigned virtualTileId ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::convertPhysicalTileToVirtualTile(unsigned int)","Filename":"poplar/Graph.hpp","Text":"unsigned convertPhysicalTileToVirtualTile ( unsigned physicalTileId ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::convertPhysicalTileToVirtualTile(unsigned int, unsigned int)","Filename":"poplar/Graph.hpp","Text":"unsigned convertPhysicalTileToVirtualTile ( unsigned ipuId , unsigned physicalTileId ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Graph::hasCodelet(poplar::StringRef)","Filename":"poplar/Graph.hpp","Text":"bool hasCodelet ( StringRef codeletName ) const"}
{"Token type":"CXXConstructor","FaliureReason":"unique_ptr_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::Graph(std::unique_ptr<core::GraphBuilder>, poplar::Target)","Filename":"poplar/Graph.hpp","Text":"Graph ( std :: unique_ptr < core :: GraphBuilder > , Target target )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::getImpl()","Filename":"poplar/Graph.hpp","Text":"core :: GraphBuilder & getImpl ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::setInitialValue(poplar::FieldRef, const void *, const poplar::TypeTraits &)","Filename":"poplar/Graph.hpp","Text":"void setInitialValue ( FieldRef field , const void * val , const TypeTraits & )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::setInitCallback(poplar::FieldRef, LateInitCallback<T>, const poplar::TypeTraits &)","Filename":"poplar/Graph.hpp","Text":"template < typename T > void setInitCallback ( FieldRef field , LateInitCallback < T > callback , const TypeTraits & )"}
{"Token type":"CXXMethod","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::setInitialValue(const poplar::Tensor &, const void *, const poplar::TypeTraits &)","Filename":"poplar/Graph.hpp","Text":"void setInitialValue ( const Tensor & t , const void * val , const TypeTraits & )"}
{"Token type":"CXXMethod","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::connect(poplar::FieldRef, void *, const poplar::TypeTraits &)","Filename":"poplar/Graph.hpp","Text":"void connect ( FieldRef field , void * val , const TypeTraits & )"}
{"Token type":"CXXMethod","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::checkFieldSubgraph(const poplar::FieldRef &)","Filename":"poplar/Graph.hpp","Text":"void checkFieldSubgraph ( const FieldRef & f ) const"}
{"Token type":"CXXMethod","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::checkVertexSubgraph(const poplar::VertexRef &)","Filename":"poplar/Graph.hpp","Text":"void checkVertexSubgraph ( const VertexRef & v ) const"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::StreamCallback","Filename":"poplar/StreamCallback.hpp","Text":"class StreamCallback { public : enum class Result { Success , NotAvailable } ; virtual ~ StreamCallback ( ) = default ; /** Callback function to fill the host buffer (host-to-device streams only).\n   * This function is called speculatively, this means it might still be called\n   * even if no additional copies for this stream exist for the remaining\n   * execution of the program.\n   *\n   * The following situations are possible during the invocation:\n   * a) There is more data available for consumption.\n   * b) Data is temporarily not available during the point in time this function\n   *    is called.\n   * c) The stream reached the end and thus has not got any more data available.\n   *\n   * The return value indicates if the invocation resulted in the buffer being\n   * successfully filled. In the first case (a), the function shall return\n   * `Result::Success`. A call to `complete` will follow if the program ends up\n   * transferring the data. Otherwise (scenarios b and c), it must return\n   * `Result::NotAvailable`. Calls to `fetch` and then `complete` will follow\n   * if the transfer takes place.\n   *\n   * \\param p Location of the buffer. It will only be valid for the duration of\n   *          the function.\n   * \\returns `Result::Success` if the function was able to fill the buffer with\n   *          data, or `Result::NotAvailable` otherwise.\n   */ virtual Result prefetch ( void * p ) = 0 ; /** Notifies that the data involved in the last prefetch/fetch invocation is\n   * used by the device. It usually means that a speculative read was a hit, and\n   * the callback can move on to the next piece of input.\n   */ virtual void complete ( ) = 0 ; /** Callback function to fill the host buffer.\n   * This function is called as a result of a stream copy, unless the last\n   * `prefetch` invocation was successful.\n   *\n   * It must always fill the buffer with more data and it is followed by a call\n   * to `complete`.\n   */ virtual void fetch ( void * ) = 0 ; }"}
{"Token type":"EnumDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::StreamCallback::Result","Filename":"poplar/StreamCallback.hpp","Text":"enum class Result { Success , NotAvailable }"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::StreamCallback::Result::Success","Filename":"poplar/StreamCallback.hpp","Text":"Success"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::StreamCallback::Result::NotAvailable","Filename":"poplar/StreamCallback.hpp","Text":"NotAvailable"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::StreamCallback::prefetch(void *)","Filename":"poplar/StreamCallback.hpp","Text":"virtual Result prefetch ( void * p ) = 0"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::StreamCallback::complete()","Filename":"poplar/StreamCallback.hpp","Text":"virtual void complete ( ) = 0"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::StreamCallback::fetch(void *)","Filename":"poplar/StreamCallback.hpp","Text":"virtual void fetch ( void * ) = 0"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::LegacyStreamCallback","Filename":"poplar/StreamCallback.hpp","Text":"class LegacyStreamCallback : public StreamCallback { public : virtual Result prefetch ( void * ) final override { return Result :: NotAvailable ; } virtual void complete ( ) final override { } }"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::LegacyStreamCallback::prefetch(void *)","Filename":"poplar/StreamCallback.hpp","Text":"virtual Result prefetch ( void * ) final override"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::LegacyStreamCallback::complete()","Filename":"poplar/StreamCallback.hpp","Text":"virtual void complete ( ) final override"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::StreamCallbackHandle","Filename":"poplar/StreamCallback.hpp","Text":"class StreamCallbackHandle { public : /** Constructs a handle from an instance of a stream callback implementation.\n   * This constructor only participates in overload resolution if CallbackImpl\n   * is derived from poplar::StreamCallback (i.e. it is an implementation of the\n   * callback interface).\n   */ template < class CallbackImpl , typename = typename std :: enable_if < std :: is_base_of < StreamCallback , CallbackImpl > :: value > :: type > StreamCallbackHandle ( std :: unique_ptr < CallbackImpl > f ) : callback ( std :: move ( f ) ) { if ( ! callback ) { throw poplar_error ( \"Invalid null stream callback\" ) ; } } /** Constructs a handle from a callable instance.\n   * This constructor only participates in overload resolution if F satisfies\n   * the requirements of a Function Object.\n   * It transforms `f` into a LegacyStreamCallback implementation.\n   * \\sa https://en.cppreference.com/w/cpp/named_req/FunctionObject\n   */ template < class F , typename = typename std :: enable_if < traits :: is_callback < F > :: value > :: type > StreamCallbackHandle ( F && f ) : callback ( makeCallback ( std :: forward < F > ( f ) ) ) { } // Non copy constructible StreamCallbackHandle ( const StreamCallbackHandle & ) = delete ; // Move constructible StreamCallbackHandle ( StreamCallbackHandle && ) = default ; // This forces the user to provide a non-empty callback and allows the // internal implementation to only make use of std::unique_ptr<StreamCallback> // if necessary. /** Extracts the callback implementation from the handle.\n   */ operator std :: unique_ptr < StreamCallback > ( ) && { return std :: move ( callback ) ; } private : template < class F > static std :: unique_ptr < StreamCallback > makeCallback ( F && f ) { struct NonPrefetchable final : LegacyStreamCallback { using Function = typename traits :: remove_cvref < F > :: type ; NonPrefetchable ( F && f ) : function ( std :: forward < F > ( f ) ) { } void fetch ( void * p ) override { function ( p ) ; } Function function ; } ; return std :: unique_ptr < NonPrefetchable > ( new NonPrefetchable ( std :: forward < F > ( f ) ) ) ; } std :: unique_ptr < StreamCallback > callback ; }"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::StreamCallbackHandle::StreamCallbackHandle(std::unique_ptr<CallbackImpl>)","Filename":"poplar/StreamCallback.hpp","Text":"template < class CallbackImpl , typename = typename std :: enable_if < std :: is_base_of < StreamCallback , CallbackImpl > :: value > :: type > StreamCallbackHandle ( std :: unique_ptr < CallbackImpl > f )"}
{"Token type":"FunctionTemplate","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::StreamCallbackHandle::StreamCallbackHandle(F &&)","Filename":"poplar/StreamCallback.hpp","Text":"template < class F , typename = typename std :: enable_if < traits :: is_callback < F > :: value > :: type > StreamCallbackHandle ( F && f )"}
{"Token type":"CXXConstructor","FaliureReason":"deleted_method","Implemented":false,"Namespace":"poplar","Name":"poplar::StreamCallbackHandle::StreamCallbackHandle(const poplar::StreamCallbackHandle &)","Filename":"poplar/StreamCallback.hpp","Text":"StreamCallbackHandle ( const StreamCallbackHandle & ) = delete"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::StreamCallbackHandle::StreamCallbackHandle(poplar::StreamCallbackHandle &&)","Filename":"poplar/StreamCallback.hpp","Text":"StreamCallbackHandle ( StreamCallbackHandle && ) = default"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::StreamCallbackHandle::makeCallback(F &&)","Filename":"poplar/StreamCallback.hpp","Text":"template < class F > static std :: unique_ptr < StreamCallback > makeCallback ( F && f )"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::Engine","Filename":"poplar/Engine.hpp","Text":"class Engine"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::TimerTimePoint","Filename":"poplar/Engine.hpp","Text":"class TimerTimePoint"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Engine","Filename":"poplar/Engine.hpp","Text":"class Engine { public : /**\n   * Callback function used to to indicate\n   * engine compilation progress. The function is\n   * passed two integers. The first is the progress\n   * value and the second is the maximum value for\n   * the progress.\n   *\n   * If a progress callback is used, the function should not block. All calls\n   * to the callback function will be made in a single dedicated thread so\n   * blocking in the callback will block the receipt of further notifications\n   * (but will not block compilation from progressing).\n   * The callback should not use Poplar objects or functions relating to the\n   * Graph, Engine or Device that are being compiled.\n   *\n   */ using ProgressFunc = std :: function < void ( int , int ) > ; /** Construct the engine from a graph and a list of programs.\n   *\n   *  \\param graph  The graph to compile into the engine.\n   *\n   *  \\param progs  The list of programs to run over the graph.\n   *                Each program can be run separately by calling\n   *                the run() method of the Engine with the argument\n   *                being the index of the program to run in this list.\n   *\n   *  \\param opt    Options that can be used to control compilation and\n   *                execution. The available options are listed under Engine.\n   *\n   *  \\param progressCallBack A function that will be called to indicate\n   *                          engine compilation progress.\n   *                          See Engine::ProgressFunc for more information.\n   *\n   *  \\throws invalid_option  If any of the options passed in `opt` were\n   *                          not recognised or improperly formatted.\n   *  \\throws link_error  If program linking fails; for example, due to\n   *                      undefined symbols or lack of memory on a tile.\n   */ Engine ( const Graph & graph , ArrayRef < program :: Program > progs , const OptionFlags & opt = { } , ProgressFunc progressCallBack = ProgressFunc ( ) ) ; Engine ( Graph && graph , ArrayRef < program :: Program > progs , const OptionFlags & opt = { } , ProgressFunc progressCallBack = ProgressFunc ( ) ) ; /** Construct the engine from a graph and a program.\n   *\n   *  \\param graph  The graph to compile into the engine.\n   *\n   *  \\param prog   The program to run over the graph. This program\n   *                is run when the run() method is called on the\n   *                Engine.\n   *\n   *  \\param opt    Options that can be used to control compilation and\n   *                execution. The available options are listed under Engine.\n   *\n   *  \\param progressCallBack A function that will be called to indicate\n   *                          engine compilation progress.\n   *                          See Engine::ProgressFunc for more information.\n   *\n   *  \\throws invalid_option  If any of the options passed in `opt` were\n   *                          not recognised or improperly formatted.\n   *\n   *  \\throws link_error  If the program linking fails; for example, due to\n   *                      undefined symbols or lack of memory on a tile.\n   */ Engine ( const Graph & graph , program :: Program prog , const OptionFlags & opt = { } , ProgressFunc progressCallBack = ProgressFunc ( ) ) ; Engine ( Graph && graph , program :: Program prog , const OptionFlags & opt = { } , ProgressFunc progressCallBack = ProgressFunc ( ) ) ; /** Construct the engine from a precompiled executable.\n   *\n   * \\param exe    The precompiled executable. This can be\n   *               created using poplar::compileGraph().\n   * \\param opt    Options that can be used to control execution. These\n   *               must be the same as the flags passed to compileGraph().\n   *               The available options are listed under Engine.\n   *\n   *  \\throws invalid_option  If any of the options passed in `opt` were\n   *                          not recognised or improperly formatted.\n   */ Engine ( Executable && exe , const OptionFlags & opt = { } ) ; // Move constructor Engine ( Engine && ) ; ~ Engine ( ) ; /** Prepare the device for loading\n   *\n   * This configures the device ready for loading binary code.\n   *\n   * \\param device The device to load onto.\n   */ void prepare ( const Device & device ) ; /** Load the engine\n   *\n   * This loads binary code. The device must have been prepare()ed previously.\n   */ void deploy ( ) ; /** Load the compiled program/graph onto a device.\n   *\n   *  This function will load all binary code and data onto the\n   *  device ready for execution. This is a shortcut to separate prepare() and\n   * deploy() calls.\n   *\n   *  \\param device The device to load onto.\n   */ void load ( const Device & device ) ; /** Run the graph program.\n   *\n   *  This function will execute the graph program. Note that the\n   *  program needs to have already been loaded onto a device otherwise\n   *  an exception will occur.\n   *\n   *  \\param prog The index of the program to run. If this is greater\n   *              than or equal to the number of programs given in the\n   *              constructor then an exception is thrown.\n   *\n   * \\param debugName Run name (for debugging/analysis).\n   */ void run ( unsigned prog = 0 , const std :: string & debugName = \"\" ) ; /** Run the graph program.\n   *\n   *  This function will load the program/graph onto the device and\n   *  then execute the graph program.\n   *\n   *  \\param prog The index of the program to run. If this is greater\n   *              than or equal to the number of programs given in the\n   *              constructor then an exception is thrown.\n   */ void loadAndRun ( const Device & device , unsigned prog = 0 ) ; /* pImpl interface to core timing info\n   * Construction is private, obtain one via \\p getTimeStamp()\n   */ class TimerTimePoint { public : TimerTimePoint ( ) = default ; private : std :: shared_ptr < core :: TimerTimePoint > impl ; explicit TimerTimePoint ( Engine & e ) ; friend class Engine ; } ; /** Get a record of the current host and device time. Details depend on\n   * the underlying device used.\n   */ TimerTimePoint getTimeStamp ( ) ; /** Get a timing report for the measured interval. Details depend on the\n   * underlying device used.\n   * \\param start Start time of report\n   * \\param end End time of report\n   */ static std :: string reportTiming ( const TimerTimePoint & start , const TimerTimePoint & end ) ; /** Get a report containing profiling data for the graph on the underlying\n   *  device. This is only valid to call if the underlying device of the\n   *  graph is an IPU model device.\n   *\n   * \\throws profiling_disabled If the device is not an IPU or IPU model.\n   *\n   * \\returns A reference to an internal profile.\n   */ const ProfileValue & getGraphProfile ( ) const ; /** Get a report containing profiling data for programs executed with\n   *  this engine since this engine was constructed/the execution report\n   *  was last reset.\n   *\n   * See the\n   * <a href=\"https://www.graphcore.ai/docs/poplar-and-poplibs-user-guide\">\n   * Poplar and PopLibs User Guide</a> for details of the data in the report.\n   *\n   * \\throws profiling_disabled If the device is not an IPU or IPU model.\n   *\n   * \\returns A reference to an internal profile. Be aware that if you store a\n   *          reference to this, rather than copying it, then it may change\n   *          when you run further programs.\n   */ const ProfileValue & getExecutionProfile ( ) ; /** Get a report containing profiling data for both the graph and the\n   *  programs executed with this engine. This is equivalent to getting\n   *  both the graph profile and execution profiles in a single ProfileValue.\n   *\n   * See the\n   * <a href=\"https://www.graphcore.ai/docs/poplar-and-poplibs-user-guide\">\n   * Poplar and PopLibs User Guide</a> for details of the data in the report.\n   *\n   * \\throws profiling_disabled If the device is not an IPU or IPU model.\n   *\n   * \\returns A copy of the internal profile.\n   */ ProfileValue getProfile ( ) ; /** Reset execution profile. When programs are run their profiles are\n   *  appended to the execution profile. This discards profiling information\n   *  for previously executed programs.\n   */ void resetExecutionProfile ( ) ; /** Pause execution profiling. Subsequent engine.run() calls are executed\n   *  without being profiled until a subsequent call to\n   * `enableExecutionProfiling`.\n   *\n   * For example, you can exclude individual programs from a profile like this:\n   *\n   *      engine.disableExecutionProfiling();\n   *      engine.run(...);\n   *      engine.enableExecutionProfiling();\n   */ void disableExecutionProfiling ( ) ; /** Enable execution profiling. Subsequent engine.run() calls are\n   *  profiled when executed.\n   */ void enableExecutionProfiling ( ) ; /** Get and print the summary of a report with the given options.\n   *  This is equivalent to getting and printing the summary of\n   *  both the graph and execution reports using\n   *  poplar::printProfileSummary().\n   *\n   *\n   *\n   * \\param outputStream  A stream to write the summary to.\n   * \\param opt           A set of option flags configuring the contents\n   *                      of the report. All can be \"true\" or \"false\".\n   *                      The default is \"false\".\\n\n   *                      The available options are:\n   *                        * `showVarStorage` (true, false)\n   *                        * `showOptimizations` (true, false)\n   *                        * `showExecutionSteps` (true, false)\n   *\n   * \\throws profiling_disabled If the device is not an IPU model device.\n   * \\throws invalid_option     If any of the options passed in `opt` were\n   *                            not recognised or improperly formatted.\n   */ void printProfileSummary ( std :: ostream & outputStream , const OptionFlags & opt = { } ) ; /** Write a CSV data file to a specified output stream containing the number\n   *  of tiles active over time in cycles for compute, synchronisation and\n   *  exchange phases.\\n Each row contains the following entries:\n   *\n   *  - begin time in cycles\n   *  - end time in cycles\n   *  - number of tiles participating in compute\n   *  - number of tiles participating in exchange\n   *  - number of tiles participating in synchronisation\n   *\n   *  Because tiles execute a number of threads (up to 6) in parallel a single\n   *  \"thread cycle\" may only be executed every 6 tile clock cycles. The\n   *  cycles reported by this function are tile clock cycles rather than\n   *  thread cycles.\n   *\n   *  \\param outputStream An output stream for the CSV data to be written to.\n   *\n   *  \\throws profiling_disabled If the device has no profiling enabled.\n   */ void reportIntervals ( std :: ostream & outputStream ) ; /** Synchronous copy of a buffer of data from a specific tensor\n   *  in the device into a host size buffer.  The tensor must have\n   *  been marked as an output tensor. The buffer must have room for\n   *  all of the tensor data. The handle should match the one passed\n   *  to Graph::createHostRead()\n   *\n   *  \\sa Graph::createHostRead()\n   *\n   * \\param handle The source host copy handle.\n   * \\param buf The destination of the read.\n   *\n   * \\deprecated Use readTensor(StringRef, void*, void*) instead.\n   */ void readTensor ( StringRef handle , void * buf ) ; /** Synchronous copy of a buffer of data from a specific tensor\n   *  in the device into a host size buffer.  The tensor must have\n   *  been marked as an output tensor. The buffer must have room for\n   *  all of the tensor data. Buffer end address required for sizes\n   *  verification. The handle should match the one passed to\n   *  Graph::createHostRead()\n   *\n   *  \\sa Graph::createHostRead()\n   *\n   * \\param handle The source host copy handle.\n   * \\param buf The destination of the read.\n   * \\param bufEnd The end address of destination space\n   */ void readTensor ( StringRef handle , void * buf , void * bufEnd ) ; /** Synchronous copy of a buffer of data from the host to a\n   *  specific tensor in the device.  The tensor must have been\n   *  marked as an input tensor.  The buffer must have enough data\n   *  for the whole tensor. The handle should match the one passed\n   *  to Graph::createHostWrite()\n   *\n   *  \\sa Graph::createHostWrite()\n   *\n   * \\param handle The destination host copy handle.\n   * \\param buf The source of the write.\n   *\n   * \\deprecated Use writeTensor(StringRef, const void*, const void*) instead.\n   */ void writeTensor ( StringRef handle , const void * buf ) ; /** Synchronous copy of a buffer of data from the host to a\n   *  specific tensor in the device.  The tensor must have been\n   *  marked as an input tensor. Buffer end address required for sizes\n   *  verification. The handle should match the one passed to\n   *  Graph::createHostWrite()\n   *\n   *  \\sa Graph::createHostWrite()\n   *\n   * \\param handle The destination host copy handle.\n   * \\param buf The source of the write.\n   * \\param bufEnd The end address of source space.\n   */ void writeTensor ( StringRef handle , const void * buf , const void * bufEnd ) ; /** Connect a stream to a circular buffer in memory. Each time\n   *  data is copied to/from the stream the pointer for the next\n   *  transfer is incremented within the bounds given.\n   *\n   *  \\param handle The name of the stream to connect to\n   *  \\param begin  Pointer to the start of the circular buffer\n   *  \\param end    Pointer to the end of the circular buffer.\n   */ void connectStream ( StringRef handle , void * begin , void * end ) ; /** Connect a stream to a circular buffer in memory. Each time\n   *  data is copied to/from the stream the pointer for the next\n   *  transfer is incremented within the bounds given.\n   *\n   *  \\param stream The stream to connect to\n   *  \\param begin  Pointer to the start of the circular buffer\n   *  \\param end    Pointer to the end of the circular buffer.\n   *\n   *  \\deprecated Use connectStream(StringRef, void*, void*) instead.\n   */ void connectStream ( const DataStream & stream , void * begin , void * end ) { connectStream ( stream . handle ( ) , begin , end ) ; } /** Connect a stream to a fixed location in memory. Each time\n   *  data is copied to/from the stream this location will be read/written.\n   *\n   *  \\param handle The name of the stream to connect to\n   *  \\param p      The pointer to the memory buffer\n   */ void connectStream ( StringRef handle , void * p ) ; /** Connect a stream to a fixed location in memory. Each time\n   *  data is copied to/from the stream this location will be read/written.\n   *\n   *  \\param stream The stream to connect to\n   *  \\param p      The pointer to the memory buffer\n   *\n   *  \\deprecated Use connectStream(StringRef, void) instead.\n   */ void connectStream ( const DataStream & stream , void * p ) { connectStream ( stream . handle ( ) , p ) ; } /** Connect a stream to a callback taking a pointer to the location\n   *  in memory to copy into/from. This will be called whenever the\n   *  stream will be read/was written by the device.\n   *  The given memory location will only be valid to read from/write\n   *  to for the duration of the callback.\n   *\n   *  \\param handle The name of the stream to connect to.\n   *  \\param f      Callback to be called whenever the stream is\n   *                to be read/was written by the device.\n   */ void connectStreamToCallback ( StringRef handle , StreamCallbackHandle f ) ; /** Connect a stream to a callback taking a pointer to the location\n   *  in memory to copy into/from. This will be called whenever the\n   *  stream will be read/was written by the device.\n   *  The given memory location will only be valid to read from/write\n   *  to for the duration of the callback.\n   *\n   *  \\param stream The stream to connect to.\n   *  \\param f      Callback to be called whenever the stream is\n   *                to be read/was written by the device.\n   * \\deprecated Use connectStreamToCallback(StringRef, StreamCallbackHandle)\n   * instead.\n   */ void connectStreamToCallback ( const DataStream & stream , StreamCallbackHandle f ) { connectStreamToCallback ( stream . handle ( ) , std :: move ( f ) ) ; } /** Connect a replicated stream to a callback taking a pointer to the\n   *  location in memory to copy into/from. This will be called whenever the\n   *  stream will be read/was written by the device. The given memory\n   *  location will only be valid to read from/write to for the duration of\n   *  the callback.\n   *\n   *  \\param handle The name of the stream to connect to.\n   *  \\param index  The replicated index to connect to.\n   *  \\param f      Callback to be called whenever the stream is\n   *                to be read/was written by the device.\n   */ void connectStreamToCallback ( StringRef handle , unsigned index , StreamCallbackHandle f ) ; /** Connect a replicated stream to a callback taking a pointer to the\n   *  location in memory to copy into/from. This will be called whenever the\n   *  stream will be read/was written by the device. The given memory\n   *  location will only be valid to read from/write to for the duration of\n   *  the callback.\n   *\n   *  \\param stream The stream to connect to.\n   *  \\param index  The replicated index to connect to.\n   *  \\param f      Callback to be called whenever the stream is\n   *                to be read/was written by the device.\n   * \\deprecated Use connectStreamToCallback(StringRef, unsigned,\n   *                                         StreamCallbackHanle) instead.\n   */ void connectStreamToCallback ( const DataStream & stream , unsigned index , StreamCallbackHandle f ) { connectStreamToCallback ( stream . handle ( ) , index , std :: move ( f ) ) ; } /** Copy from a remote buffer to a user buffer w.\n   *\n   *  \\param handle The name of the remote buffer to copy from.\n   *  \\param w The user buffer to copy to.\n   *  \\param repeatIndex The index in the remote buffer to copy from.\n   *  \\param replicationIndex The replicated graph index.\n   */ void copyFromRemoteBuffer ( StringRef handle , void * w , int repeatIndex , unsigned replicationIndex = 0 ) ; /** Copy from a remote buffer to a user buffer w.\n   *\n   *  \\param buffer The remote buffer to copy from.\n   *  \\param w The user buffer to copy to.\n   *  \\param repeatIndex The index in the remote buffer to copy from.\n   *  \\param replicationIndex The replicated graph index.\n   *  \\deprecated Use copyFromRemoteBuffer(StringRef, void*, int, unsigned)\n   *  instead.\n   */ void copyFromRemoteBuffer ( const RemoteBuffer & buffer , void * w , int repeatIndex , unsigned replicationIndex = 0 ) { copyFromRemoteBuffer ( buffer . handle ( ) , w , repeatIndex , replicationIndex ) ; } /** Copy to a remote buffer from a user buffer w.\n   *\n   *  \\param w The user buffer to copy from.\n   *  \\param handle The remote buffer to copy to.\n   *  \\param repeatIndex The index in the remote buffer to copy to.\n   *  \\param replicationIndex The replicated graph index.\n   */ void copyToRemoteBuffer ( void * w , StringRef handle , int repeatIndex , unsigned replicationIndex = 0 ) ; /** Copy to a remote buffer from a user buffer w.\n   *\n   *  \\param w The user buffer to copy from.\n   *  \\param buffer The remote buffer to copy to.\n   *  \\param repeatIndex The index in the remote buffer to copy to.\n   *  \\param replicationIndex The replicated graph index.\n   *  \\deprecated Use copyFromRemoteBuffer(StringRef, void*, int, unsigned)\n   *  instead.\n   */ void copyToRemoteBuffer ( void * w , const RemoteBuffer & buffer , int repeatIndex , unsigned replicationIndex = 0 ) { copyToRemoteBuffer ( w , buffer . handle ( ) , repeatIndex , replicationIndex ) ; } /** Return a list of all streams in the engine.\n   *\n   * @return Vector of strings each of which is a stream's handle postfixed\n   * with '+' or '-' indicating whether the stream is a host-write or\n   * a host-read respectively.\n   */ std :: vector < std :: string > listStreams ( ) const ; /** Set output stream for printf commands.\n   *\n   *  \\param stream The output stream to use.\n   */ void setPrintStream ( std :: ostream & stream ) ; /** Set the output stream for PrintTensor programs. By default tensors\n   * are printed to stderr.\n   *\n   * \\param stream The output stream to use.\n   */ void setPrintTensorStream ( std :: ostream & stream ) ; /** Returns options the engine was created with\n   */ OptionFlags getEngineOptions ( ) const ; // Implementation Engine ( std :: unique_ptr < core :: Engine > ) ; const core :: Engine & getImpl ( ) const { return * impl ; } private : std :: unique_ptr < core :: Engine > impl ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Engine::Engine(const poplar::Graph &, ArrayRef<program::Program>, const poplar::OptionFlags &, poplar::Engine::ProgressFunc)","Filename":"poplar/Engine.hpp","Text":"Engine ( const Graph & graph , ArrayRef < program :: Program > progs , const OptionFlags & opt = { } , ProgressFunc progressCallBack = ProgressFunc ( ) )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Engine::Engine(poplar::Graph &&, ArrayRef<program::Program>, const poplar::OptionFlags &, poplar::Engine::ProgressFunc)","Filename":"poplar/Engine.hpp","Text":"Engine ( Graph && graph , ArrayRef < program :: Program > progs , const OptionFlags & opt = { } , ProgressFunc progressCallBack = ProgressFunc ( ) )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Engine::Engine(const poplar::Graph &, program::Program, const poplar::OptionFlags &, poplar::Engine::ProgressFunc)","Filename":"poplar/Engine.hpp","Text":"Engine ( const Graph & graph , program :: Program prog , const OptionFlags & opt = { } , ProgressFunc progressCallBack = ProgressFunc ( ) )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Engine::Engine(poplar::Graph &&, program::Program, const poplar::OptionFlags &, poplar::Engine::ProgressFunc)","Filename":"poplar/Engine.hpp","Text":"Engine ( Graph && graph , program :: Program prog , const OptionFlags & opt = { } , ProgressFunc progressCallBack = ProgressFunc ( ) )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Engine::Engine(poplar::Executable &&, const poplar::OptionFlags &)","Filename":"poplar/Engine.hpp","Text":"Engine ( Executable && exe , const OptionFlags & opt = { } )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Engine::Engine(poplar::Engine &&)","Filename":"poplar/Engine.hpp","Text":"Engine ( Engine && )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Engine::prepare(const poplar::Device &)","Filename":"poplar/Engine.hpp","Text":"void prepare ( const Device & device )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Engine::deploy()","Filename":"poplar/Engine.hpp","Text":"void deploy ( )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Engine::load(const poplar::Device &)","Filename":"poplar/Engine.hpp","Text":"void load ( const Device & device )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Engine::run(unsigned int, const std::string &)","Filename":"poplar/Engine.hpp","Text":"void run ( unsigned prog = 0 , const std :: string & debugName = \"\" )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Engine::loadAndRun(const poplar::Device &, unsigned int)","Filename":"poplar/Engine.hpp","Text":"void loadAndRun ( const Device & device , unsigned prog = 0 )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Engine::TimerTimePoint","Filename":"poplar/Engine.hpp","Text":"class TimerTimePoint { public : TimerTimePoint ( ) = default ; private : std :: shared_ptr < core :: TimerTimePoint > impl ; explicit TimerTimePoint ( Engine & e ) ; friend class Engine ; }"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::Engine::TimerTimePoint::TimerTimePoint()","Filename":"poplar/Engine.hpp","Text":"TimerTimePoint ( ) = default"}
{"Token type":"CXXConstructor","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Engine::TimerTimePoint::TimerTimePoint(poplar::Engine &)","Filename":"poplar/Engine.hpp","Text":"explicit TimerTimePoint ( Engine & e )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Engine::getTimeStamp()","Filename":"poplar/Engine.hpp","Text":"TimerTimePoint getTimeStamp ( )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Engine::reportTiming(const poplar::Engine::TimerTimePoint &, const poplar::Engine::TimerTimePoint &)","Filename":"poplar/Engine.hpp","Text":"static std :: string reportTiming ( const TimerTimePoint & start , const TimerTimePoint & end )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Engine::getGraphProfile()","Filename":"poplar/Engine.hpp","Text":"const ProfileValue & getGraphProfile ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Engine::getExecutionProfile()","Filename":"poplar/Engine.hpp","Text":"const ProfileValue & getExecutionProfile ( )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Engine::getProfile()","Filename":"poplar/Engine.hpp","Text":"ProfileValue getProfile ( )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Engine::resetExecutionProfile()","Filename":"poplar/Engine.hpp","Text":"void resetExecutionProfile ( )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Engine::disableExecutionProfiling()","Filename":"poplar/Engine.hpp","Text":"void disableExecutionProfiling ( )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Engine::enableExecutionProfiling()","Filename":"poplar/Engine.hpp","Text":"void enableExecutionProfiling ( )"}
{"Token type":"CXXMethod","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Engine::printProfileSummary(std::ostream &, const poplar::OptionFlags &)","Filename":"poplar/Engine.hpp","Text":"void printProfileSummary ( std :: ostream & outputStream , const OptionFlags & opt = { } )"}
{"Token type":"CXXMethod","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Engine::reportIntervals(std::ostream &)","Filename":"poplar/Engine.hpp","Text":"void reportIntervals ( std :: ostream & outputStream )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Engine::readTensor(poplar::StringRef, void *)","Filename":"poplar/Engine.hpp","Text":"void readTensor ( StringRef handle , void * buf )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Engine::readTensor(poplar::StringRef, void *, void *)","Filename":"poplar/Engine.hpp","Text":"void readTensor ( StringRef handle , void * buf , void * bufEnd )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Engine::writeTensor(poplar::StringRef, const void *)","Filename":"poplar/Engine.hpp","Text":"void writeTensor ( StringRef handle , const void * buf )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Engine::writeTensor(poplar::StringRef, const void *, const void *)","Filename":"poplar/Engine.hpp","Text":"void writeTensor ( StringRef handle , const void * buf , const void * bufEnd )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Engine::connectStream(poplar::StringRef, void *, void *)","Filename":"poplar/Engine.hpp","Text":"void connectStream ( StringRef handle , void * begin , void * end )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Engine::connectStream(const poplar::DataStream &, void *, void *)","Filename":"poplar/Engine.hpp","Text":"void connectStream ( const DataStream & stream , void * begin , void * end )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Engine::connectStream(poplar::StringRef, void *)","Filename":"poplar/Engine.hpp","Text":"void connectStream ( StringRef handle , void * p )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Engine::connectStream(const poplar::DataStream &, void *)","Filename":"poplar/Engine.hpp","Text":"void connectStream ( const DataStream & stream , void * p )"}
{"Token type":"CXXMethod","FaliureReason":"calls_deleted_function","Implemented":false,"Namespace":"poplar","Name":"poplar::Engine::connectStreamToCallback(poplar::StringRef, poplar::StreamCallbackHandle)","Filename":"poplar/Engine.hpp","Text":"void connectStreamToCallback ( StringRef handle , StreamCallbackHandle f )"}
{"Token type":"CXXMethod","FaliureReason":"calls_deleted_function","Implemented":false,"Namespace":"poplar","Name":"poplar::Engine::connectStreamToCallback(const poplar::DataStream &, poplar::StreamCallbackHandle)","Filename":"poplar/Engine.hpp","Text":"void connectStreamToCallback ( const DataStream & stream , StreamCallbackHandle f )"}
{"Token type":"CXXMethod","FaliureReason":"calls_deleted_function","Implemented":false,"Namespace":"poplar","Name":"poplar::Engine::connectStreamToCallback(poplar::StringRef, unsigned int, poplar::StreamCallbackHandle)","Filename":"poplar/Engine.hpp","Text":"void connectStreamToCallback ( StringRef handle , unsigned index , StreamCallbackHandle f )"}
{"Token type":"CXXMethod","FaliureReason":"calls_deleted_function","Implemented":false,"Namespace":"poplar","Name":"poplar::Engine::connectStreamToCallback(const poplar::DataStream &, unsigned int, poplar::StreamCallbackHandle)","Filename":"poplar/Engine.hpp","Text":"void connectStreamToCallback ( const DataStream & stream , unsigned index , StreamCallbackHandle f )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Engine::copyFromRemoteBuffer(poplar::StringRef, void *, int, unsigned int)","Filename":"poplar/Engine.hpp","Text":"void copyFromRemoteBuffer ( StringRef handle , void * w , int repeatIndex , unsigned replicationIndex = 0 )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Engine::copyFromRemoteBuffer(const poplar::RemoteBuffer &, void *, int, unsigned int)","Filename":"poplar/Engine.hpp","Text":"void copyFromRemoteBuffer ( const RemoteBuffer & buffer , void * w , int repeatIndex , unsigned replicationIndex = 0 )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Engine::copyToRemoteBuffer(void *, poplar::StringRef, int, unsigned int)","Filename":"poplar/Engine.hpp","Text":"void copyToRemoteBuffer ( void * w , StringRef handle , int repeatIndex , unsigned replicationIndex = 0 )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Engine::copyToRemoteBuffer(void *, const poplar::RemoteBuffer &, int, unsigned int)","Filename":"poplar/Engine.hpp","Text":"void copyToRemoteBuffer ( void * w , const RemoteBuffer & buffer , int repeatIndex , unsigned replicationIndex = 0 )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Engine::listStreams()","Filename":"poplar/Engine.hpp","Text":"std :: vector < std :: string > listStreams ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Engine::setPrintStream(std::ostream &)","Filename":"poplar/Engine.hpp","Text":"void setPrintStream ( std :: ostream & stream )"}
{"Token type":"CXXMethod","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Engine::setPrintTensorStream(std::ostream &)","Filename":"poplar/Engine.hpp","Text":"void setPrintTensorStream ( std :: ostream & stream )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::Engine::getEngineOptions()","Filename":"poplar/Engine.hpp","Text":"OptionFlags getEngineOptions ( ) const"}
{"Token type":"CXXConstructor","FaliureReason":"unique_ptr_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Engine::Engine(std::unique_ptr<core::Engine>)","Filename":"poplar/Engine.hpp","Text":"Engine ( std :: unique_ptr < core :: Engine > )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Engine::getImpl()","Filename":"poplar/Engine.hpp","Text":"const core :: Engine & getImpl ( ) const"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::compileGraph(const poplar::Graph &, ArrayRef<program::Program>, const poplar::OptionFlags &, poplar::ProgressFunc)","Filename":"poplar/Engine.hpp","Text":"Executable compileGraph ( const Graph & graph , ArrayRef < program :: Program > progs , const OptionFlags & opt = { } , ProgressFunc progressCallBack = ProgressFunc ( ) )"}
{"Token type":"FunctionDecl","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::compileGraph(poplar::Graph &&, ArrayRef<program::Program>, const poplar::OptionFlags &, poplar::ProgressFunc)","Filename":"poplar/Engine.hpp","Text":"Executable compileGraph ( Graph && graph , ArrayRef < program :: Program > progs , const OptionFlags & opt = { } , ProgressFunc progressCallBack = ProgressFunc ( ) )"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::ArrayRef<T>(std::nullptr_t)","Filename":"poplar/ArrayRef.hpp","Text":"ArrayRef ( std :: nullptr_t ) = delete"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::ArrayRef<T>()","Filename":"poplar/ArrayRef.hpp","Text":"constexpr ArrayRef ( ) : ptr ( nullptr ) , len ( 0 ) { }"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::ArrayRef<T>(const T *, std::size_t)","Filename":"poplar/ArrayRef.hpp","Text":"constexpr ArrayRef ( const T * p , std :: size_t size ) : ptr ( p ) , len ( size ) { }"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::ArrayRef<T>(const std::vector<T> &)","Filename":"poplar/ArrayRef.hpp","Text":"ArrayRef ( const std :: vector < T > & v )"}
{"Token type":"FunctionTemplate","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::ArrayRef<T>(const std::array<T, N> &)","Filename":"poplar/ArrayRef.hpp","Text":"template < std :: size_t N > constexpr ArrayRef ( const std :: array < T , N > & a ) : ArrayRef ( a . data ( ) , N ) { }"}
{"Token type":"FunctionTemplate","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::ArrayRef<T>(const T (&)[N])","Filename":"poplar/ArrayRef.hpp","Text":"template < std :: size_t N > constexpr ArrayRef ( const T ( & p ) [ N ] ) : ArrayRef ( p , N ) { }"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::ArrayRef<T>(const std::initializer_list<T> &)","Filename":"poplar/ArrayRef.hpp","Text":"constexpr ArrayRef ( const std :: initializer_list < T > & list ) : ArrayRef ( list . begin ( ) , list . size ( ) ) { }"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::ArrayRef<T>(const ArrayRef<T> &)","Filename":"poplar/ArrayRef.hpp","Text":"constexpr ArrayRef ( const ArrayRef & ) = default"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::data()","Filename":"poplar/ArrayRef.hpp","Text":"constexpr const T * data ( ) const { return ptr ; }"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::size()","Filename":"poplar/ArrayRef.hpp","Text":"constexpr std :: size_t size ( ) const { return len ; }"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::empty()","Filename":"poplar/ArrayRef.hpp","Text":"constexpr bool empty ( ) const { return len == 0 ; }"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::front()","Filename":"poplar/ArrayRef.hpp","Text":"const T & front ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::operator[](std::size_t)","Filename":"poplar/ArrayRef.hpp","Text":"const T & operator [ ] ( std :: size_t i ) const"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::begin()","Filename":"poplar/ArrayRef.hpp","Text":"const_iterator begin ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::end()","Filename":"poplar/ArrayRef.hpp","Text":"const_iterator end ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::cbegin()","Filename":"poplar/ArrayRef.hpp","Text":"const_iterator cbegin ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::cend()","Filename":"poplar/ArrayRef.hpp","Text":"const_iterator cend ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::cloneAsVector()","Filename":"poplar/ArrayRef.hpp","Text":"std :: vector < T > cloneAsVector ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::max_size()","Filename":"poplar/ArrayRef.hpp","Text":"std :: size_t max_size ( ) const"}
{"Token type":"FunctionTemplate","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::operator==(const ArrayRef<T> &, const ArrayRef<T> &)","Filename":"poplar/ArrayRef.hpp","Text":"template < class T > inline bool operator == ( const ArrayRef < T > & l , const ArrayRef < T > & r )"}
{"Token type":"FunctionTemplate","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::operator!=(const ArrayRef<T> &, const ArrayRef<T> &)","Filename":"poplar/ArrayRef.hpp","Text":"template < class T > inline bool operator != ( const ArrayRef < T > & l , const ArrayRef < T > & r )"}
{"Token type":"StructDecl","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef","Filename":"poplar/StringRef.hpp","Text":"struct StringRef : public ArrayRef < char > { constexpr StringRef ( ) : ArrayRef ( nullptr , 0 ) { } constexpr StringRef ( const StringRef & ) = default ; StringRef ( std :: nullptr_t ) = delete ; StringRef ( const std :: string & s ) : ArrayRef ( s . data ( ) , s . size ( ) ) { } constexpr StringRef ( const char * p , std :: size_t len ) : ArrayRef ( p , len ) { } StringRef ( const char * p ) : ArrayRef ( p , std :: strlen ( p ) ) { } // String literal will always be null terminated hence N-1: template < std :: size_t N > constexpr StringRef ( const char ( & p ) [ N ] ) : ArrayRef ( p , N - 1 ) { } std :: string cloneAsString ( ) const { return std :: string ( begin ( ) , size ( ) ) ; } operator std :: string ( ) const { return cloneAsString ( ) ; } }"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef::StringRef()","Filename":"poplar/StringRef.hpp","Text":"constexpr StringRef ( ) : ArrayRef ( nullptr , 0 ) { }"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef::StringRef(const poplar::StringRef &)","Filename":"poplar/StringRef.hpp","Text":"constexpr StringRef ( const StringRef & ) = default"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef::StringRef(std::nullptr_t)","Filename":"poplar/StringRef.hpp","Text":"StringRef ( std :: nullptr_t ) = delete"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef::StringRef(const std::string &)","Filename":"poplar/StringRef.hpp","Text":"StringRef ( const std :: string & s )"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef::StringRef(const char *, std::size_t)","Filename":"poplar/StringRef.hpp","Text":"constexpr StringRef ( const char * p , std :: size_t len ) : ArrayRef ( p , len ) { }"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef::StringRef(const char *)","Filename":"poplar/StringRef.hpp","Text":"StringRef ( const char * p )"}
{"Token type":"FunctionTemplate","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef::StringRef(const char (&)[N])","Filename":"poplar/StringRef.hpp","Text":"template < std :: size_t N > constexpr StringRef ( const char ( & p ) [ N ] ) : ArrayRef ( p , N - 1 ) { }"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef::cloneAsString()","Filename":"poplar/StringRef.hpp","Text":"std :: string cloneAsString ( ) const"}
{"Token type":"FunctionDecl","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::operator==(poplar::StringRef, poplar::StringRef)","Filename":"poplar/StringRef.hpp","Text":"inline bool operator == ( StringRef l , StringRef r )"}
{"Token type":"FunctionDecl","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::operator!=(poplar::StringRef, poplar::StringRef)","Filename":"poplar/StringRef.hpp","Text":"inline bool operator != ( StringRef l , StringRef r )"}
{"Token type":"FunctionDecl","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<(poplar::StringRef, poplar::StringRef)","Filename":"poplar/StringRef.hpp","Text":"inline bool operator < ( StringRef l , StringRef r )"}
{"Token type":"FunctionDecl","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::operator+(poplar::StringRef, poplar::StringRef)","Filename":"poplar/StringRef.hpp","Text":"inline std :: string operator + ( StringRef l , StringRef r )"}
{"Token type":"FunctionDecl","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::operator+=(std::string &, poplar::StringRef)","Filename":"poplar/StringRef.hpp","Text":"inline std :: string & operator += ( std :: string & s , StringRef r )"}
{"Token type":"FunctionDecl","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<<(std::ostream &, const poplar::StringRef &)","Filename":"poplar/StringRef.hpp","Text":"inline std :: ostream & operator << ( std :: ostream & os , const StringRef & s )"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::Type","Filename":"poplar/Type.hpp","Text":"class Type"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::Type()","Filename":"poplar/Type.hpp","Text":"Type ( )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::Type(poplar::Type &&)","Filename":"poplar/Type.hpp","Text":"Type ( Type && other )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::operator=(const poplar::Type &)","Filename":"poplar/Type.hpp","Text":"Type & operator = ( const Type & other )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::operator=(poplar::Type &&)","Filename":"poplar/Type.hpp","Text":"Type & operator = ( Type && other )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::operator==(const poplar::Type &)","Filename":"poplar/Type.hpp","Text":"bool operator == ( const Type & other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::operator!=(const poplar::Type &)","Filename":"poplar/Type.hpp","Text":"bool operator != ( const Type & other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::operator<(const poplar::Type &)","Filename":"poplar/Type.hpp","Text":"bool operator < ( const Type & other ) const"}
{"Token type":"CXXConstructor","FaliureReason":"unique_ptr_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::Type(std::unique_ptr<core::Type>)","Filename":"poplar/Type.hpp","Text":"Type ( std :: unique_ptr < core :: Type > )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::getImpl()","Filename":"poplar/Type.hpp","Text":"const core :: Type & getImpl ( ) const"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<<(std::ostream &, const poplar::Type &)","Filename":"poplar/Type.hpp","Text":"inline std :: ostream & operator << ( std :: ostream & os , const Type & t )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<bool>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( bool , BOOL )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<char>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( char , CHAR )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<unsigned char>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( unsigned char , UNSIGNED_CHAR )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<signed char>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( signed char , SIGNED_CHAR )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<unsigned short>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( unsigned short , UNSIGNED_SHORT )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<short>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( signed short , SHORT )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<unsigned int>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( unsigned int , UNSIGNED_INT )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<int>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( signed int , INT )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<unsigned long>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( unsigned long , UNSIGNED_LONG )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<long>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( signed long , LONG )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<unsigned long long>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( unsigned long long , UNSIGNED_LONGLONG )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<long long>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( signed long long , LONGLONG )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<float>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( float , FLOAT )"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::DataStreamRef","Filename":"poplar/DataStream.hpp","Text":"class DataStreamRef"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::RemoteBufferRef","Filename":"poplar/DataStream.hpp","Text":"class RemoteBufferRef"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::DataStream::DataStream()","Filename":"poplar/DataStream.hpp","Text":"DataStream ( )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::DataStream::DataStream(poplar::DataStream &&)","Filename":"poplar/DataStream.hpp","Text":"DataStream ( DataStream && )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::DataStream::operator=(const poplar::DataStream &)","Filename":"poplar/DataStream.hpp","Text":"DataStream & operator = ( const DataStream & )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::DataStream::operator=(poplar::DataStream &&)","Filename":"poplar/DataStream.hpp","Text":"DataStream & operator = ( DataStream && )"}
{"Token type":"CXXConstructor","FaliureReason":"unique_ptr_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::DataStream::DataStream(std::unique_ptr<core::DataStreamRef>)","Filename":"poplar/DataStream.hpp","Text":"DataStream ( std :: unique_ptr < core :: DataStreamRef > )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::DataStream::getImpl()","Filename":"poplar/DataStream.hpp","Text":"const core :: DataStreamRef & getImpl ( ) const"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::RemoteBuffer::RemoteBuffer()","Filename":"poplar/DataStream.hpp","Text":"RemoteBuffer ( )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::RemoteBuffer::RemoteBuffer(poplar::RemoteBuffer &&)","Filename":"poplar/DataStream.hpp","Text":"RemoteBuffer ( RemoteBuffer && )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::RemoteBuffer::operator=(const poplar::RemoteBuffer &)","Filename":"poplar/DataStream.hpp","Text":"RemoteBuffer & operator = ( const RemoteBuffer & )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::RemoteBuffer::operator=(poplar::RemoteBuffer &&)","Filename":"poplar/DataStream.hpp","Text":"RemoteBuffer & operator = ( RemoteBuffer && )"}
{"Token type":"CXXConstructor","FaliureReason":"unique_ptr_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::RemoteBuffer::RemoteBuffer(std::unique_ptr<core::RemoteBufferRef>)","Filename":"poplar/DataStream.hpp","Text":"RemoteBuffer ( std :: unique_ptr < core :: RemoteBufferRef > )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::RemoteBuffer::getImpl()","Filename":"poplar/DataStream.hpp","Text":"const core :: RemoteBufferRef & getImpl ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::RemoteBuffer::operator==(const poplar::RemoteBuffer &)","Filename":"poplar/DataStream.hpp","Text":"bool operator == ( const RemoteBuffer & b ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::RemoteBuffer::operator!=(const poplar::RemoteBuffer &)","Filename":"poplar/DataStream.hpp","Text":"bool operator != ( const RemoteBuffer & b ) const"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::OptionFlags","Filename":"poplar/OptionFlags.hpp","Text":"class OptionFlags"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::OptionFlagsIterator","Filename":"poplar/OptionFlags.hpp","Text":"class OptionFlagsIterator"}
{"Token type":"CXXConstructor","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::iterator(std::unique_ptr<core::OptionFlagsIterator> &&)","Filename":"poplar/OptionFlags.hpp","Text":"iterator ( std :: unique_ptr < core :: OptionFlagsIterator > && p ) noexcept"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::operator=(const poplar::OptionFlags::iterator &)","Filename":"poplar/OptionFlags.hpp","Text":"iterator & operator = ( const iterator & other )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::iterator(poplar::OptionFlags::iterator &&)","Filename":"poplar/OptionFlags.hpp","Text":"iterator ( iterator && other ) noexcept"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::operator=(poplar::OptionFlags::iterator &&)","Filename":"poplar/OptionFlags.hpp","Text":"iterator & operator = ( iterator && other ) noexcept"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::operator*()","Filename":"poplar/OptionFlags.hpp","Text":"const OptionFlag & operator * ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::operator->()","Filename":"poplar/OptionFlags.hpp","Text":"const OptionFlag * operator -> ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::operator==(const poplar::OptionFlags::iterator &)","Filename":"poplar/OptionFlags.hpp","Text":"bool operator == ( const iterator & other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::operator!=(const poplar::OptionFlags::iterator &)","Filename":"poplar/OptionFlags.hpp","Text":"bool operator != ( const iterator & other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::operator++()","Filename":"poplar/OptionFlags.hpp","Text":"iterator & operator ++ ( )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::operator++(int)","Filename":"poplar/OptionFlags.hpp","Text":"iterator operator ++ ( int )"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::OptionFlags()","Filename":"poplar/OptionFlags.hpp","Text":"OptionFlags ( )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::OptionFlags(poplar::OptionFlags &&)","Filename":"poplar/OptionFlags.hpp","Text":"OptionFlags ( OptionFlags && other )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::operator=(const poplar::OptionFlags &)","Filename":"poplar/OptionFlags.hpp","Text":"OptionFlags & operator = ( const OptionFlags & other )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::operator=(poplar::OptionFlags &&)","Filename":"poplar/OptionFlags.hpp","Text":"OptionFlags & operator = ( OptionFlags && other )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::operator==(const poplar::OptionFlags &)","Filename":"poplar/OptionFlags.hpp","Text":"bool operator == ( const OptionFlags & other ) const"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::OptionFlags(poplar::OptionFlags::initializer_list &&)","Filename":"poplar/OptionFlags.hpp","Text":"OptionFlags ( initializer_list && list )"}
{"Token type":"CXXMethod","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::set(poplar::OptionFlags::initializer_list &&)","Filename":"poplar/OptionFlags.hpp","Text":"void set ( initializer_list && list )"}
{"Token type":"FunctionDecl","FaliureReason":"istream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::readJSON(std::istream &, poplar::OptionFlags &)","Filename":"poplar/OptionFlags.hpp","Text":"void readJSON ( std :: istream & stream , OptionFlags & flags )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::GlobalExchangeFlow::operator==(const poplar::GlobalExchangeFlow &)","Filename":"poplar/GlobalExchangeConstraints.hpp","Text":"bool operator == ( const GlobalExchangeFlow & other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::GlobalExchangeFlow::operator<(const poplar::GlobalExchangeFlow &)","Filename":"poplar/GlobalExchangeConstraints.hpp","Text":"bool operator < ( const GlobalExchangeFlow & other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::GlobalExchangeConstraint::operator==(const poplar::GlobalExchangeConstraint &)","Filename":"poplar/GlobalExchangeConstraints.hpp","Text":"bool operator == ( const GlobalExchangeConstraint & other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::GlobalExchangeConstraint::operator<(const poplar::GlobalExchangeConstraint &)","Filename":"poplar/GlobalExchangeConstraints.hpp","Text":"bool operator < ( const GlobalExchangeConstraint & other ) const"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<<(std::ostream &, poplar::IpuLinkConfiguration)","Filename":"poplar/IpuLinkConfiguration.hpp","Text":"std :: ostream & operator << ( std :: ostream & os , IpuLinkConfiguration ic )"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<<(std::ostream &, poplar::IpuLinkTopology)","Filename":"poplar/IpuLinkTopology.hpp","Text":"std :: ostream & operator << ( std :: ostream & os , IpuLinkTopology topo )"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::Target","Filename":"poplar/Target.hpp","Text":"class Target"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::Target()","Filename":"poplar/Target.hpp","Text":"Target ( )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::Target(poplar::Target &&)","Filename":"poplar/Target.hpp","Text":"Target ( Target && )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::operator=(const poplar::Target &)","Filename":"poplar/Target.hpp","Text":"Target & operator = ( const Target & )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::operator=(poplar::Target &&)","Filename":"poplar/Target.hpp","Text":"Target & operator = ( Target && )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::operator==(const poplar::Target &)","Filename":"poplar/Target.hpp","Text":"bool operator == ( const Target & ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::operator!=(const poplar::Target &)","Filename":"poplar/Target.hpp","Text":"bool operator != ( const Target & ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::operator<(const poplar::Target &)","Filename":"poplar/Target.hpp","Text":"bool operator < ( const Target & ) const"}
{"Token type":"CXXConstructor","FaliureReason":"unique_ptr_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::Target(std::unique_ptr<core::Target>)","Filename":"poplar/Target.hpp","Text":"Target ( std :: unique_ptr < core :: Target > )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::getImpl()","Filename":"poplar/Target.hpp","Text":"core :: Target & getImpl ( ) const"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::Device","Filename":"poplar/Device.hpp","Text":"class Device"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::Device::Device()","Filename":"poplar/Device.hpp","Text":"Device ( )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Device::Device(poplar::Device &&)","Filename":"poplar/Device.hpp","Text":"Device ( Device && )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Device::operator=(poplar::Device &&)","Filename":"poplar/Device.hpp","Text":"Device & operator = ( Device && )"}
{"Token type":"CXXConstructor","FaliureReason":"deleted_method","Implemented":false,"Namespace":"poplar","Name":"poplar::Device::Device(const poplar::Device &)","Filename":"poplar/Device.hpp","Text":"Device ( const Device & ) = delete"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Device::operator=(const poplar::Device &)","Filename":"poplar/Device.hpp","Text":"Device & operator = ( const Device & ) = delete"}
{"Token type":"CXXConstructor","FaliureReason":"unique_ptr_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Device::Device(std::unique_ptr<core::Device>)","Filename":"poplar/Device.hpp","Text":"Device ( std :: unique_ptr < core :: Device > )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Device::getImpl()","Filename":"poplar/Device.hpp","Text":"core :: Device & getImpl ( ) const"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::Executable","Filename":"poplar/Executable.hpp","Text":"class Executable"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Executable::Executable(poplar::Executable &&)","Filename":"poplar/Executable.hpp","Text":"Executable ( Executable && other )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Executable::operator=(poplar::Executable &&)","Filename":"poplar/Executable.hpp","Text":"Executable & operator = ( Executable && other )"}
{"Token type":"CXXMethod","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Executable::serialize(std::ostream &)","Filename":"poplar/Executable.hpp","Text":"void serialize ( std :: ostream & out ) const"}
{"Token type":"CXXMethod","FaliureReason":"istream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Executable::deserialize(std::istream &)","Filename":"poplar/Executable.hpp","Text":"static Executable deserialize ( std :: istream & in )"}
{"Token type":"CXXConstructor","FaliureReason":"unique_ptr_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Executable::Executable(std::unique_ptr<core::Executable>)","Filename":"poplar/Executable.hpp","Text":"explicit Executable ( std :: unique_ptr < core :: Executable > impl )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Executable::getImpl()","Filename":"poplar/Executable.hpp","Text":"const core :: Executable & getImpl ( ) const"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::GraphBuilder","Filename":"poplar/GraphElements.hpp","Text":"class GraphBuilder"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::VertexRef::VertexRef()","Filename":"poplar/GraphElements.hpp","Text":"VertexRef ( )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::VertexRef::operator[](poplar::StringRef)","Filename":"poplar/GraphElements.hpp","Text":"FieldRef operator [ ] ( StringRef fieldName ) const"}
{"Token type":"CXXConstructor","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::VertexRef::VertexRef(const core::GraphBuilder *, unsigned int)","Filename":"poplar/GraphElements.hpp","Text":"VertexRef ( const core :: GraphBuilder * graph , unsigned id )"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldRef::FieldRef()","Filename":"poplar/GraphElements.hpp","Text":"FieldRef ( )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldRef::operator[](std::size_t)","Filename":"poplar/GraphElements.hpp","Text":"FieldRef operator [ ] ( std :: size_t index ) const"}
{"Token type":"CXXConstructor","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldRef::FieldRef(poplar::VertexRef, poplar::StringRef)","Filename":"poplar/GraphElements.hpp","Text":"FieldRef ( VertexRef vertex , StringRef fieldName )"}
{"Token type":"CXXConstructor","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldRef::FieldRef(poplar::VertexRef, unsigned int)","Filename":"poplar/GraphElements.hpp","Text":"FieldRef ( VertexRef vertex , unsigned fieldId )"}
{"Token type":"CXXConstructor","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldRef::FieldRef(poplar::VertexRef, poplar::StringRef, std::size_t)","Filename":"poplar/GraphElements.hpp","Text":"FieldRef ( VertexRef vertex , StringRef fieldName , std :: size_t index )"}
{"Token type":"CXXConstructor","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldRef::FieldRef(poplar::VertexRef, unsigned int, std::size_t)","Filename":"poplar/GraphElements.hpp","Text":"FieldRef ( VertexRef vertex , unsigned fieldId , std :: size_t index )"}
{"Token type":"CXXMethod","FaliureReason":"constructor_missing_class","Implemented":false,"Namespace":"poplar","Name":"poplar::operator[](poplar::StringRef)","Filename":"poplar/GraphElements.hpp","Text":"inline FieldRef VertexRef :: operator [ ] ( StringRef fieldName ) const"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::ComputeSet::ComputeSet()","Filename":"poplar/GraphElements.hpp","Text":"ComputeSet ( )"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::Function::Function()","Filename":"poplar/GraphElements.hpp","Text":"Function ( )"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::MutableProfileValue","Filename":"poplar/ProfileValue.hpp","Text":"class MutableProfileValue"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::operator[](poplar::StringRef)","Filename":"poplar/ProfileValue.hpp","Text":"const ProfileValue & operator [ ] ( StringRef s ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::operator[](std::size_t)","Filename":"poplar/ProfileValue.hpp","Text":"const ProfileValue & operator [ ] ( std :: size_t i ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::operator==(const poplar::ProfileValue &)","Filename":"poplar/ProfileValue.hpp","Text":"bool operator == ( const ProfileValue & other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::operator!=(const poplar::ProfileValue &)","Filename":"poplar/ProfileValue.hpp","Text":"bool operator != ( const ProfileValue & other ) const"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::ProfileValue()","Filename":"poplar/ProfileValue.hpp","Text":"ProfileValue ( )"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::ProfileValue(T)","Filename":"poplar/ProfileValue.hpp","Text":"template < class T , typename = typename std :: enable_if < std :: is_integral < T > :: value > :: type > ProfileValue ( T init )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::ProfileValue(poplar::ProfileValue &&)","Filename":"poplar/ProfileValue.hpp","Text":"ProfileValue ( ProfileValue && other ) noexcept"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::operator=(const poplar::ProfileValue &)","Filename":"poplar/ProfileValue.hpp","Text":"ProfileValue & operator = ( const ProfileValue & other )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::operator=(poplar::ProfileValue &&)","Filename":"poplar/ProfileValue.hpp","Text":"ProfileValue & operator = ( ProfileValue && other ) noexcept"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::operator=(poplar::ProfileValue::Boolean)","Filename":"poplar/ProfileValue.hpp","Text":"ProfileValue & operator = ( Boolean init )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::operator=(poplar::ProfileValue::Number)","Filename":"poplar/ProfileValue.hpp","Text":"ProfileValue & operator = ( Number init )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::operator=(poplar::ProfileValue::String)","Filename":"poplar/ProfileValue.hpp","Text":"ProfileValue & operator = ( String init )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::operator=(poplar::ProfileValue::Vector)","Filename":"poplar/ProfileValue.hpp","Text":"ProfileValue & operator = ( Vector init )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::operator=(poplar::ProfileValue::Map)","Filename":"poplar/ProfileValue.hpp","Text":"ProfileValue & operator = ( Map init )"}
{"Token type":"FunctionTemplate","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::operator=(T)","Filename":"poplar/ProfileValue.hpp","Text":"template < class T , typename = typename std :: enable_if < std :: is_integral < T > :: value > :: type > ProfileValue & operator = ( T init )"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::serializeToJSON(std::ostream &, const poplar::ProfileValue &, bool)","Filename":"poplar/ProfileValue.hpp","Text":"void serializeToJSON ( std :: ostream & out , const ProfileValue & val , bool prettyPrint = false )"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::serializeToCBOR(std::ostream &, const poplar::ProfileValue &, bool)","Filename":"poplar/ProfileValue.hpp","Text":"void serializeToCBOR ( std :: ostream & out , const ProfileValue & val , bool withTag = true )"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<<(std::ostream &, const poplar::ProfileValue &)","Filename":"poplar/ProfileValue.hpp","Text":"std :: ostream & operator << ( std :: ostream & os , const ProfileValue & v )"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::printGraphSummary(std::ostream &, const poplar::ProfileValue &, const poplar::OptionFlags &)","Filename":"poplar/ProfileValue.hpp","Text":"void printGraphSummary ( std :: ostream & out , const ProfileValue & graphProfile , const OptionFlags & opts )"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::printExecutionSummary(std::ostream &, const poplar::ProfileValue &, const poplar::ProfileValue &, const poplar::OptionFlags &)","Filename":"poplar/ProfileValue.hpp","Text":"void printExecutionSummary ( std :: ostream & out , const ProfileValue & graphProfile , const ProfileValue & executionProfile , const OptionFlags & opts )"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::printProfileSummary(std::ostream &, const poplar::ProfileValue &, const poplar::ProfileValue &, const poplar::OptionFlags &)","Filename":"poplar/ProfileValue.hpp","Text":"void printProfileSummary ( std :: ostream & out , const ProfileValue & graphProfile , const ProfileValue & executionProfile , const OptionFlags & opts = { } )"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::profiling_disabled::profiling_disabled()","Filename":"poplar/exceptions.hpp","Text":"profiling_disabled ( )"}
{"Token type":"CXXConstructor","FaliureReason":"constructor_missing_class","Implemented":false,"Namespace":"poplar","Name":"poplar::GenericInterval<T>::GenericInterval<T>()","Filename":"poplar/Interval.hpp","Text":"GenericInterval ( ) = default"}
{"Token type":"CXXConstructor","FaliureReason":"constructor_missing_class","Implemented":false,"Namespace":"poplar","Name":"poplar::GenericInterval<T>::GenericInterval<T>(T, T)","Filename":"poplar/Interval.hpp","Text":"GenericInterval ( T begin , T end )"}
{"Token type":"CXXMethod","FaliureReason":"constructor_missing_class","Implemented":false,"Namespace":"poplar","Name":"poplar::GenericInterval<T>::begin()","Filename":"poplar/Interval.hpp","Text":"const T & begin ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"constructor_missing_class","Implemented":false,"Namespace":"poplar","Name":"poplar::GenericInterval<T>::end()","Filename":"poplar/Interval.hpp","Text":"const T & end ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"constructor_missing_class","Implemented":false,"Namespace":"poplar","Name":"poplar::GenericInterval<T>::size()","Filename":"poplar/Interval.hpp","Text":"T size ( ) const"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::operator==(const GenericInterval<T> &, const GenericInterval<T> &)","Filename":"poplar/Interval.hpp","Text":"template < class T > inline bool operator == ( const GenericInterval < T > & a , const GenericInterval < T > & b )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<(const GenericInterval<T> &, const GenericInterval<T> &)","Filename":"poplar/Interval.hpp","Text":"template < class T > inline bool operator < ( const GenericInterval < T > & a , const GenericInterval < T > & b )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::operator!=(const GenericInterval<T> &, const GenericInterval<T> &)","Filename":"poplar/Interval.hpp","Text":"template < class T > inline bool operator != ( const GenericInterval < T > & a , const GenericInterval < T > & b )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::operator>=(const GenericInterval<T> &, const GenericInterval<T> &)","Filename":"poplar/Interval.hpp","Text":"template < class T > inline bool operator >= ( const GenericInterval < T > & a , const GenericInterval < T > & b )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::operator>(const GenericInterval<T> &, const GenericInterval<T> &)","Filename":"poplar/Interval.hpp","Text":"template < class T > inline bool operator > ( const GenericInterval < T > & a , const GenericInterval < T > & b )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<=(const GenericInterval<T> &, const GenericInterval<T> &)","Filename":"poplar/Interval.hpp","Text":"template < class T > inline bool operator <= ( const GenericInterval < T > & a , const GenericInterval < T > & b )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<<(std::ostream &, const GenericInterval<T> &)","Filename":"poplar/Interval.hpp","Text":"template < class T > inline std :: ostream & operator << ( std :: ostream & os , const GenericInterval < T > & b )"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::SourceLocation::SourceLocation()","Filename":"poplar/DebugContext.hpp","Text":"SourceLocation ( ) = default"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::DebugInfo","Filename":"poplar/DebugContext.hpp","Text":"class DebugInfo"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::DebugInfo::operator=(const poplar::DebugInfo &)","Filename":"poplar/DebugContext.hpp","Text":"DebugInfo & operator = ( const DebugInfo & ) = delete"}
{"Token type":"CXXConstructor","FaliureReason":"deleted_method","Implemented":false,"Namespace":"poplar","Name":"poplar::DebugInfo::DebugInfo(const poplar::DebugInfo &)","Filename":"poplar/DebugContext.hpp","Text":"DebugInfo ( const DebugInfo & ) = delete"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::DebugInfo::getImpl()","Filename":"poplar/DebugContext.hpp","Text":"core :: DebugInfo & getImpl ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::DebugInfo::setValue(std::string, poplar::ProfileValue)","Filename":"poplar/DebugContext.hpp","Text":"bool setValue ( std :: string name , ProfileValue value )"}
{"Token type":"StructDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::DebugContext","Filename":"poplar/DebugContext.hpp","Text":"struct DebugContext"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::DebugContext::DebugContext(poplar::DebugContext &&)","Filename":"poplar/DebugContext.hpp","Text":"DebugContext ( DebugContext && )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::DebugContext::getImpl()","Filename":"poplar/DebugContext.hpp","Text":"core :: DebugContext & getImpl ( ) const"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar","Name":"poplar::IeeeHalf","Filename":"poplar/TypeTraits.hpp","Text":"class IeeeHalf"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::TypeTraits::make()","Filename":"poplar/TypeTraits.hpp","Text":"template < typename T > static TypeTraits make ( )"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::TypeTraits::isSimpleType()","Filename":"poplar/TypeTraits.hpp","Text":"template < typename T > static constexpr bool isSimpleType ( )"}
{"Token type":"FunctionTemplate","FaliureReason":"constructor_missing_class","Implemented":false,"Namespace":"poplar","Name":"poplar::make()","Filename":"poplar/TypeTraits.hpp","Text":"template < typename T > TypeTraits TypeTraits :: make ( )"}
{"Token type":"CXXMethod","FaliureReason":"constructor_missing_class","Implemented":false,"Namespace":"poplar","Name":"poplar::make<>()","Filename":"poplar/TypeTraits.hpp","Text":"template < > inline TypeTraits TypeTraits :: make < IeeeHalf > ( )"}
{"Token type":"FunctionTemplate","FaliureReason":"constructor_missing_class","Implemented":false,"Namespace":"poplar","Name":"poplar::isSimpleType()","Filename":"poplar/TypeTraits.hpp","Text":"template < typename T > constexpr bool TypeTraits :: isSimpleType ( ) { return std :: is_integral < T > :: value || std :: is_floating_point < T > :: value ; }"}
{"Token type":"CXXMethod","FaliureReason":"constructor_missing_class","Implemented":false,"Namespace":"poplar","Name":"poplar::isSimpleType<>()","Filename":"poplar/TypeTraits.hpp","Text":"template < > constexpr bool TypeTraits :: isSimpleType < IeeeHalf > ( ) { return true ; }"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::Tensor","Filename":"poplar/Tensor.hpp","Text":"class Tensor"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::Tensor()","Filename":"poplar/Tensor.hpp","Text":"Tensor ( )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::Tensor(poplar::Tensor &&)","Filename":"poplar/Tensor.hpp","Text":"Tensor ( Tensor && other )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::operator=(const poplar::Tensor &)","Filename":"poplar/Tensor.hpp","Text":"const Tensor & operator = ( const Tensor & other ) &"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::operator=(poplar::Tensor &&)","Filename":"poplar/Tensor.hpp","Text":"Tensor & operator = ( Tensor && other ) &"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::operator[](std::size_t)","Filename":"poplar/Tensor.hpp","Text":"Tensor operator [ ] ( std :: size_t i ) const &"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::operator[](std::size_t)","Filename":"poplar/Tensor.hpp","Text":"Tensor && operator [ ] ( std :: size_t i ) &&"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::getConstantValue(T *)","Filename":"poplar/Tensor.hpp","Text":"template < typename T > bool getConstantValue ( T * val ) const"}
{"Token type":"CXXMethod","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::output(std::ostream &)","Filename":"poplar/Tensor.hpp","Text":"std :: ostream & output ( std :: ostream & os ) const"}
{"Token type":"CXXMethod","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::outputRegions(std::ostream &)","Filename":"poplar/Tensor.hpp","Text":"std :: ostream & outputRegions ( std :: ostream & os ) const"}
{"Token type":"CXXConstructor","FaliureReason":"unique_ptr_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::Tensor(std::unique_ptr<core::Tensor>)","Filename":"poplar/Tensor.hpp","Text":"Tensor ( std :: unique_ptr < core :: Tensor > )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::getImpl()","Filename":"poplar/Tensor.hpp","Text":"core :: Tensor & getImpl ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::getPImpl()","Filename":"poplar/Tensor.hpp","Text":"std :: unique_ptr < core :: Tensor > * getPImpl ( )"}
{"Token type":"CXXMethod","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::getConstantData(void *, const poplar::TypeTraits &)","Filename":"poplar/Tensor.hpp","Text":"bool getConstantData ( void * dst , const TypeTraits & traits ) const"}
{"Token type":"FunctionDecl","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::operator==(const poplar::Tensor &, const poplar::Tensor &)","Filename":"poplar/Tensor.hpp","Text":"bool operator == ( const Tensor & a , const Tensor & b )"}
{"Token type":"FunctionDecl","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::operator!=(const poplar::Tensor &, const poplar::Tensor &)","Filename":"poplar/Tensor.hpp","Text":"bool inline operator != ( const Tensor & a , const Tensor & b )"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<<(std::ostream &, const poplar::Tensor &)","Filename":"poplar/Tensor.hpp","Text":"std :: ostream & operator << ( std :: ostream & os , const Tensor & tensor )"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::ProgramImpl","Filename":"poplar/Program.hpp","Text":"class ProgramImpl"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Program::Program()","Filename":"poplar/Program.hpp","Text":"Program ( )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Program::Program(poplar::program::Program &&)","Filename":"poplar/Program.hpp","Text":"Program ( Program && p )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Program::operator=(const poplar::program::Program &)","Filename":"poplar/Program.hpp","Text":"Program & operator = ( const Program & p )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Program::operator=(poplar::program::Program &&)","Filename":"poplar/Program.hpp","Text":"Program & operator = ( Program && p )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Program::getImpl()","Filename":"poplar/Program.hpp","Text":"core :: ProgramImpl & getImpl ( ) const"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Sequence::add_many(const poplar::program::Program &, T &&...)","Filename":"poplar/Program.hpp","Text":"template < class ... T > void add_many ( const Program & first , T && ... rest )"}
{"Token type":"CXXMethod","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Sequence::add_many()","Filename":"poplar/Program.hpp","Text":"void add_many ( )"}
{"Token type":"CXXMethod","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Sequence::init()","Filename":"poplar/Program.hpp","Text":"void init ( )"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Sequence::Sequence()","Filename":"poplar/Program.hpp","Text":"Sequence ( )"}
{"Token type":"FunctionTemplate","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Sequence::Sequence(T &&...)","Filename":"poplar/Program.hpp","Text":"template < class ... T > Sequence ( T && ... args )"}
{"Token type":"CXXConstructor","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Switch::Switch(poplar::Tensor, const poplar::program::Program &, const bool)","Filename":"poplar/Program.hpp","Text":"Switch ( Tensor control , const Program & defaultCaseBody , const bool unreachableDefault )"}
{"Token type":"CXXConstructor","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Copy::Copy(const poplar::DataStream &, poplar::Tensor, bool, poplar::Tensor, size_t, bool, const poplar::OptionFlags &)","Filename":"poplar/Program.hpp","Text":"Copy ( const DataStream & stream , Tensor dst , bool rearrangeOnHost , Tensor offset , size_t repeats , bool optimiseMemory , const OptionFlags & options = { } )"}
{"Token type":"CXXConstructor","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Copy::Copy(poplar::Tensor, const poplar::DataStream &, bool, poplar::Tensor, size_t, bool, const poplar::OptionFlags &)","Filename":"poplar/Program.hpp","Text":"Copy ( Tensor src , const DataStream & stream , bool rearrangeOnHost , Tensor offset , size_t repeats , bool optimiseMemory , const OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::dumpProgram(const poplar::Graph &, const poplar::program::Program &, std::ostream &)","Filename":"poplar/Program.hpp","Text":"void dumpProgram ( const Graph & graph , const Program & program , std :: ostream & out )"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::VariableRef::VariableRef()","Filename":"poplar/VariableRef.hpp","Text":"VariableRef ( ) = default"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::VariableRef::VariableRef(poplar::VariableRef &&)","Filename":"poplar/VariableRef.hpp","Text":"VariableRef ( VariableRef && other ) = default"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::VariableRef::operator=(const poplar::VariableRef &)","Filename":"poplar/VariableRef.hpp","Text":"VariableRef & operator = ( const VariableRef & other ) = default"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::VariableRef::operator=(poplar::VariableRef &&)","Filename":"poplar/VariableRef.hpp","Text":"VariableRef & operator = ( VariableRef && other ) = default"}
{"Token type":"FunctionDecl","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::VariableRef::operator==(const poplar::VariableRef &, const poplar::VariableRef &)","Filename":"poplar/VariableRef.hpp","Text":"friend bool operator == ( const VariableRef & a , const VariableRef & b )"}
{"Token type":"FunctionDecl","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::VariableRef::operator<(const poplar::VariableRef &, const poplar::VariableRef &)","Filename":"poplar/VariableRef.hpp","Text":"friend bool operator < ( const VariableRef & a , const VariableRef & b )"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::VariableInterval::VariableInterval()","Filename":"poplar/VariableRef.hpp","Text":"VariableInterval ( ) = default"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::VariableInterval::VariableInterval(poplar::VariableInterval &&)","Filename":"poplar/VariableRef.hpp","Text":"VariableInterval ( VariableInterval && other ) = default"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::VariableInterval::operator=(const poplar::VariableInterval &)","Filename":"poplar/VariableRef.hpp","Text":"VariableInterval & operator = ( const VariableInterval & other ) = default"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::VariableInterval::operator=(poplar::VariableInterval &&)","Filename":"poplar/VariableRef.hpp","Text":"VariableInterval & operator = ( VariableInterval && other ) = default"}
{"Token type":"FunctionDecl","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::operator==(const poplar::VariableInterval &, const poplar::VariableInterval &)","Filename":"poplar/VariableRef.hpp","Text":"bool operator == ( const VariableInterval & a , const VariableInterval & b )"}
{"Token type":"FunctionDecl","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<(const poplar::VariableInterval &, const poplar::VariableInterval &)","Filename":"poplar/VariableRef.hpp","Text":"bool operator < ( const VariableInterval & a , const VariableInterval & b )"}
{"Token type":"StructDecl","FaliureReason":"not_allowed_namespace","Implemented":false,"Namespace":"std","Name":"std::hash<poplar::VariableRef>","Filename":"poplar/VariableRef.hpp","Text":"template < > struct hash < poplar :: VariableRef > { size_t operator ( ) ( const poplar :: VariableRef & v ) const { return v . hash ( ) ; } }"}
{"Token type":"CXXMethod","FaliureReason":"not_allowed_namespace","Implemented":false,"Namespace":"std","Name":"std::hash<poplar::VariableRef>::operator()(const poplar::VariableRef &)","Filename":"poplar/VariableRef.hpp","Text":"size_t operator ( ) ( const poplar :: VariableRef & v ) const"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar::layout","Name":"poplar::layout::operator<<(std::ostream &, const poplar::layout::Vector)","Filename":"poplar/VectorLayout.hpp","Text":"std :: ostream & operator << ( std :: ostream & os , const Vector v )"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar::layout","Name":"poplar::layout::operator<<(std::ostream &, const poplar::layout::VectorList)","Filename":"poplar/VectorLayout.hpp","Text":"std :: ostream & operator << ( std :: ostream & os , const VectorList v )"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::VertexIntrospector","Filename":"poplar/VertexIntrospector.hpp","Text":"class VertexIntrospector"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::FieldData","Filename":"poplar/VertexIntrospector.hpp","Text":"class FieldData"}
{"Token type":"CXXMethod","FaliureReason":"filedata_size_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldData::SizeT::size()","Filename":"poplar/VertexIntrospector.hpp","Text":"std :: size_t size ( ) const"}
{"Token type":"CXXConstructor","FaliureReason":"deleted_method","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldData::FieldData(const poplar::FieldData &)","Filename":"poplar/VertexIntrospector.hpp","Text":"FieldData ( const FieldData & ) = delete"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldData::FieldData(poplar::FieldData &&)","Filename":"poplar/VertexIntrospector.hpp","Text":"FieldData ( FieldData && )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldData::operator[](std::size_t)","Filename":"poplar/VertexIntrospector.hpp","Text":"SizeT operator [ ] ( std :: size_t i ) const"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldData::getInitialValue(const poplar::Target &)","Filename":"poplar/VertexIntrospector.hpp","Text":"template < typename T > T getInitialValue ( const Target & target ) const"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldData::getInitialValues(const poplar::Target &)","Filename":"poplar/VertexIntrospector.hpp","Text":"template < typename T > std :: vector < T > getInitialValues ( const Target & target ) const"}
{"Token type":"CXXConstructor","FaliureReason":"unique_ptr_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldData::FieldData(std::unique_ptr<core::FieldData>)","Filename":"poplar/VertexIntrospector.hpp","Text":"FieldData ( std :: unique_ptr < core :: FieldData > fd )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldData::getInitialValuesOverload(const poplar::Target &, std::vector<T> &)","Filename":"poplar/VertexIntrospector.hpp","Text":"template < typename T > void getInitialValuesOverload ( const Target & target , std :: vector < T > & result ) const"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldData::getInitialValuesOverload(const poplar::Target &, std::vector<std::vector<T> > &)","Filename":"poplar/VertexIntrospector.hpp","Text":"template < typename T > void getInitialValuesOverload ( const Target & target , std :: vector < std :: vector < T >> & result ) const"}
{"Token type":"CXXMethod","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldData::getInitialValues(const poplar::Target &, void *, const poplar::TypeTraits &, std::size_t)","Filename":"poplar/VertexIntrospector.hpp","Text":"void getInitialValues ( const Target & target , void * dst , const TypeTraits & traits , std :: size_t index = std :: numeric_limits < std :: size_t > :: max ( ) ) const"}
{"Token type":"CXXConstructor","FaliureReason":"unique_ptr_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::VertexIntrospector::VertexIntrospector(std::unique_ptr<core::VertexIntrospector>)","Filename":"poplar/VertexIntrospector.hpp","Text":"VertexIntrospector ( std :: unique_ptr < core :: VertexIntrospector > impl )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::VertexIntrospector::VertexIntrospector(poplar::VertexIntrospector &&)","Filename":"poplar/VertexIntrospector.hpp","Text":"VertexIntrospector ( VertexIntrospector && )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::VertexIntrospector::getImpl()","Filename":"poplar/VertexIntrospector.hpp","Text":"const core :: VertexIntrospector & getImpl ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::replication_factor::operator++()","Filename":"poplar/replication_factor.hpp","Text":"replication_factor & operator ++ ( )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::replication_factor::operator==(const poplar::replication_factor)","Filename":"poplar/replication_factor.hpp","Text":"bool operator == ( const replication_factor other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::replication_factor::operator!=(const poplar::replication_factor)","Filename":"poplar/replication_factor.hpp","Text":"bool operator != ( const replication_factor other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::replication_factor::operator<(const poplar::replication_factor)","Filename":"poplar/replication_factor.hpp","Text":"bool operator < ( const replication_factor other ) const"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::GraphBuilder","Filename":"poplar/Graph.hpp","Text":"class GraphBuilder"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::Graph(poplar::Graph &&)","Filename":"poplar/Graph.hpp","Text":"Graph ( Graph && )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::operator=(poplar::Graph &&)","Filename":"poplar/Graph.hpp","Text":"Graph & operator = ( Graph && )"}
{"Token type":"CXXMethod","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::addCodelets(poplar::StringRef, poplar::CodeletFileType, poplar::StringRef, std::ostream &)","Filename":"poplar/Graph.hpp","Text":"bool addCodelets ( StringRef src , CodeletFileType type , StringRef compileFlags , std :: ostream & compileOutput )"}
{"Token type":"CXXMethod","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::addCodelets(std::stringstream &, poplar::StringRef, std::ostream &)","Filename":"poplar/Graph.hpp","Text":"void addCodelets ( std :: stringstream & stream , StringRef compileFlags , std :: ostream & compileOutput )"}
{"Token type":"EnumDecl","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::ConnectionDesc::Kind","Filename":"poplar/Graph.hpp","Text":"enum class Kind { TensorEdge , ValueEdge , VectorTensorEdge }"}
{"Token type":"EnumConstantDecl","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::ConnectionDesc::Kind::TensorEdge","Filename":"poplar/Graph.hpp","Text":"TensorEdge"}
{"Token type":"EnumConstantDecl","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::ConnectionDesc::Kind::ValueEdge","Filename":"poplar/Graph.hpp","Text":"ValueEdge"}
{"Token type":"EnumConstantDecl","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::ConnectionDesc::Kind::VectorTensorEdge","Filename":"poplar/Graph.hpp","Text":"VectorTensorEdge"}
{"Token type":"CXXMethod","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::ConnectionDesc::connect(poplar::Graph &, const poplar::VertexRef &)","Filename":"poplar/Graph.hpp","Text":"void connect ( Graph & g , const VertexRef & v ) const"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::ConnectionDesc::ConnectionDesc(poplar::StringRef, T, typename std::enable_if<TypeTraits::isSimpleType<T>()>::type *)","Filename":"poplar/Graph.hpp","Text":"template < typename T > ConnectionDesc ( StringRef field , T v , typename std :: enable_if < TypeTraits :: isSimpleType < T > ( ) > :: type * = nullptr )"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::addConstant(const poplar::Type &, ArrayRef<std::size_t>, T, const poplar::DebugContext &, typename std::enable_if<TypeTraits::isSimpleType<T>()>::type *)","Filename":"poplar/Graph.hpp","Text":"template < typename T > Tensor addConstant ( const Type & type , ArrayRef < std :: size_t > shape , T val , const DebugContext & debugContext = { \"<const>\" } , typename std :: enable_if < TypeTraits :: isSimpleType < T > ( ) > :: type * = nullptr )"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::addConstant(const poplar::Type &, ArrayRef<std::size_t>, const T *, const poplar::DebugContext &, typename std::enable_if<TypeTraits::isSimpleType<T>()>::type *)","Filename":"poplar/Graph.hpp","Text":"template < typename T > Tensor addConstant ( const Type & type , ArrayRef < std :: size_t > shape , const T * val , const DebugContext & debugContext = { \"<const>\" } , typename std :: enable_if < TypeTraits :: isSimpleType < T > ( ) > :: type * = nullptr )"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::connect(poplar::FieldRef, T, typename std::enable_if<TypeTraits::isSimpleType<T>()>::type *)","Filename":"poplar/Graph.hpp","Text":"template < typename T > void connect ( FieldRef field , T v , typename std :: enable_if < TypeTraits :: isSimpleType < T > ( ) > :: type * = nullptr )"}
{"Token type":"CXXMethod","FaliureReason":"calls_deleted_function","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::registerCycleEstimator(poplar::StringRef, poplar::CycleEstimateFunc)","Filename":"poplar/Graph.hpp","Text":"void registerCycleEstimator ( StringRef vertexTypeName , CycleEstimateFunc f )"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::setInitialValue(poplar::FieldRef, T, typename std::enable_if<TypeTraits::isSimpleType<T>()>::type *)","Filename":"poplar/Graph.hpp","Text":"template < typename T > void setInitialValue ( FieldRef field , T val , typename std :: enable_if < TypeTraits :: isSimpleType < T > ( ) > :: type * = nullptr )"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::setInitCallback(poplar::FieldRef, LateInitCallback<T>, typename std::enable_if<std::is_arithmetic<T>::value>::type *)","Filename":"poplar/Graph.hpp","Text":"template < typename T > void setInitCallback ( FieldRef field , LateInitCallback < T > callback , typename std :: enable_if < std :: is_arithmetic < T > :: value > :: type * = nullptr )"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::setInitialValue(poplar::FieldRef, const std::vector<T> &)","Filename":"poplar/Graph.hpp","Text":"template < typename T > void setInitialValue ( FieldRef field , const std :: vector < T > & v )"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::setInitialValue(poplar::FieldRef, const std::initializer_list<T> &)","Filename":"poplar/Graph.hpp","Text":"template < typename T > void setInitialValue ( FieldRef field , const std :: initializer_list < T > & l )"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::setInitialValue(const poplar::Tensor &, T, typename std::enable_if<TypeTraits::isSimpleType<T>()>::type *)","Filename":"poplar/Graph.hpp","Text":"template < typename T > void setInitialValue ( const Tensor & t , T val , typename std :: enable_if < TypeTraits :: isSimpleType < T > ( ) > :: type * = nullptr )"}
{"Token type":"CXXMethod","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::outputVertexGraph(std::ostream &, ArrayRef<program::Program>)","Filename":"poplar/Graph.hpp","Text":"void outputVertexGraph ( std :: ostream & outputStream , ArrayRef < program :: Program > progs = { } ) const"}
{"Token type":"CXXMethod","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::outputComputeGraph(std::ostream &, ArrayRef<program::Program>)","Filename":"poplar/Graph.hpp","Text":"void outputComputeGraph ( std :: ostream & outputStream , ArrayRef < program :: Program > progs = { } ) const"}
{"Token type":"CXXMethod","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::serializeTensors(std::ostream &, ArrayRef<poplar::Tensor>, poplar::SerializationFormat)","Filename":"poplar/Graph.hpp","Text":"void serializeTensors ( std :: ostream & out , ArrayRef < Tensor > tensors , SerializationFormat format ) const"}
{"Token type":"CXXMethod","FaliureReason":"istream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::deserializeTensors(std::istream &, poplar::SerializationFormat)","Filename":"poplar/Graph.hpp","Text":"std :: vector < Tensor > deserializeTensors ( std :: istream & in , SerializationFormat format )"}
{"Token type":"CXXMethod","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::serialize(std::ostream &, poplar::SerializationFormat)","Filename":"poplar/Graph.hpp","Text":"void serialize ( std :: ostream & out , SerializationFormat format ) const"}
{"Token type":"CXXMethod","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::serialize(std::ostream &, ArrayRef<program::Program>, poplar::SerializationFormat)","Filename":"poplar/Graph.hpp","Text":"void serialize ( std :: ostream & out , ArrayRef < program :: Program > progs , SerializationFormat format ) const"}
{"Token type":"CXXConstructor","FaliureReason":"unique_ptr_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::Graph(std::unique_ptr<core::GraphBuilder>, poplar::Target)","Filename":"poplar/Graph.hpp","Text":"Graph ( std :: unique_ptr < core :: GraphBuilder > , Target target )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::getImpl()","Filename":"poplar/Graph.hpp","Text":"core :: GraphBuilder & getImpl ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::setInitialValue(poplar::FieldRef, const void *, const poplar::TypeTraits &)","Filename":"poplar/Graph.hpp","Text":"void setInitialValue ( FieldRef field , const void * val , const TypeTraits & )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::setInitCallback(poplar::FieldRef, LateInitCallback<T>, const poplar::TypeTraits &)","Filename":"poplar/Graph.hpp","Text":"template < typename T > void setInitCallback ( FieldRef field , LateInitCallback < T > callback , const TypeTraits & )"}
{"Token type":"CXXMethod","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::setInitialValue(const poplar::Tensor &, const void *, const poplar::TypeTraits &)","Filename":"poplar/Graph.hpp","Text":"void setInitialValue ( const Tensor & t , const void * val , const TypeTraits & )"}
{"Token type":"CXXMethod","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::connect(poplar::FieldRef, void *, const poplar::TypeTraits &)","Filename":"poplar/Graph.hpp","Text":"void connect ( FieldRef field , void * val , const TypeTraits & )"}
{"Token type":"CXXMethod","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::checkFieldSubgraph(const poplar::FieldRef &)","Filename":"poplar/Graph.hpp","Text":"void checkFieldSubgraph ( const FieldRef & f ) const"}
{"Token type":"CXXMethod","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::checkVertexSubgraph(const poplar::VertexRef &)","Filename":"poplar/Graph.hpp","Text":"void checkVertexSubgraph ( const VertexRef & v ) const"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::ArrayRef<T>(std::nullptr_t)","Filename":"poplar/ArrayRef.hpp","Text":"ArrayRef ( std :: nullptr_t ) = delete"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::ArrayRef<T>()","Filename":"poplar/ArrayRef.hpp","Text":"constexpr ArrayRef ( ) : ptr ( nullptr ) , len ( 0 ) { }"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::ArrayRef<T>(const T *, std::size_t)","Filename":"poplar/ArrayRef.hpp","Text":"constexpr ArrayRef ( const T * p , std :: size_t size ) : ptr ( p ) , len ( size ) { }"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::ArrayRef<T>(const std::vector<T> &)","Filename":"poplar/ArrayRef.hpp","Text":"ArrayRef ( const std :: vector < T > & v )"}
{"Token type":"FunctionTemplate","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::ArrayRef<T>(const std::array<T, N> &)","Filename":"poplar/ArrayRef.hpp","Text":"template < std :: size_t N > constexpr ArrayRef ( const std :: array < T , N > & a ) : ArrayRef ( a . data ( ) , N ) { }"}
{"Token type":"FunctionTemplate","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::ArrayRef<T>(const T (&)[N])","Filename":"poplar/ArrayRef.hpp","Text":"template < std :: size_t N > constexpr ArrayRef ( const T ( & p ) [ N ] ) : ArrayRef ( p , N ) { }"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::ArrayRef<T>(const std::initializer_list<T> &)","Filename":"poplar/ArrayRef.hpp","Text":"constexpr ArrayRef ( const std :: initializer_list < T > & list ) : ArrayRef ( list . begin ( ) , list . size ( ) ) { }"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::ArrayRef<T>(const ArrayRef<T> &)","Filename":"poplar/ArrayRef.hpp","Text":"constexpr ArrayRef ( const ArrayRef & ) = default"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::data()","Filename":"poplar/ArrayRef.hpp","Text":"constexpr const T * data ( ) const { return ptr ; }"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::size()","Filename":"poplar/ArrayRef.hpp","Text":"constexpr std :: size_t size ( ) const { return len ; }"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::empty()","Filename":"poplar/ArrayRef.hpp","Text":"constexpr bool empty ( ) const { return len == 0 ; }"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::front()","Filename":"poplar/ArrayRef.hpp","Text":"const T & front ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::operator[](std::size_t)","Filename":"poplar/ArrayRef.hpp","Text":"const T & operator [ ] ( std :: size_t i ) const"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::begin()","Filename":"poplar/ArrayRef.hpp","Text":"const_iterator begin ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::end()","Filename":"poplar/ArrayRef.hpp","Text":"const_iterator end ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::cbegin()","Filename":"poplar/ArrayRef.hpp","Text":"const_iterator cbegin ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::cend()","Filename":"poplar/ArrayRef.hpp","Text":"const_iterator cend ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::cloneAsVector()","Filename":"poplar/ArrayRef.hpp","Text":"std :: vector < T > cloneAsVector ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::max_size()","Filename":"poplar/ArrayRef.hpp","Text":"std :: size_t max_size ( ) const"}
{"Token type":"FunctionTemplate","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::operator==(const ArrayRef<T> &, const ArrayRef<T> &)","Filename":"poplar/ArrayRef.hpp","Text":"template < class T > inline bool operator == ( const ArrayRef < T > & l , const ArrayRef < T > & r )"}
{"Token type":"FunctionTemplate","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::operator!=(const ArrayRef<T> &, const ArrayRef<T> &)","Filename":"poplar/ArrayRef.hpp","Text":"template < class T > inline bool operator != ( const ArrayRef < T > & l , const ArrayRef < T > & r )"}
{"Token type":"StructDecl","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef","Filename":"poplar/StringRef.hpp","Text":"struct StringRef : public ArrayRef < char > { constexpr StringRef ( ) : ArrayRef ( nullptr , 0 ) { } constexpr StringRef ( const StringRef & ) = default ; StringRef ( std :: nullptr_t ) = delete ; StringRef ( const std :: string & s ) : ArrayRef ( s . data ( ) , s . size ( ) ) { } constexpr StringRef ( const char * p , std :: size_t len ) : ArrayRef ( p , len ) { } StringRef ( const char * p ) : ArrayRef ( p , std :: strlen ( p ) ) { } // String literal will always be null terminated hence N-1: template < std :: size_t N > constexpr StringRef ( const char ( & p ) [ N ] ) : ArrayRef ( p , N - 1 ) { } std :: string cloneAsString ( ) const { return std :: string ( begin ( ) , size ( ) ) ; } operator std :: string ( ) const { return cloneAsString ( ) ; } }"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef::StringRef()","Filename":"poplar/StringRef.hpp","Text":"constexpr StringRef ( ) : ArrayRef ( nullptr , 0 ) { }"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef::StringRef(const poplar::StringRef &)","Filename":"poplar/StringRef.hpp","Text":"constexpr StringRef ( const StringRef & ) = default"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef::StringRef(std::nullptr_t)","Filename":"poplar/StringRef.hpp","Text":"StringRef ( std :: nullptr_t ) = delete"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef::StringRef(const std::string &)","Filename":"poplar/StringRef.hpp","Text":"StringRef ( const std :: string & s )"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef::StringRef(const char *, std::size_t)","Filename":"poplar/StringRef.hpp","Text":"constexpr StringRef ( const char * p , std :: size_t len ) : ArrayRef ( p , len ) { }"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef::StringRef(const char *)","Filename":"poplar/StringRef.hpp","Text":"StringRef ( const char * p )"}
{"Token type":"FunctionTemplate","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef::StringRef(const char (&)[N])","Filename":"poplar/StringRef.hpp","Text":"template < std :: size_t N > constexpr StringRef ( const char ( & p ) [ N ] ) : ArrayRef ( p , N - 1 ) { }"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef::cloneAsString()","Filename":"poplar/StringRef.hpp","Text":"std :: string cloneAsString ( ) const"}
{"Token type":"FunctionDecl","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::operator==(poplar::StringRef, poplar::StringRef)","Filename":"poplar/StringRef.hpp","Text":"inline bool operator == ( StringRef l , StringRef r )"}
{"Token type":"FunctionDecl","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::operator!=(poplar::StringRef, poplar::StringRef)","Filename":"poplar/StringRef.hpp","Text":"inline bool operator != ( StringRef l , StringRef r )"}
{"Token type":"FunctionDecl","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<(poplar::StringRef, poplar::StringRef)","Filename":"poplar/StringRef.hpp","Text":"inline bool operator < ( StringRef l , StringRef r )"}
{"Token type":"FunctionDecl","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::operator+(poplar::StringRef, poplar::StringRef)","Filename":"poplar/StringRef.hpp","Text":"inline std :: string operator + ( StringRef l , StringRef r )"}
{"Token type":"FunctionDecl","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::operator+=(std::string &, poplar::StringRef)","Filename":"poplar/StringRef.hpp","Text":"inline std :: string & operator += ( std :: string & s , StringRef r )"}
{"Token type":"FunctionDecl","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<<(std::ostream &, const poplar::StringRef &)","Filename":"poplar/StringRef.hpp","Text":"inline std :: ostream & operator << ( std :: ostream & os , const StringRef & s )"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::OptionFlags","Filename":"poplar/OptionFlags.hpp","Text":"class OptionFlags"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::OptionFlagsIterator","Filename":"poplar/OptionFlags.hpp","Text":"class OptionFlagsIterator"}
{"Token type":"CXXConstructor","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::iterator(std::unique_ptr<core::OptionFlagsIterator> &&)","Filename":"poplar/OptionFlags.hpp","Text":"iterator ( std :: unique_ptr < core :: OptionFlagsIterator > && p ) noexcept"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::operator=(const poplar::OptionFlags::iterator &)","Filename":"poplar/OptionFlags.hpp","Text":"iterator & operator = ( const iterator & other )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::iterator(poplar::OptionFlags::iterator &&)","Filename":"poplar/OptionFlags.hpp","Text":"iterator ( iterator && other ) noexcept"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::operator=(poplar::OptionFlags::iterator &&)","Filename":"poplar/OptionFlags.hpp","Text":"iterator & operator = ( iterator && other ) noexcept"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::operator*()","Filename":"poplar/OptionFlags.hpp","Text":"const OptionFlag & operator * ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::operator->()","Filename":"poplar/OptionFlags.hpp","Text":"const OptionFlag * operator -> ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::operator==(const poplar::OptionFlags::iterator &)","Filename":"poplar/OptionFlags.hpp","Text":"bool operator == ( const iterator & other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::operator!=(const poplar::OptionFlags::iterator &)","Filename":"poplar/OptionFlags.hpp","Text":"bool operator != ( const iterator & other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::operator++()","Filename":"poplar/OptionFlags.hpp","Text":"iterator & operator ++ ( )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::operator++(int)","Filename":"poplar/OptionFlags.hpp","Text":"iterator operator ++ ( int )"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::OptionFlags()","Filename":"poplar/OptionFlags.hpp","Text":"OptionFlags ( )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::OptionFlags(poplar::OptionFlags &&)","Filename":"poplar/OptionFlags.hpp","Text":"OptionFlags ( OptionFlags && other )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::operator=(const poplar::OptionFlags &)","Filename":"poplar/OptionFlags.hpp","Text":"OptionFlags & operator = ( const OptionFlags & other )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::operator=(poplar::OptionFlags &&)","Filename":"poplar/OptionFlags.hpp","Text":"OptionFlags & operator = ( OptionFlags && other )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::operator==(const poplar::OptionFlags &)","Filename":"poplar/OptionFlags.hpp","Text":"bool operator == ( const OptionFlags & other ) const"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::OptionFlags(poplar::OptionFlags::initializer_list &&)","Filename":"poplar/OptionFlags.hpp","Text":"OptionFlags ( initializer_list && list )"}
{"Token type":"CXXMethod","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::set(poplar::OptionFlags::initializer_list &&)","Filename":"poplar/OptionFlags.hpp","Text":"void set ( initializer_list && list )"}
{"Token type":"FunctionDecl","FaliureReason":"istream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::readJSON(std::istream &, poplar::OptionFlags &)","Filename":"poplar/OptionFlags.hpp","Text":"void readJSON ( std :: istream & stream , OptionFlags & flags )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::GlobalExchangeFlow::operator==(const poplar::GlobalExchangeFlow &)","Filename":"poplar/GlobalExchangeConstraints.hpp","Text":"bool operator == ( const GlobalExchangeFlow & other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::GlobalExchangeFlow::operator<(const poplar::GlobalExchangeFlow &)","Filename":"poplar/GlobalExchangeConstraints.hpp","Text":"bool operator < ( const GlobalExchangeFlow & other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::GlobalExchangeConstraint::operator==(const poplar::GlobalExchangeConstraint &)","Filename":"poplar/GlobalExchangeConstraints.hpp","Text":"bool operator == ( const GlobalExchangeConstraint & other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::GlobalExchangeConstraint::operator<(const poplar::GlobalExchangeConstraint &)","Filename":"poplar/GlobalExchangeConstraints.hpp","Text":"bool operator < ( const GlobalExchangeConstraint & other ) const"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<<(std::ostream &, poplar::IpuLinkConfiguration)","Filename":"poplar/IpuLinkConfiguration.hpp","Text":"std :: ostream & operator << ( std :: ostream & os , IpuLinkConfiguration ic )"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<<(std::ostream &, poplar::IpuLinkTopology)","Filename":"poplar/IpuLinkTopology.hpp","Text":"std :: ostream & operator << ( std :: ostream & os , IpuLinkTopology topo )"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::Type","Filename":"poplar/Type.hpp","Text":"class Type"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::Type()","Filename":"poplar/Type.hpp","Text":"Type ( )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::Type(poplar::Type &&)","Filename":"poplar/Type.hpp","Text":"Type ( Type && other )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::operator=(const poplar::Type &)","Filename":"poplar/Type.hpp","Text":"Type & operator = ( const Type & other )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::operator=(poplar::Type &&)","Filename":"poplar/Type.hpp","Text":"Type & operator = ( Type && other )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::operator==(const poplar::Type &)","Filename":"poplar/Type.hpp","Text":"bool operator == ( const Type & other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::operator!=(const poplar::Type &)","Filename":"poplar/Type.hpp","Text":"bool operator != ( const Type & other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::operator<(const poplar::Type &)","Filename":"poplar/Type.hpp","Text":"bool operator < ( const Type & other ) const"}
{"Token type":"CXXConstructor","FaliureReason":"unique_ptr_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::Type(std::unique_ptr<core::Type>)","Filename":"poplar/Type.hpp","Text":"Type ( std :: unique_ptr < core :: Type > )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::getImpl()","Filename":"poplar/Type.hpp","Text":"const core :: Type & getImpl ( ) const"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<<(std::ostream &, const poplar::Type &)","Filename":"poplar/Type.hpp","Text":"inline std :: ostream & operator << ( std :: ostream & os , const Type & t )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<bool>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( bool , BOOL )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<char>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( char , CHAR )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<unsigned char>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( unsigned char , UNSIGNED_CHAR )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<signed char>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( signed char , SIGNED_CHAR )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<unsigned short>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( unsigned short , UNSIGNED_SHORT )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<short>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( signed short , SHORT )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<unsigned int>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( unsigned int , UNSIGNED_INT )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<int>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( signed int , INT )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<unsigned long>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( unsigned long , UNSIGNED_LONG )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<long>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( signed long , LONG )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<unsigned long long>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( unsigned long long , UNSIGNED_LONGLONG )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<long long>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( signed long long , LONGLONG )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<float>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( float , FLOAT )"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::Target","Filename":"poplar/Target.hpp","Text":"class Target"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::Target()","Filename":"poplar/Target.hpp","Text":"Target ( )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::Target(poplar::Target &&)","Filename":"poplar/Target.hpp","Text":"Target ( Target && )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::operator=(const poplar::Target &)","Filename":"poplar/Target.hpp","Text":"Target & operator = ( const Target & )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::operator=(poplar::Target &&)","Filename":"poplar/Target.hpp","Text":"Target & operator = ( Target && )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::operator==(const poplar::Target &)","Filename":"poplar/Target.hpp","Text":"bool operator == ( const Target & ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::operator!=(const poplar::Target &)","Filename":"poplar/Target.hpp","Text":"bool operator != ( const Target & ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::operator<(const poplar::Target &)","Filename":"poplar/Target.hpp","Text":"bool operator < ( const Target & ) const"}
{"Token type":"CXXConstructor","FaliureReason":"unique_ptr_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::Target(std::unique_ptr<core::Target>)","Filename":"poplar/Target.hpp","Text":"Target ( std :: unique_ptr < core :: Target > )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::getImpl()","Filename":"poplar/Target.hpp","Text":"core :: Target & getImpl ( ) const"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::Device","Filename":"poplar/Device.hpp","Text":"class Device"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::Device::Device()","Filename":"poplar/Device.hpp","Text":"Device ( )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Device::Device(poplar::Device &&)","Filename":"poplar/Device.hpp","Text":"Device ( Device && )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Device::operator=(poplar::Device &&)","Filename":"poplar/Device.hpp","Text":"Device & operator = ( Device && )"}
{"Token type":"CXXConstructor","FaliureReason":"deleted_method","Implemented":false,"Namespace":"poplar","Name":"poplar::Device::Device(const poplar::Device &)","Filename":"poplar/Device.hpp","Text":"Device ( const Device & ) = delete"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Device::operator=(const poplar::Device &)","Filename":"poplar/Device.hpp","Text":"Device & operator = ( const Device & ) = delete"}
{"Token type":"CXXConstructor","FaliureReason":"unique_ptr_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Device::Device(std::unique_ptr<core::Device>)","Filename":"poplar/Device.hpp","Text":"Device ( std :: unique_ptr < core :: Device > )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Device::getImpl()","Filename":"poplar/Device.hpp","Text":"core :: Device & getImpl ( ) const"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::IPUModel","Filename":"poplar/IPUModel.hpp","Text":"struct IPUModel { explicit IPUModel ( char const * IPUVersion = \"ipu1\" ) ; /// ipu0, ipu1, ipu2, etc... std :: string IPUVersion ; /// The number of IPUs. unsigned numIPUs ; /// The number of tiles per supertile. unsigned tilesPerSuperTile ; /// The number of tiles per IPU unsigned tilesPerIPU ; /// The number of worker contexts per tile. unsigned numWorkerContexts ; /// Memory bytes per tile. unsigned memoryBytesPerTile ; /// Clock frequency in Hz double tileClockFrequency ; /// The bandwidth of internal IPU exchange in bytes per cycle. unsigned exchangeBytesPerCycle ; /// The number of bytes per cycle that can be copied from one location to /// another using a memcpy. unsigned memcpyBytesPerCycle ; /// The size of an instruction in bytes. unsigned instructionBytes ; /// Whether a tile in a supertile can use all the exchange bandwidth of the /// supertile to send or receive, when the other tile is idle or receiving /// the same data. bool supportsSuperTileSendReceive ; /// Index in the memoryElementOffsets table (returned by /// Target::getMemoryElementOffsets) which gives the start of the /// interleaved memory region. Any value greater than or equal to size of the /// offsets table is interpreted as machine not having interleaved memory /// elements. Note that by definition, interleaved memory is always in the /// upper part of memory unsigned interleavedMemoryElementIndex ; /// A function that returns the number of cycles before the specificed tile /// is released from sync relative to the first tile that is release from /// sync. enum class RelativeSyncDelayType { AUTO , NO_DELAY } relativeSyncDelay ; /// The IPU sync delay for the tile that is closest to the sync controller. unsigned minIPUSyncDelay ; /// The number of clock cycles required to synchronize all IPUs. unsigned globalSyncCycles ; /// Set of constraints that provide a lower bound on the time it takes to /// send data between IPUs. std :: vector < GlobalExchangeConstraint > globalExchangeConstraints ; /// Size of the packet used to transfer data between tiles in bytes. unsigned globalExchangePacketBytes ; /// Number of cycles from issuing a sync instruction to the earliest time /// that instructions can resume. unsigned tileLocalSyncSyncDelay ; /// Number of cycles after a worker has issued its exit /// instruction that the supervisor can resume. unsigned tileLocalSyncExitDelay ; /// Number of stride bits unsigned numStrideBits ; /// The width of the load/store data path within the tile. unsigned dataPathWidth ; /// The maximum pipeline depth of the convolution units within the tile for /// fp16 unsigned fp16ConvUnitMaxPipelineDepth ; /// The maximum pipeline depth of the convolution units within the tile for /// fp32. Only allow a maximum of 4 cycle AMP loop. unsigned fp32ConvUnitMaxPipelineDepth ; /// The input elements loaded per cycle for f16 conv unsigned fp16ConvUnitInputLoadElemsPerCycle ; /// The input elements loaded per cycle for f32 conv unsigned fp32ConvUnitInputLoadElemsPerCycle ; /// The number of convolution units in the tile that can be used /// when partial results are outputs as 16-bits and inputs are 16 bits unsigned fp16InFp16OutConvUnitsPerTile ; /// The number of convolution units in the tile that can be used /// when partial results are outputs as 32-bits and inputs are 16 bits unsigned fp16InFp32OutConvUnitsPerTile ; /// The number of convolution units in the tile that can be used /// when accumulating to 32 bit values unsigned fp32InFp32OutConvUnitsPerTile ; /// The number of convolutional weights that can be loaded in a cycle unsigned convUnitCoeffLoadBytesPerCycle ; /// Number of bytes supervisor contexts may be loading instructions from /// memory ahead of current PC unsigned supervisorInstrFetchDelay ; /// Number of bytes worker context may be loading instructions from memory /// ahead of current PC unsigned workerInstrFetchDelay ; // Max number of repeat counter unsigned rptCountMax ; /// The atomic store granularity unsigned atomicStoreGranularity ; /// Whether or not to actually compile real IPU code for modelling bool compileIPUCode ; bool operator == ( const IPUModel & ) const ; bool operator != ( const IPUModel & ) const ; /** Create a device that runs code on the CPU and models the performance\n   *  that would be achieved on an IPU. */ Device createDevice ( OptionFlags opts = { } , bool accurateHalf = false , unsigned deviceManagerId = std :: numeric_limits < unsigned > :: max ( ) ) ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::IPUModel::IPUModel(const char *)","Filename":"poplar/IPUModel.hpp","Text":"explicit IPUModel ( char const * IPUVersion = \"ipu1\" )"}
{"Token type":"EnumDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::IPUModel::RelativeSyncDelayType","Filename":"poplar/IPUModel.hpp","Text":"enum class RelativeSyncDelayType { AUTO , NO_DELAY }"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::IPUModel::RelativeSyncDelayType::AUTO","Filename":"poplar/IPUModel.hpp","Text":"AUTO"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::IPUModel::RelativeSyncDelayType::NO_DELAY","Filename":"poplar/IPUModel.hpp","Text":"NO_DELAY"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::IPUModel::operator==(const poplar::IPUModel &)","Filename":"poplar/IPUModel.hpp","Text":"bool operator == ( const IPUModel & ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::IPUModel::operator!=(const poplar::IPUModel &)","Filename":"poplar/IPUModel.hpp","Text":"bool operator != ( const IPUModel & ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":true,"Namespace":"poplar","Name":"poplar::IPUModel::createDevice(poplar::OptionFlags, bool, unsigned int)","Filename":"poplar/IPUModel.hpp","Text":"Device createDevice ( OptionFlags opts = { } , bool accurateHalf = false , unsigned deviceManagerId = std :: numeric_limits < unsigned > :: max ( ) )"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::ArrayRef<T>(std::nullptr_t)","Filename":"poplar/ArrayRef.hpp","Text":"ArrayRef ( std :: nullptr_t ) = delete"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::ArrayRef<T>()","Filename":"poplar/ArrayRef.hpp","Text":"constexpr ArrayRef ( ) : ptr ( nullptr ) , len ( 0 ) { }"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::ArrayRef<T>(const T *, std::size_t)","Filename":"poplar/ArrayRef.hpp","Text":"constexpr ArrayRef ( const T * p , std :: size_t size ) : ptr ( p ) , len ( size ) { }"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::ArrayRef<T>(const std::vector<T> &)","Filename":"poplar/ArrayRef.hpp","Text":"ArrayRef ( const std :: vector < T > & v )"}
{"Token type":"FunctionTemplate","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::ArrayRef<T>(const std::array<T, N> &)","Filename":"poplar/ArrayRef.hpp","Text":"template < std :: size_t N > constexpr ArrayRef ( const std :: array < T , N > & a ) : ArrayRef ( a . data ( ) , N ) { }"}
{"Token type":"FunctionTemplate","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::ArrayRef<T>(const T (&)[N])","Filename":"poplar/ArrayRef.hpp","Text":"template < std :: size_t N > constexpr ArrayRef ( const T ( & p ) [ N ] ) : ArrayRef ( p , N ) { }"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::ArrayRef<T>(const std::initializer_list<T> &)","Filename":"poplar/ArrayRef.hpp","Text":"constexpr ArrayRef ( const std :: initializer_list < T > & list ) : ArrayRef ( list . begin ( ) , list . size ( ) ) { }"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::ArrayRef<T>(const ArrayRef<T> &)","Filename":"poplar/ArrayRef.hpp","Text":"constexpr ArrayRef ( const ArrayRef & ) = default"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::data()","Filename":"poplar/ArrayRef.hpp","Text":"constexpr const T * data ( ) const { return ptr ; }"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::size()","Filename":"poplar/ArrayRef.hpp","Text":"constexpr std :: size_t size ( ) const { return len ; }"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::empty()","Filename":"poplar/ArrayRef.hpp","Text":"constexpr bool empty ( ) const { return len == 0 ; }"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::front()","Filename":"poplar/ArrayRef.hpp","Text":"const T & front ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::operator[](std::size_t)","Filename":"poplar/ArrayRef.hpp","Text":"const T & operator [ ] ( std :: size_t i ) const"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::begin()","Filename":"poplar/ArrayRef.hpp","Text":"const_iterator begin ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::end()","Filename":"poplar/ArrayRef.hpp","Text":"const_iterator end ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::cbegin()","Filename":"poplar/ArrayRef.hpp","Text":"const_iterator cbegin ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::cend()","Filename":"poplar/ArrayRef.hpp","Text":"const_iterator cend ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::cloneAsVector()","Filename":"poplar/ArrayRef.hpp","Text":"std :: vector < T > cloneAsVector ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::max_size()","Filename":"poplar/ArrayRef.hpp","Text":"std :: size_t max_size ( ) const"}
{"Token type":"FunctionTemplate","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::operator==(const ArrayRef<T> &, const ArrayRef<T> &)","Filename":"poplar/ArrayRef.hpp","Text":"template < class T > inline bool operator == ( const ArrayRef < T > & l , const ArrayRef < T > & r )"}
{"Token type":"FunctionTemplate","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::operator!=(const ArrayRef<T> &, const ArrayRef<T> &)","Filename":"poplar/ArrayRef.hpp","Text":"template < class T > inline bool operator != ( const ArrayRef < T > & l , const ArrayRef < T > & r )"}
{"Token type":"StructDecl","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef","Filename":"poplar/StringRef.hpp","Text":"struct StringRef : public ArrayRef < char > { constexpr StringRef ( ) : ArrayRef ( nullptr , 0 ) { } constexpr StringRef ( const StringRef & ) = default ; StringRef ( std :: nullptr_t ) = delete ; StringRef ( const std :: string & s ) : ArrayRef ( s . data ( ) , s . size ( ) ) { } constexpr StringRef ( const char * p , std :: size_t len ) : ArrayRef ( p , len ) { } StringRef ( const char * p ) : ArrayRef ( p , std :: strlen ( p ) ) { } // String literal will always be null terminated hence N-1: template < std :: size_t N > constexpr StringRef ( const char ( & p ) [ N ] ) : ArrayRef ( p , N - 1 ) { } std :: string cloneAsString ( ) const { return std :: string ( begin ( ) , size ( ) ) ; } operator std :: string ( ) const { return cloneAsString ( ) ; } }"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef::StringRef()","Filename":"poplar/StringRef.hpp","Text":"constexpr StringRef ( ) : ArrayRef ( nullptr , 0 ) { }"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef::StringRef(const poplar::StringRef &)","Filename":"poplar/StringRef.hpp","Text":"constexpr StringRef ( const StringRef & ) = default"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef::StringRef(std::nullptr_t)","Filename":"poplar/StringRef.hpp","Text":"StringRef ( std :: nullptr_t ) = delete"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef::StringRef(const std::string &)","Filename":"poplar/StringRef.hpp","Text":"StringRef ( const std :: string & s )"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef::StringRef(const char *, std::size_t)","Filename":"poplar/StringRef.hpp","Text":"constexpr StringRef ( const char * p , std :: size_t len ) : ArrayRef ( p , len ) { }"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef::StringRef(const char *)","Filename":"poplar/StringRef.hpp","Text":"StringRef ( const char * p )"}
{"Token type":"FunctionTemplate","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef::StringRef(const char (&)[N])","Filename":"poplar/StringRef.hpp","Text":"template < std :: size_t N > constexpr StringRef ( const char ( & p ) [ N ] ) : ArrayRef ( p , N - 1 ) { }"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef::cloneAsString()","Filename":"poplar/StringRef.hpp","Text":"std :: string cloneAsString ( ) const"}
{"Token type":"FunctionDecl","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::operator==(poplar::StringRef, poplar::StringRef)","Filename":"poplar/StringRef.hpp","Text":"inline bool operator == ( StringRef l , StringRef r )"}
{"Token type":"FunctionDecl","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::operator!=(poplar::StringRef, poplar::StringRef)","Filename":"poplar/StringRef.hpp","Text":"inline bool operator != ( StringRef l , StringRef r )"}
{"Token type":"FunctionDecl","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<(poplar::StringRef, poplar::StringRef)","Filename":"poplar/StringRef.hpp","Text":"inline bool operator < ( StringRef l , StringRef r )"}
{"Token type":"FunctionDecl","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::operator+(poplar::StringRef, poplar::StringRef)","Filename":"poplar/StringRef.hpp","Text":"inline std :: string operator + ( StringRef l , StringRef r )"}
{"Token type":"FunctionDecl","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::operator+=(std::string &, poplar::StringRef)","Filename":"poplar/StringRef.hpp","Text":"inline std :: string & operator += ( std :: string & s , StringRef r )"}
{"Token type":"FunctionDecl","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<<(std::ostream &, const poplar::StringRef &)","Filename":"poplar/StringRef.hpp","Text":"inline std :: ostream & operator << ( std :: ostream & os , const StringRef & s )"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::Type","Filename":"poplar/Type.hpp","Text":"class Type"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::Type()","Filename":"poplar/Type.hpp","Text":"Type ( )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::Type(poplar::Type &&)","Filename":"poplar/Type.hpp","Text":"Type ( Type && other )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::operator=(const poplar::Type &)","Filename":"poplar/Type.hpp","Text":"Type & operator = ( const Type & other )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::operator=(poplar::Type &&)","Filename":"poplar/Type.hpp","Text":"Type & operator = ( Type && other )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::operator==(const poplar::Type &)","Filename":"poplar/Type.hpp","Text":"bool operator == ( const Type & other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::operator!=(const poplar::Type &)","Filename":"poplar/Type.hpp","Text":"bool operator != ( const Type & other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::operator<(const poplar::Type &)","Filename":"poplar/Type.hpp","Text":"bool operator < ( const Type & other ) const"}
{"Token type":"CXXConstructor","FaliureReason":"unique_ptr_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::Type(std::unique_ptr<core::Type>)","Filename":"poplar/Type.hpp","Text":"Type ( std :: unique_ptr < core :: Type > )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::getImpl()","Filename":"poplar/Type.hpp","Text":"const core :: Type & getImpl ( ) const"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<<(std::ostream &, const poplar::Type &)","Filename":"poplar/Type.hpp","Text":"inline std :: ostream & operator << ( std :: ostream & os , const Type & t )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<bool>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( bool , BOOL )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<char>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( char , CHAR )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<unsigned char>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( unsigned char , UNSIGNED_CHAR )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<signed char>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( signed char , SIGNED_CHAR )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<unsigned short>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( unsigned short , UNSIGNED_SHORT )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<short>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( signed short , SHORT )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<unsigned int>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( unsigned int , UNSIGNED_INT )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<int>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( signed int , INT )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<unsigned long>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( unsigned long , UNSIGNED_LONG )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<long>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( signed long , LONG )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<unsigned long long>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( unsigned long long , UNSIGNED_LONGLONG )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<long long>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( signed long long , LONGLONG )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<float>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( float , FLOAT )"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::DataStreamRef","Filename":"poplar/DataStream.hpp","Text":"class DataStreamRef"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::RemoteBufferRef","Filename":"poplar/DataStream.hpp","Text":"class RemoteBufferRef"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::DataStream::DataStream()","Filename":"poplar/DataStream.hpp","Text":"DataStream ( )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::DataStream::DataStream(poplar::DataStream &&)","Filename":"poplar/DataStream.hpp","Text":"DataStream ( DataStream && )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::DataStream::operator=(const poplar::DataStream &)","Filename":"poplar/DataStream.hpp","Text":"DataStream & operator = ( const DataStream & )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::DataStream::operator=(poplar::DataStream &&)","Filename":"poplar/DataStream.hpp","Text":"DataStream & operator = ( DataStream && )"}
{"Token type":"CXXConstructor","FaliureReason":"unique_ptr_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::DataStream::DataStream(std::unique_ptr<core::DataStreamRef>)","Filename":"poplar/DataStream.hpp","Text":"DataStream ( std :: unique_ptr < core :: DataStreamRef > )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::DataStream::getImpl()","Filename":"poplar/DataStream.hpp","Text":"const core :: DataStreamRef & getImpl ( ) const"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::RemoteBuffer::RemoteBuffer()","Filename":"poplar/DataStream.hpp","Text":"RemoteBuffer ( )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::RemoteBuffer::RemoteBuffer(poplar::RemoteBuffer &&)","Filename":"poplar/DataStream.hpp","Text":"RemoteBuffer ( RemoteBuffer && )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::RemoteBuffer::operator=(const poplar::RemoteBuffer &)","Filename":"poplar/DataStream.hpp","Text":"RemoteBuffer & operator = ( const RemoteBuffer & )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::RemoteBuffer::operator=(poplar::RemoteBuffer &&)","Filename":"poplar/DataStream.hpp","Text":"RemoteBuffer & operator = ( RemoteBuffer && )"}
{"Token type":"CXXConstructor","FaliureReason":"unique_ptr_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::RemoteBuffer::RemoteBuffer(std::unique_ptr<core::RemoteBufferRef>)","Filename":"poplar/DataStream.hpp","Text":"RemoteBuffer ( std :: unique_ptr < core :: RemoteBufferRef > )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::RemoteBuffer::getImpl()","Filename":"poplar/DataStream.hpp","Text":"const core :: RemoteBufferRef & getImpl ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::RemoteBuffer::operator==(const poplar::RemoteBuffer &)","Filename":"poplar/DataStream.hpp","Text":"bool operator == ( const RemoteBuffer & b ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::RemoteBuffer::operator!=(const poplar::RemoteBuffer &)","Filename":"poplar/DataStream.hpp","Text":"bool operator != ( const RemoteBuffer & b ) const"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::OptionFlags","Filename":"poplar/OptionFlags.hpp","Text":"class OptionFlags"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::OptionFlagsIterator","Filename":"poplar/OptionFlags.hpp","Text":"class OptionFlagsIterator"}
{"Token type":"CXXConstructor","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::iterator(std::unique_ptr<core::OptionFlagsIterator> &&)","Filename":"poplar/OptionFlags.hpp","Text":"iterator ( std :: unique_ptr < core :: OptionFlagsIterator > && p ) noexcept"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::operator=(const poplar::OptionFlags::iterator &)","Filename":"poplar/OptionFlags.hpp","Text":"iterator & operator = ( const iterator & other )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::iterator(poplar::OptionFlags::iterator &&)","Filename":"poplar/OptionFlags.hpp","Text":"iterator ( iterator && other ) noexcept"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::operator=(poplar::OptionFlags::iterator &&)","Filename":"poplar/OptionFlags.hpp","Text":"iterator & operator = ( iterator && other ) noexcept"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::operator*()","Filename":"poplar/OptionFlags.hpp","Text":"const OptionFlag & operator * ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::operator->()","Filename":"poplar/OptionFlags.hpp","Text":"const OptionFlag * operator -> ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::operator==(const poplar::OptionFlags::iterator &)","Filename":"poplar/OptionFlags.hpp","Text":"bool operator == ( const iterator & other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::operator!=(const poplar::OptionFlags::iterator &)","Filename":"poplar/OptionFlags.hpp","Text":"bool operator != ( const iterator & other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::operator++()","Filename":"poplar/OptionFlags.hpp","Text":"iterator & operator ++ ( )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::operator++(int)","Filename":"poplar/OptionFlags.hpp","Text":"iterator operator ++ ( int )"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::OptionFlags()","Filename":"poplar/OptionFlags.hpp","Text":"OptionFlags ( )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::OptionFlags(poplar::OptionFlags &&)","Filename":"poplar/OptionFlags.hpp","Text":"OptionFlags ( OptionFlags && other )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::operator=(const poplar::OptionFlags &)","Filename":"poplar/OptionFlags.hpp","Text":"OptionFlags & operator = ( const OptionFlags & other )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::operator=(poplar::OptionFlags &&)","Filename":"poplar/OptionFlags.hpp","Text":"OptionFlags & operator = ( OptionFlags && other )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::operator==(const poplar::OptionFlags &)","Filename":"poplar/OptionFlags.hpp","Text":"bool operator == ( const OptionFlags & other ) const"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::OptionFlags(poplar::OptionFlags::initializer_list &&)","Filename":"poplar/OptionFlags.hpp","Text":"OptionFlags ( initializer_list && list )"}
{"Token type":"CXXMethod","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::set(poplar::OptionFlags::initializer_list &&)","Filename":"poplar/OptionFlags.hpp","Text":"void set ( initializer_list && list )"}
{"Token type":"FunctionDecl","FaliureReason":"istream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::readJSON(std::istream &, poplar::OptionFlags &)","Filename":"poplar/OptionFlags.hpp","Text":"void readJSON ( std :: istream & stream , OptionFlags & flags )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::GlobalExchangeFlow::operator==(const poplar::GlobalExchangeFlow &)","Filename":"poplar/GlobalExchangeConstraints.hpp","Text":"bool operator == ( const GlobalExchangeFlow & other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::GlobalExchangeFlow::operator<(const poplar::GlobalExchangeFlow &)","Filename":"poplar/GlobalExchangeConstraints.hpp","Text":"bool operator < ( const GlobalExchangeFlow & other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::GlobalExchangeConstraint::operator==(const poplar::GlobalExchangeConstraint &)","Filename":"poplar/GlobalExchangeConstraints.hpp","Text":"bool operator == ( const GlobalExchangeConstraint & other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::GlobalExchangeConstraint::operator<(const poplar::GlobalExchangeConstraint &)","Filename":"poplar/GlobalExchangeConstraints.hpp","Text":"bool operator < ( const GlobalExchangeConstraint & other ) const"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<<(std::ostream &, poplar::IpuLinkConfiguration)","Filename":"poplar/IpuLinkConfiguration.hpp","Text":"std :: ostream & operator << ( std :: ostream & os , IpuLinkConfiguration ic )"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<<(std::ostream &, poplar::IpuLinkTopology)","Filename":"poplar/IpuLinkTopology.hpp","Text":"std :: ostream & operator << ( std :: ostream & os , IpuLinkTopology topo )"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::Target","Filename":"poplar/Target.hpp","Text":"class Target"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::Target()","Filename":"poplar/Target.hpp","Text":"Target ( )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::Target(poplar::Target &&)","Filename":"poplar/Target.hpp","Text":"Target ( Target && )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::operator=(const poplar::Target &)","Filename":"poplar/Target.hpp","Text":"Target & operator = ( const Target & )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::operator=(poplar::Target &&)","Filename":"poplar/Target.hpp","Text":"Target & operator = ( Target && )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::operator==(const poplar::Target &)","Filename":"poplar/Target.hpp","Text":"bool operator == ( const Target & ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::operator!=(const poplar::Target &)","Filename":"poplar/Target.hpp","Text":"bool operator != ( const Target & ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::operator<(const poplar::Target &)","Filename":"poplar/Target.hpp","Text":"bool operator < ( const Target & ) const"}
{"Token type":"CXXConstructor","FaliureReason":"unique_ptr_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::Target(std::unique_ptr<core::Target>)","Filename":"poplar/Target.hpp","Text":"Target ( std :: unique_ptr < core :: Target > )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::getImpl()","Filename":"poplar/Target.hpp","Text":"core :: Target & getImpl ( ) const"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::Device","Filename":"poplar/Device.hpp","Text":"class Device"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::Device::Device()","Filename":"poplar/Device.hpp","Text":"Device ( )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Device::Device(poplar::Device &&)","Filename":"poplar/Device.hpp","Text":"Device ( Device && )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Device::operator=(poplar::Device &&)","Filename":"poplar/Device.hpp","Text":"Device & operator = ( Device && )"}
{"Token type":"CXXConstructor","FaliureReason":"deleted_method","Implemented":false,"Namespace":"poplar","Name":"poplar::Device::Device(const poplar::Device &)","Filename":"poplar/Device.hpp","Text":"Device ( const Device & ) = delete"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Device::operator=(const poplar::Device &)","Filename":"poplar/Device.hpp","Text":"Device & operator = ( const Device & ) = delete"}
{"Token type":"CXXConstructor","FaliureReason":"unique_ptr_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Device::Device(std::unique_ptr<core::Device>)","Filename":"poplar/Device.hpp","Text":"Device ( std :: unique_ptr < core :: Device > )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Device::getImpl()","Filename":"poplar/Device.hpp","Text":"core :: Device & getImpl ( ) const"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::Executable","Filename":"poplar/Executable.hpp","Text":"class Executable"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Executable::Executable(poplar::Executable &&)","Filename":"poplar/Executable.hpp","Text":"Executable ( Executable && other )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Executable::operator=(poplar::Executable &&)","Filename":"poplar/Executable.hpp","Text":"Executable & operator = ( Executable && other )"}
{"Token type":"CXXMethod","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Executable::serialize(std::ostream &)","Filename":"poplar/Executable.hpp","Text":"void serialize ( std :: ostream & out ) const"}
{"Token type":"CXXMethod","FaliureReason":"istream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Executable::deserialize(std::istream &)","Filename":"poplar/Executable.hpp","Text":"static Executable deserialize ( std :: istream & in )"}
{"Token type":"CXXConstructor","FaliureReason":"unique_ptr_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Executable::Executable(std::unique_ptr<core::Executable>)","Filename":"poplar/Executable.hpp","Text":"explicit Executable ( std :: unique_ptr < core :: Executable > impl )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Executable::getImpl()","Filename":"poplar/Executable.hpp","Text":"const core :: Executable & getImpl ( ) const"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::GraphBuilder","Filename":"poplar/GraphElements.hpp","Text":"class GraphBuilder"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::VertexRef::VertexRef()","Filename":"poplar/GraphElements.hpp","Text":"VertexRef ( )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::VertexRef::operator[](poplar::StringRef)","Filename":"poplar/GraphElements.hpp","Text":"FieldRef operator [ ] ( StringRef fieldName ) const"}
{"Token type":"CXXConstructor","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::VertexRef::VertexRef(const core::GraphBuilder *, unsigned int)","Filename":"poplar/GraphElements.hpp","Text":"VertexRef ( const core :: GraphBuilder * graph , unsigned id )"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldRef::FieldRef()","Filename":"poplar/GraphElements.hpp","Text":"FieldRef ( )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldRef::operator[](std::size_t)","Filename":"poplar/GraphElements.hpp","Text":"FieldRef operator [ ] ( std :: size_t index ) const"}
{"Token type":"CXXConstructor","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldRef::FieldRef(poplar::VertexRef, poplar::StringRef)","Filename":"poplar/GraphElements.hpp","Text":"FieldRef ( VertexRef vertex , StringRef fieldName )"}
{"Token type":"CXXConstructor","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldRef::FieldRef(poplar::VertexRef, unsigned int)","Filename":"poplar/GraphElements.hpp","Text":"FieldRef ( VertexRef vertex , unsigned fieldId )"}
{"Token type":"CXXConstructor","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldRef::FieldRef(poplar::VertexRef, poplar::StringRef, std::size_t)","Filename":"poplar/GraphElements.hpp","Text":"FieldRef ( VertexRef vertex , StringRef fieldName , std :: size_t index )"}
{"Token type":"CXXConstructor","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldRef::FieldRef(poplar::VertexRef, unsigned int, std::size_t)","Filename":"poplar/GraphElements.hpp","Text":"FieldRef ( VertexRef vertex , unsigned fieldId , std :: size_t index )"}
{"Token type":"CXXMethod","FaliureReason":"constructor_missing_class","Implemented":false,"Namespace":"poplar","Name":"poplar::operator[](poplar::StringRef)","Filename":"poplar/GraphElements.hpp","Text":"inline FieldRef VertexRef :: operator [ ] ( StringRef fieldName ) const"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::ComputeSet::ComputeSet()","Filename":"poplar/GraphElements.hpp","Text":"ComputeSet ( )"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::Function::Function()","Filename":"poplar/GraphElements.hpp","Text":"Function ( )"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::MutableProfileValue","Filename":"poplar/ProfileValue.hpp","Text":"class MutableProfileValue"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::operator[](poplar::StringRef)","Filename":"poplar/ProfileValue.hpp","Text":"const ProfileValue & operator [ ] ( StringRef s ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::operator[](std::size_t)","Filename":"poplar/ProfileValue.hpp","Text":"const ProfileValue & operator [ ] ( std :: size_t i ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::operator==(const poplar::ProfileValue &)","Filename":"poplar/ProfileValue.hpp","Text":"bool operator == ( const ProfileValue & other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::operator!=(const poplar::ProfileValue &)","Filename":"poplar/ProfileValue.hpp","Text":"bool operator != ( const ProfileValue & other ) const"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::ProfileValue()","Filename":"poplar/ProfileValue.hpp","Text":"ProfileValue ( )"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::ProfileValue(T)","Filename":"poplar/ProfileValue.hpp","Text":"template < class T , typename = typename std :: enable_if < std :: is_integral < T > :: value > :: type > ProfileValue ( T init )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::ProfileValue(poplar::ProfileValue &&)","Filename":"poplar/ProfileValue.hpp","Text":"ProfileValue ( ProfileValue && other ) noexcept"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::operator=(const poplar::ProfileValue &)","Filename":"poplar/ProfileValue.hpp","Text":"ProfileValue & operator = ( const ProfileValue & other )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::operator=(poplar::ProfileValue &&)","Filename":"poplar/ProfileValue.hpp","Text":"ProfileValue & operator = ( ProfileValue && other ) noexcept"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::operator=(poplar::ProfileValue::Boolean)","Filename":"poplar/ProfileValue.hpp","Text":"ProfileValue & operator = ( Boolean init )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::operator=(poplar::ProfileValue::Number)","Filename":"poplar/ProfileValue.hpp","Text":"ProfileValue & operator = ( Number init )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::operator=(poplar::ProfileValue::String)","Filename":"poplar/ProfileValue.hpp","Text":"ProfileValue & operator = ( String init )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::operator=(poplar::ProfileValue::Vector)","Filename":"poplar/ProfileValue.hpp","Text":"ProfileValue & operator = ( Vector init )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::operator=(poplar::ProfileValue::Map)","Filename":"poplar/ProfileValue.hpp","Text":"ProfileValue & operator = ( Map init )"}
{"Token type":"FunctionTemplate","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::operator=(T)","Filename":"poplar/ProfileValue.hpp","Text":"template < class T , typename = typename std :: enable_if < std :: is_integral < T > :: value > :: type > ProfileValue & operator = ( T init )"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::serializeToJSON(std::ostream &, const poplar::ProfileValue &, bool)","Filename":"poplar/ProfileValue.hpp","Text":"void serializeToJSON ( std :: ostream & out , const ProfileValue & val , bool prettyPrint = false )"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::serializeToCBOR(std::ostream &, const poplar::ProfileValue &, bool)","Filename":"poplar/ProfileValue.hpp","Text":"void serializeToCBOR ( std :: ostream & out , const ProfileValue & val , bool withTag = true )"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<<(std::ostream &, const poplar::ProfileValue &)","Filename":"poplar/ProfileValue.hpp","Text":"std :: ostream & operator << ( std :: ostream & os , const ProfileValue & v )"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::printGraphSummary(std::ostream &, const poplar::ProfileValue &, const poplar::OptionFlags &)","Filename":"poplar/ProfileValue.hpp","Text":"void printGraphSummary ( std :: ostream & out , const ProfileValue & graphProfile , const OptionFlags & opts )"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::printExecutionSummary(std::ostream &, const poplar::ProfileValue &, const poplar::ProfileValue &, const poplar::OptionFlags &)","Filename":"poplar/ProfileValue.hpp","Text":"void printExecutionSummary ( std :: ostream & out , const ProfileValue & graphProfile , const ProfileValue & executionProfile , const OptionFlags & opts )"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::printProfileSummary(std::ostream &, const poplar::ProfileValue &, const poplar::ProfileValue &, const poplar::OptionFlags &)","Filename":"poplar/ProfileValue.hpp","Text":"void printProfileSummary ( std :: ostream & out , const ProfileValue & graphProfile , const ProfileValue & executionProfile , const OptionFlags & opts = { } )"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::profiling_disabled::profiling_disabled()","Filename":"poplar/exceptions.hpp","Text":"profiling_disabled ( )"}
{"Token type":"CXXConstructor","FaliureReason":"constructor_missing_class","Implemented":false,"Namespace":"poplar","Name":"poplar::GenericInterval<T>::GenericInterval<T>()","Filename":"poplar/Interval.hpp","Text":"GenericInterval ( ) = default"}
{"Token type":"CXXConstructor","FaliureReason":"constructor_missing_class","Implemented":false,"Namespace":"poplar","Name":"poplar::GenericInterval<T>::GenericInterval<T>(T, T)","Filename":"poplar/Interval.hpp","Text":"GenericInterval ( T begin , T end )"}
{"Token type":"CXXMethod","FaliureReason":"constructor_missing_class","Implemented":false,"Namespace":"poplar","Name":"poplar::GenericInterval<T>::begin()","Filename":"poplar/Interval.hpp","Text":"const T & begin ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"constructor_missing_class","Implemented":false,"Namespace":"poplar","Name":"poplar::GenericInterval<T>::end()","Filename":"poplar/Interval.hpp","Text":"const T & end ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"constructor_missing_class","Implemented":false,"Namespace":"poplar","Name":"poplar::GenericInterval<T>::size()","Filename":"poplar/Interval.hpp","Text":"T size ( ) const"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::operator==(const GenericInterval<T> &, const GenericInterval<T> &)","Filename":"poplar/Interval.hpp","Text":"template < class T > inline bool operator == ( const GenericInterval < T > & a , const GenericInterval < T > & b )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<(const GenericInterval<T> &, const GenericInterval<T> &)","Filename":"poplar/Interval.hpp","Text":"template < class T > inline bool operator < ( const GenericInterval < T > & a , const GenericInterval < T > & b )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::operator!=(const GenericInterval<T> &, const GenericInterval<T> &)","Filename":"poplar/Interval.hpp","Text":"template < class T > inline bool operator != ( const GenericInterval < T > & a , const GenericInterval < T > & b )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::operator>=(const GenericInterval<T> &, const GenericInterval<T> &)","Filename":"poplar/Interval.hpp","Text":"template < class T > inline bool operator >= ( const GenericInterval < T > & a , const GenericInterval < T > & b )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::operator>(const GenericInterval<T> &, const GenericInterval<T> &)","Filename":"poplar/Interval.hpp","Text":"template < class T > inline bool operator > ( const GenericInterval < T > & a , const GenericInterval < T > & b )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<=(const GenericInterval<T> &, const GenericInterval<T> &)","Filename":"poplar/Interval.hpp","Text":"template < class T > inline bool operator <= ( const GenericInterval < T > & a , const GenericInterval < T > & b )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<<(std::ostream &, const GenericInterval<T> &)","Filename":"poplar/Interval.hpp","Text":"template < class T > inline std :: ostream & operator << ( std :: ostream & os , const GenericInterval < T > & b )"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::SourceLocation::SourceLocation()","Filename":"poplar/DebugContext.hpp","Text":"SourceLocation ( ) = default"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::DebugInfo","Filename":"poplar/DebugContext.hpp","Text":"class DebugInfo"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::DebugInfo::operator=(const poplar::DebugInfo &)","Filename":"poplar/DebugContext.hpp","Text":"DebugInfo & operator = ( const DebugInfo & ) = delete"}
{"Token type":"CXXConstructor","FaliureReason":"deleted_method","Implemented":false,"Namespace":"poplar","Name":"poplar::DebugInfo::DebugInfo(const poplar::DebugInfo &)","Filename":"poplar/DebugContext.hpp","Text":"DebugInfo ( const DebugInfo & ) = delete"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::DebugInfo::getImpl()","Filename":"poplar/DebugContext.hpp","Text":"core :: DebugInfo & getImpl ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::DebugInfo::setValue(std::string, poplar::ProfileValue)","Filename":"poplar/DebugContext.hpp","Text":"bool setValue ( std :: string name , ProfileValue value )"}
{"Token type":"StructDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::DebugContext","Filename":"poplar/DebugContext.hpp","Text":"struct DebugContext"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::DebugContext::DebugContext(poplar::DebugContext &&)","Filename":"poplar/DebugContext.hpp","Text":"DebugContext ( DebugContext && )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::DebugContext::getImpl()","Filename":"poplar/DebugContext.hpp","Text":"core :: DebugContext & getImpl ( ) const"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar","Name":"poplar::IeeeHalf","Filename":"poplar/TypeTraits.hpp","Text":"class IeeeHalf"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::TypeTraits::make()","Filename":"poplar/TypeTraits.hpp","Text":"template < typename T > static TypeTraits make ( )"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::TypeTraits::isSimpleType()","Filename":"poplar/TypeTraits.hpp","Text":"template < typename T > static constexpr bool isSimpleType ( )"}
{"Token type":"FunctionTemplate","FaliureReason":"constructor_missing_class","Implemented":false,"Namespace":"poplar","Name":"poplar::make()","Filename":"poplar/TypeTraits.hpp","Text":"template < typename T > TypeTraits TypeTraits :: make ( )"}
{"Token type":"CXXMethod","FaliureReason":"constructor_missing_class","Implemented":false,"Namespace":"poplar","Name":"poplar::make<>()","Filename":"poplar/TypeTraits.hpp","Text":"template < > inline TypeTraits TypeTraits :: make < IeeeHalf > ( )"}
{"Token type":"FunctionTemplate","FaliureReason":"constructor_missing_class","Implemented":false,"Namespace":"poplar","Name":"poplar::isSimpleType()","Filename":"poplar/TypeTraits.hpp","Text":"template < typename T > constexpr bool TypeTraits :: isSimpleType ( ) { return std :: is_integral < T > :: value || std :: is_floating_point < T > :: value ; }"}
{"Token type":"CXXMethod","FaliureReason":"constructor_missing_class","Implemented":false,"Namespace":"poplar","Name":"poplar::isSimpleType<>()","Filename":"poplar/TypeTraits.hpp","Text":"template < > constexpr bool TypeTraits :: isSimpleType < IeeeHalf > ( ) { return true ; }"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::Tensor","Filename":"poplar/Tensor.hpp","Text":"class Tensor"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::Tensor()","Filename":"poplar/Tensor.hpp","Text":"Tensor ( )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::Tensor(poplar::Tensor &&)","Filename":"poplar/Tensor.hpp","Text":"Tensor ( Tensor && other )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::operator=(const poplar::Tensor &)","Filename":"poplar/Tensor.hpp","Text":"const Tensor & operator = ( const Tensor & other ) &"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::operator=(poplar::Tensor &&)","Filename":"poplar/Tensor.hpp","Text":"Tensor & operator = ( Tensor && other ) &"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::operator[](std::size_t)","Filename":"poplar/Tensor.hpp","Text":"Tensor operator [ ] ( std :: size_t i ) const &"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::operator[](std::size_t)","Filename":"poplar/Tensor.hpp","Text":"Tensor && operator [ ] ( std :: size_t i ) &&"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::getConstantValue(T *)","Filename":"poplar/Tensor.hpp","Text":"template < typename T > bool getConstantValue ( T * val ) const"}
{"Token type":"CXXMethod","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::output(std::ostream &)","Filename":"poplar/Tensor.hpp","Text":"std :: ostream & output ( std :: ostream & os ) const"}
{"Token type":"CXXMethod","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::outputRegions(std::ostream &)","Filename":"poplar/Tensor.hpp","Text":"std :: ostream & outputRegions ( std :: ostream & os ) const"}
{"Token type":"CXXConstructor","FaliureReason":"unique_ptr_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::Tensor(std::unique_ptr<core::Tensor>)","Filename":"poplar/Tensor.hpp","Text":"Tensor ( std :: unique_ptr < core :: Tensor > )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::getImpl()","Filename":"poplar/Tensor.hpp","Text":"core :: Tensor & getImpl ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::getPImpl()","Filename":"poplar/Tensor.hpp","Text":"std :: unique_ptr < core :: Tensor > * getPImpl ( )"}
{"Token type":"CXXMethod","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::getConstantData(void *, const poplar::TypeTraits &)","Filename":"poplar/Tensor.hpp","Text":"bool getConstantData ( void * dst , const TypeTraits & traits ) const"}
{"Token type":"FunctionDecl","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::operator==(const poplar::Tensor &, const poplar::Tensor &)","Filename":"poplar/Tensor.hpp","Text":"bool operator == ( const Tensor & a , const Tensor & b )"}
{"Token type":"FunctionDecl","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::operator!=(const poplar::Tensor &, const poplar::Tensor &)","Filename":"poplar/Tensor.hpp","Text":"bool inline operator != ( const Tensor & a , const Tensor & b )"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<<(std::ostream &, const poplar::Tensor &)","Filename":"poplar/Tensor.hpp","Text":"std :: ostream & operator << ( std :: ostream & os , const Tensor & tensor )"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::ProgramImpl","Filename":"poplar/Program.hpp","Text":"class ProgramImpl"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Program::Program()","Filename":"poplar/Program.hpp","Text":"Program ( )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Program::Program(poplar::program::Program &&)","Filename":"poplar/Program.hpp","Text":"Program ( Program && p )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Program::operator=(const poplar::program::Program &)","Filename":"poplar/Program.hpp","Text":"Program & operator = ( const Program & p )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Program::operator=(poplar::program::Program &&)","Filename":"poplar/Program.hpp","Text":"Program & operator = ( Program && p )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Program::getImpl()","Filename":"poplar/Program.hpp","Text":"core :: ProgramImpl & getImpl ( ) const"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Sequence::add_many(const poplar::program::Program &, T &&...)","Filename":"poplar/Program.hpp","Text":"template < class ... T > void add_many ( const Program & first , T && ... rest )"}
{"Token type":"CXXMethod","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Sequence::add_many()","Filename":"poplar/Program.hpp","Text":"void add_many ( )"}
{"Token type":"CXXMethod","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Sequence::init()","Filename":"poplar/Program.hpp","Text":"void init ( )"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Sequence::Sequence()","Filename":"poplar/Program.hpp","Text":"Sequence ( )"}
{"Token type":"FunctionTemplate","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Sequence::Sequence(T &&...)","Filename":"poplar/Program.hpp","Text":"template < class ... T > Sequence ( T && ... args )"}
{"Token type":"CXXConstructor","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Switch::Switch(poplar::Tensor, const poplar::program::Program &, const bool)","Filename":"poplar/Program.hpp","Text":"Switch ( Tensor control , const Program & defaultCaseBody , const bool unreachableDefault )"}
{"Token type":"CXXConstructor","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Copy::Copy(const poplar::DataStream &, poplar::Tensor, bool, poplar::Tensor, size_t, bool, const poplar::OptionFlags &)","Filename":"poplar/Program.hpp","Text":"Copy ( const DataStream & stream , Tensor dst , bool rearrangeOnHost , Tensor offset , size_t repeats , bool optimiseMemory , const OptionFlags & options = { } )"}
{"Token type":"CXXConstructor","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Copy::Copy(poplar::Tensor, const poplar::DataStream &, bool, poplar::Tensor, size_t, bool, const poplar::OptionFlags &)","Filename":"poplar/Program.hpp","Text":"Copy ( Tensor src , const DataStream & stream , bool rearrangeOnHost , Tensor offset , size_t repeats , bool optimiseMemory , const OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::dumpProgram(const poplar::Graph &, const poplar::program::Program &, std::ostream &)","Filename":"poplar/Program.hpp","Text":"void dumpProgram ( const Graph & graph , const Program & program , std :: ostream & out )"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::VariableRef::VariableRef()","Filename":"poplar/VariableRef.hpp","Text":"VariableRef ( ) = default"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::VariableRef::VariableRef(poplar::VariableRef &&)","Filename":"poplar/VariableRef.hpp","Text":"VariableRef ( VariableRef && other ) = default"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::VariableRef::operator=(const poplar::VariableRef &)","Filename":"poplar/VariableRef.hpp","Text":"VariableRef & operator = ( const VariableRef & other ) = default"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::VariableRef::operator=(poplar::VariableRef &&)","Filename":"poplar/VariableRef.hpp","Text":"VariableRef & operator = ( VariableRef && other ) = default"}
{"Token type":"FunctionDecl","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::VariableRef::operator==(const poplar::VariableRef &, const poplar::VariableRef &)","Filename":"poplar/VariableRef.hpp","Text":"friend bool operator == ( const VariableRef & a , const VariableRef & b )"}
{"Token type":"FunctionDecl","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::VariableRef::operator<(const poplar::VariableRef &, const poplar::VariableRef &)","Filename":"poplar/VariableRef.hpp","Text":"friend bool operator < ( const VariableRef & a , const VariableRef & b )"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::VariableInterval::VariableInterval()","Filename":"poplar/VariableRef.hpp","Text":"VariableInterval ( ) = default"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::VariableInterval::VariableInterval(poplar::VariableInterval &&)","Filename":"poplar/VariableRef.hpp","Text":"VariableInterval ( VariableInterval && other ) = default"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::VariableInterval::operator=(const poplar::VariableInterval &)","Filename":"poplar/VariableRef.hpp","Text":"VariableInterval & operator = ( const VariableInterval & other ) = default"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::VariableInterval::operator=(poplar::VariableInterval &&)","Filename":"poplar/VariableRef.hpp","Text":"VariableInterval & operator = ( VariableInterval && other ) = default"}
{"Token type":"FunctionDecl","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::operator==(const poplar::VariableInterval &, const poplar::VariableInterval &)","Filename":"poplar/VariableRef.hpp","Text":"bool operator == ( const VariableInterval & a , const VariableInterval & b )"}
{"Token type":"FunctionDecl","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<(const poplar::VariableInterval &, const poplar::VariableInterval &)","Filename":"poplar/VariableRef.hpp","Text":"bool operator < ( const VariableInterval & a , const VariableInterval & b )"}
{"Token type":"StructDecl","FaliureReason":"not_allowed_namespace","Implemented":false,"Namespace":"std","Name":"std::hash<poplar::VariableRef>","Filename":"poplar/VariableRef.hpp","Text":"template < > struct hash < poplar :: VariableRef > { size_t operator ( ) ( const poplar :: VariableRef & v ) const { return v . hash ( ) ; } }"}
{"Token type":"CXXMethod","FaliureReason":"not_allowed_namespace","Implemented":false,"Namespace":"std","Name":"std::hash<poplar::VariableRef>::operator()(const poplar::VariableRef &)","Filename":"poplar/VariableRef.hpp","Text":"size_t operator ( ) ( const poplar :: VariableRef & v ) const"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar::layout","Name":"poplar::layout::operator<<(std::ostream &, const poplar::layout::Vector)","Filename":"poplar/VectorLayout.hpp","Text":"std :: ostream & operator << ( std :: ostream & os , const Vector v )"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar::layout","Name":"poplar::layout::operator<<(std::ostream &, const poplar::layout::VectorList)","Filename":"poplar/VectorLayout.hpp","Text":"std :: ostream & operator << ( std :: ostream & os , const VectorList v )"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::VertexIntrospector","Filename":"poplar/VertexIntrospector.hpp","Text":"class VertexIntrospector"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::FieldData","Filename":"poplar/VertexIntrospector.hpp","Text":"class FieldData"}
{"Token type":"CXXMethod","FaliureReason":"filedata_size_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldData::SizeT::size()","Filename":"poplar/VertexIntrospector.hpp","Text":"std :: size_t size ( ) const"}
{"Token type":"CXXConstructor","FaliureReason":"deleted_method","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldData::FieldData(const poplar::FieldData &)","Filename":"poplar/VertexIntrospector.hpp","Text":"FieldData ( const FieldData & ) = delete"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldData::FieldData(poplar::FieldData &&)","Filename":"poplar/VertexIntrospector.hpp","Text":"FieldData ( FieldData && )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldData::operator[](std::size_t)","Filename":"poplar/VertexIntrospector.hpp","Text":"SizeT operator [ ] ( std :: size_t i ) const"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldData::getInitialValue(const poplar::Target &)","Filename":"poplar/VertexIntrospector.hpp","Text":"template < typename T > T getInitialValue ( const Target & target ) const"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldData::getInitialValues(const poplar::Target &)","Filename":"poplar/VertexIntrospector.hpp","Text":"template < typename T > std :: vector < T > getInitialValues ( const Target & target ) const"}
{"Token type":"CXXConstructor","FaliureReason":"unique_ptr_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldData::FieldData(std::unique_ptr<core::FieldData>)","Filename":"poplar/VertexIntrospector.hpp","Text":"FieldData ( std :: unique_ptr < core :: FieldData > fd )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldData::getInitialValuesOverload(const poplar::Target &, std::vector<T> &)","Filename":"poplar/VertexIntrospector.hpp","Text":"template < typename T > void getInitialValuesOverload ( const Target & target , std :: vector < T > & result ) const"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldData::getInitialValuesOverload(const poplar::Target &, std::vector<std::vector<T> > &)","Filename":"poplar/VertexIntrospector.hpp","Text":"template < typename T > void getInitialValuesOverload ( const Target & target , std :: vector < std :: vector < T >> & result ) const"}
{"Token type":"CXXMethod","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldData::getInitialValues(const poplar::Target &, void *, const poplar::TypeTraits &, std::size_t)","Filename":"poplar/VertexIntrospector.hpp","Text":"void getInitialValues ( const Target & target , void * dst , const TypeTraits & traits , std :: size_t index = std :: numeric_limits < std :: size_t > :: max ( ) ) const"}
{"Token type":"CXXConstructor","FaliureReason":"unique_ptr_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::VertexIntrospector::VertexIntrospector(std::unique_ptr<core::VertexIntrospector>)","Filename":"poplar/VertexIntrospector.hpp","Text":"VertexIntrospector ( std :: unique_ptr < core :: VertexIntrospector > impl )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::VertexIntrospector::VertexIntrospector(poplar::VertexIntrospector &&)","Filename":"poplar/VertexIntrospector.hpp","Text":"VertexIntrospector ( VertexIntrospector && )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::VertexIntrospector::getImpl()","Filename":"poplar/VertexIntrospector.hpp","Text":"const core :: VertexIntrospector & getImpl ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::replication_factor::operator++()","Filename":"poplar/replication_factor.hpp","Text":"replication_factor & operator ++ ( )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::replication_factor::operator==(const poplar::replication_factor)","Filename":"poplar/replication_factor.hpp","Text":"bool operator == ( const replication_factor other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::replication_factor::operator!=(const poplar::replication_factor)","Filename":"poplar/replication_factor.hpp","Text":"bool operator != ( const replication_factor other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::replication_factor::operator<(const poplar::replication_factor)","Filename":"poplar/replication_factor.hpp","Text":"bool operator < ( const replication_factor other ) const"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::GraphBuilder","Filename":"poplar/Graph.hpp","Text":"class GraphBuilder"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::Graph(poplar::Graph &&)","Filename":"poplar/Graph.hpp","Text":"Graph ( Graph && )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::operator=(poplar::Graph &&)","Filename":"poplar/Graph.hpp","Text":"Graph & operator = ( Graph && )"}
{"Token type":"CXXMethod","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::addCodelets(poplar::StringRef, poplar::CodeletFileType, poplar::StringRef, std::ostream &)","Filename":"poplar/Graph.hpp","Text":"bool addCodelets ( StringRef src , CodeletFileType type , StringRef compileFlags , std :: ostream & compileOutput )"}
{"Token type":"CXXMethod","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::addCodelets(std::stringstream &, poplar::StringRef, std::ostream &)","Filename":"poplar/Graph.hpp","Text":"void addCodelets ( std :: stringstream & stream , StringRef compileFlags , std :: ostream & compileOutput )"}
{"Token type":"EnumDecl","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::ConnectionDesc::Kind","Filename":"poplar/Graph.hpp","Text":"enum class Kind { TensorEdge , ValueEdge , VectorTensorEdge }"}
{"Token type":"EnumConstantDecl","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::ConnectionDesc::Kind::TensorEdge","Filename":"poplar/Graph.hpp","Text":"TensorEdge"}
{"Token type":"EnumConstantDecl","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::ConnectionDesc::Kind::ValueEdge","Filename":"poplar/Graph.hpp","Text":"ValueEdge"}
{"Token type":"EnumConstantDecl","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::ConnectionDesc::Kind::VectorTensorEdge","Filename":"poplar/Graph.hpp","Text":"VectorTensorEdge"}
{"Token type":"CXXMethod","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::ConnectionDesc::connect(poplar::Graph &, const poplar::VertexRef &)","Filename":"poplar/Graph.hpp","Text":"void connect ( Graph & g , const VertexRef & v ) const"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::ConnectionDesc::ConnectionDesc(poplar::StringRef, T, typename std::enable_if<TypeTraits::isSimpleType<T>()>::type *)","Filename":"poplar/Graph.hpp","Text":"template < typename T > ConnectionDesc ( StringRef field , T v , typename std :: enable_if < TypeTraits :: isSimpleType < T > ( ) > :: type * = nullptr )"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::addConstant(const poplar::Type &, ArrayRef<std::size_t>, T, const poplar::DebugContext &, typename std::enable_if<TypeTraits::isSimpleType<T>()>::type *)","Filename":"poplar/Graph.hpp","Text":"template < typename T > Tensor addConstant ( const Type & type , ArrayRef < std :: size_t > shape , T val , const DebugContext & debugContext = { \"<const>\" } , typename std :: enable_if < TypeTraits :: isSimpleType < T > ( ) > :: type * = nullptr )"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::addConstant(const poplar::Type &, ArrayRef<std::size_t>, const T *, const poplar::DebugContext &, typename std::enable_if<TypeTraits::isSimpleType<T>()>::type *)","Filename":"poplar/Graph.hpp","Text":"template < typename T > Tensor addConstant ( const Type & type , ArrayRef < std :: size_t > shape , const T * val , const DebugContext & debugContext = { \"<const>\" } , typename std :: enable_if < TypeTraits :: isSimpleType < T > ( ) > :: type * = nullptr )"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::connect(poplar::FieldRef, T, typename std::enable_if<TypeTraits::isSimpleType<T>()>::type *)","Filename":"poplar/Graph.hpp","Text":"template < typename T > void connect ( FieldRef field , T v , typename std :: enable_if < TypeTraits :: isSimpleType < T > ( ) > :: type * = nullptr )"}
{"Token type":"CXXMethod","FaliureReason":"calls_deleted_function","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::registerCycleEstimator(poplar::StringRef, poplar::CycleEstimateFunc)","Filename":"poplar/Graph.hpp","Text":"void registerCycleEstimator ( StringRef vertexTypeName , CycleEstimateFunc f )"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::setInitialValue(poplar::FieldRef, T, typename std::enable_if<TypeTraits::isSimpleType<T>()>::type *)","Filename":"poplar/Graph.hpp","Text":"template < typename T > void setInitialValue ( FieldRef field , T val , typename std :: enable_if < TypeTraits :: isSimpleType < T > ( ) > :: type * = nullptr )"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::setInitCallback(poplar::FieldRef, LateInitCallback<T>, typename std::enable_if<std::is_arithmetic<T>::value>::type *)","Filename":"poplar/Graph.hpp","Text":"template < typename T > void setInitCallback ( FieldRef field , LateInitCallback < T > callback , typename std :: enable_if < std :: is_arithmetic < T > :: value > :: type * = nullptr )"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::setInitialValue(poplar::FieldRef, const std::vector<T> &)","Filename":"poplar/Graph.hpp","Text":"template < typename T > void setInitialValue ( FieldRef field , const std :: vector < T > & v )"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::setInitialValue(poplar::FieldRef, const std::initializer_list<T> &)","Filename":"poplar/Graph.hpp","Text":"template < typename T > void setInitialValue ( FieldRef field , const std :: initializer_list < T > & l )"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::setInitialValue(const poplar::Tensor &, T, typename std::enable_if<TypeTraits::isSimpleType<T>()>::type *)","Filename":"poplar/Graph.hpp","Text":"template < typename T > void setInitialValue ( const Tensor & t , T val , typename std :: enable_if < TypeTraits :: isSimpleType < T > ( ) > :: type * = nullptr )"}
{"Token type":"CXXMethod","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::outputVertexGraph(std::ostream &, ArrayRef<program::Program>)","Filename":"poplar/Graph.hpp","Text":"void outputVertexGraph ( std :: ostream & outputStream , ArrayRef < program :: Program > progs = { } ) const"}
{"Token type":"CXXMethod","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::outputComputeGraph(std::ostream &, ArrayRef<program::Program>)","Filename":"poplar/Graph.hpp","Text":"void outputComputeGraph ( std :: ostream & outputStream , ArrayRef < program :: Program > progs = { } ) const"}
{"Token type":"CXXMethod","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::serializeTensors(std::ostream &, ArrayRef<poplar::Tensor>, poplar::SerializationFormat)","Filename":"poplar/Graph.hpp","Text":"void serializeTensors ( std :: ostream & out , ArrayRef < Tensor > tensors , SerializationFormat format ) const"}
{"Token type":"CXXMethod","FaliureReason":"istream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::deserializeTensors(std::istream &, poplar::SerializationFormat)","Filename":"poplar/Graph.hpp","Text":"std :: vector < Tensor > deserializeTensors ( std :: istream & in , SerializationFormat format )"}
{"Token type":"CXXMethod","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::serialize(std::ostream &, poplar::SerializationFormat)","Filename":"poplar/Graph.hpp","Text":"void serialize ( std :: ostream & out , SerializationFormat format ) const"}
{"Token type":"CXXMethod","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::serialize(std::ostream &, ArrayRef<program::Program>, poplar::SerializationFormat)","Filename":"poplar/Graph.hpp","Text":"void serialize ( std :: ostream & out , ArrayRef < program :: Program > progs , SerializationFormat format ) const"}
{"Token type":"CXXConstructor","FaliureReason":"unique_ptr_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::Graph(std::unique_ptr<core::GraphBuilder>, poplar::Target)","Filename":"poplar/Graph.hpp","Text":"Graph ( std :: unique_ptr < core :: GraphBuilder > , Target target )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::getImpl()","Filename":"poplar/Graph.hpp","Text":"core :: GraphBuilder & getImpl ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::setInitialValue(poplar::FieldRef, const void *, const poplar::TypeTraits &)","Filename":"poplar/Graph.hpp","Text":"void setInitialValue ( FieldRef field , const void * val , const TypeTraits & )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::setInitCallback(poplar::FieldRef, LateInitCallback<T>, const poplar::TypeTraits &)","Filename":"poplar/Graph.hpp","Text":"template < typename T > void setInitCallback ( FieldRef field , LateInitCallback < T > callback , const TypeTraits & )"}
{"Token type":"CXXMethod","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::setInitialValue(const poplar::Tensor &, const void *, const poplar::TypeTraits &)","Filename":"poplar/Graph.hpp","Text":"void setInitialValue ( const Tensor & t , const void * val , const TypeTraits & )"}
{"Token type":"CXXMethod","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::connect(poplar::FieldRef, void *, const poplar::TypeTraits &)","Filename":"poplar/Graph.hpp","Text":"void connect ( FieldRef field , void * val , const TypeTraits & )"}
{"Token type":"CXXMethod","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::checkFieldSubgraph(const poplar::FieldRef &)","Filename":"poplar/Graph.hpp","Text":"void checkFieldSubgraph ( const FieldRef & f ) const"}
{"Token type":"CXXMethod","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::checkVertexSubgraph(const poplar::VertexRef &)","Filename":"poplar/Graph.hpp","Text":"void checkVertexSubgraph ( const VertexRef & v ) const"}
{"Token type":"EnumDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::TernaryOpType","Filename":"popops/ExprOp.hpp","Text":"enum class TernaryOpType { CLAMP , SELECT }"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::TernaryOpType::CLAMP","Filename":"popops/ExprOp.hpp","Text":"CLAMP"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::TernaryOpType::SELECT","Filename":"popops/ExprOp.hpp","Text":"SELECT"}
{"Token type":"EnumDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::BinaryOpType","Filename":"popops/ExprOp.hpp","Text":"enum class BinaryOpType { ADD , ATAN2 , BITWISE_AND , BITWISE_OR , BITWISE_XOR , BITWISE_XNOR , DIVIDE , EQUAL , GREATER_THAN_EQUAL , GREATER_THAN , INV_STD_DEV_TO_VARIANCE , LESS_THAN_EQUAL , LOGICAL_AND , LOGICAL_OR , LESS_THAN , MAXIMUM , MINIMUM , MULTIPLY , NOT_EQUAL , POWER , REMAINDER , SHIFT_LEFT , SHIFT_RIGHT , SHIFT_RIGHT_SIGN_EXTEND , SUBTRACT , VARIANCE_TO_INV_STD_DEV }"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::BinaryOpType::ADD","Filename":"popops/ExprOp.hpp","Text":"ADD"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::BinaryOpType::ATAN2","Filename":"popops/ExprOp.hpp","Text":"ATAN2"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::BinaryOpType::BITWISE_AND","Filename":"popops/ExprOp.hpp","Text":"BITWISE_AND"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::BinaryOpType::BITWISE_OR","Filename":"popops/ExprOp.hpp","Text":"BITWISE_OR"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::BinaryOpType::BITWISE_XOR","Filename":"popops/ExprOp.hpp","Text":"BITWISE_XOR"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::BinaryOpType::BITWISE_XNOR","Filename":"popops/ExprOp.hpp","Text":"BITWISE_XNOR"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::BinaryOpType::DIVIDE","Filename":"popops/ExprOp.hpp","Text":"DIVIDE"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::BinaryOpType::EQUAL","Filename":"popops/ExprOp.hpp","Text":"EQUAL"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::BinaryOpType::GREATER_THAN_EQUAL","Filename":"popops/ExprOp.hpp","Text":"GREATER_THAN_EQUAL"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::BinaryOpType::GREATER_THAN","Filename":"popops/ExprOp.hpp","Text":"GREATER_THAN"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::BinaryOpType::INV_STD_DEV_TO_VARIANCE","Filename":"popops/ExprOp.hpp","Text":"INV_STD_DEV_TO_VARIANCE"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::BinaryOpType::LESS_THAN_EQUAL","Filename":"popops/ExprOp.hpp","Text":"LESS_THAN_EQUAL"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::BinaryOpType::LOGICAL_AND","Filename":"popops/ExprOp.hpp","Text":"LOGICAL_AND"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::BinaryOpType::LOGICAL_OR","Filename":"popops/ExprOp.hpp","Text":"LOGICAL_OR"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::BinaryOpType::LESS_THAN","Filename":"popops/ExprOp.hpp","Text":"LESS_THAN"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::BinaryOpType::MAXIMUM","Filename":"popops/ExprOp.hpp","Text":"MAXIMUM"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::BinaryOpType::MINIMUM","Filename":"popops/ExprOp.hpp","Text":"MINIMUM"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::BinaryOpType::MULTIPLY","Filename":"popops/ExprOp.hpp","Text":"MULTIPLY"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::BinaryOpType::NOT_EQUAL","Filename":"popops/ExprOp.hpp","Text":"NOT_EQUAL"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::BinaryOpType::POWER","Filename":"popops/ExprOp.hpp","Text":"POWER"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::BinaryOpType::REMAINDER","Filename":"popops/ExprOp.hpp","Text":"REMAINDER"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::BinaryOpType::SHIFT_LEFT","Filename":"popops/ExprOp.hpp","Text":"SHIFT_LEFT"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::BinaryOpType::SHIFT_RIGHT","Filename":"popops/ExprOp.hpp","Text":"SHIFT_RIGHT"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::BinaryOpType::SHIFT_RIGHT_SIGN_EXTEND","Filename":"popops/ExprOp.hpp","Text":"SHIFT_RIGHT_SIGN_EXTEND"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::BinaryOpType::SUBTRACT","Filename":"popops/ExprOp.hpp","Text":"SUBTRACT"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::BinaryOpType::VARIANCE_TO_INV_STD_DEV","Filename":"popops/ExprOp.hpp","Text":"VARIANCE_TO_INV_STD_DEV"}
{"Token type":"EnumDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::UnaryOpType","Filename":"popops/ExprOp.hpp","Text":"enum class UnaryOpType { ABSOLUTE , ASIN , BITWISE_NOT , CEIL , COS , COUNT_LEADING_ZEROS , EXPONENT , EXPONENT_MINUS_ONE , FLOOR , INVERSE , IS_FINITE , IS_INF , IS_NAN , LOGARITHM , LOGARITHM_ONE_PLUS , LOGICAL_NOT , NEGATE , POPCOUNT , SIGNUM , SIN , TAN , TANH , ROUND , SQRT , SQUARE , SIGMOID , RSQRT }"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::UnaryOpType::ABSOLUTE","Filename":"popops/ExprOp.hpp","Text":"ABSOLUTE"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::UnaryOpType::ASIN","Filename":"popops/ExprOp.hpp","Text":"ASIN"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::UnaryOpType::BITWISE_NOT","Filename":"popops/ExprOp.hpp","Text":"BITWISE_NOT"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::UnaryOpType::CEIL","Filename":"popops/ExprOp.hpp","Text":"CEIL"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::UnaryOpType::COS","Filename":"popops/ExprOp.hpp","Text":"COS"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::UnaryOpType::COUNT_LEADING_ZEROS","Filename":"popops/ExprOp.hpp","Text":"COUNT_LEADING_ZEROS"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::UnaryOpType::EXPONENT","Filename":"popops/ExprOp.hpp","Text":"EXPONENT"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::UnaryOpType::EXPONENT_MINUS_ONE","Filename":"popops/ExprOp.hpp","Text":"EXPONENT_MINUS_ONE"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::UnaryOpType::FLOOR","Filename":"popops/ExprOp.hpp","Text":"FLOOR"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::UnaryOpType::INVERSE","Filename":"popops/ExprOp.hpp","Text":"INVERSE"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::UnaryOpType::IS_FINITE","Filename":"popops/ExprOp.hpp","Text":"IS_FINITE"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::UnaryOpType::IS_INF","Filename":"popops/ExprOp.hpp","Text":"IS_INF"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::UnaryOpType::IS_NAN","Filename":"popops/ExprOp.hpp","Text":"IS_NAN"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::UnaryOpType::LOGARITHM","Filename":"popops/ExprOp.hpp","Text":"LOGARITHM"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::UnaryOpType::LOGARITHM_ONE_PLUS","Filename":"popops/ExprOp.hpp","Text":"LOGARITHM_ONE_PLUS"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::UnaryOpType::LOGICAL_NOT","Filename":"popops/ExprOp.hpp","Text":"LOGICAL_NOT"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::UnaryOpType::NEGATE","Filename":"popops/ExprOp.hpp","Text":"NEGATE"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::UnaryOpType::POPCOUNT","Filename":"popops/ExprOp.hpp","Text":"POPCOUNT"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::UnaryOpType::SIGNUM","Filename":"popops/ExprOp.hpp","Text":"SIGNUM"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::UnaryOpType::SIN","Filename":"popops/ExprOp.hpp","Text":"SIN"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::UnaryOpType::TAN","Filename":"popops/ExprOp.hpp","Text":"TAN"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::UnaryOpType::TANH","Filename":"popops/ExprOp.hpp","Text":"TANH"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::UnaryOpType::ROUND","Filename":"popops/ExprOp.hpp","Text":"ROUND"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::UnaryOpType::SQRT","Filename":"popops/ExprOp.hpp","Text":"SQRT"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::UnaryOpType::SQUARE","Filename":"popops/ExprOp.hpp","Text":"SQUARE"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::UnaryOpType::SIGMOID","Filename":"popops/ExprOp.hpp","Text":"SIGMOID"}
{"Token type":"EnumConstantDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::UnaryOpType::RSQRT","Filename":"popops/ExprOp.hpp","Text":"RSQRT"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Expr","Filename":"popops/Expr.hpp","Text":"class Expr { protected : using ExprClassID = void ( * ) ( void ) ; ExprClassID classId ; Expr ( ExprClassID classId ) : classId ( classId ) { } public : virtual ~ Expr ( ) ; template < class T > bool isA ( ) const { return classId == T :: getClassId ( ) ; } template < class T > T * getAs ( ) { if ( ! isA < T > ( ) ) return 0 ; return static_cast < T * > ( this ) ; } template < class T > const T * getAs ( ) const { if ( ! isA < T > ( ) ) return 0 ; return static_cast < const T * > ( this ) ; } virtual std :: unique_ptr < Expr > clone ( ) const = 0 ; virtual std :: string name ( const std :: vector < poplar :: Tensor > & ) const = 0 ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Expr::Expr(popops::expr::Expr::ExprClassID)","Filename":"popops/Expr.hpp","Text":"Expr ( ExprClassID classId )"}
{"Token type":"FunctionTemplate","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Expr::isA()","Filename":"popops/Expr.hpp","Text":"template < class T > bool isA ( ) const"}
{"Token type":"FunctionTemplate","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Expr::getAs()","Filename":"popops/Expr.hpp","Text":"template < class T > T * getAs ( )"}
{"Token type":"FunctionTemplate","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Expr::getAs()","Filename":"popops/Expr.hpp","Text":"template < class T > const T * getAs ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Expr::clone()","Filename":"popops/Expr.hpp","Text":"virtual std :: unique_ptr < Expr > clone ( ) const = 0"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Expr::name(const std::vector<poplar::Tensor> &)","Filename":"popops/Expr.hpp","Text":"virtual std :: string name ( const std :: vector < poplar :: Tensor > & ) const = 0"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::ExprType<T>::loc()","Filename":"popops/Expr.hpp","Text":"static void loc ( )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::ExprType<T>::getClassId()","Filename":"popops/Expr.hpp","Text":"static ExprClassID getClassId ( )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::ExprType<T>::ExprType<T>()","Filename":"popops/Expr.hpp","Text":"ExprType ( )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Any","Filename":"popops/Expr.hpp","Text":"class Any { std :: unique_ptr < Expr > expr ; public : Any ( const Expr & expr ) : expr ( expr . clone ( ) ) { } operator Expr & ( ) { return * expr ; } operator const Expr & ( ) const { return * expr ; } std :: string name ( const std :: vector < poplar :: Tensor > & inputs ) const { return expr -> name ( inputs ) ; } }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Any::Any(const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"Any ( const Expr & expr )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Any::name(const std::vector<poplar::Tensor> &)","Filename":"popops/Expr.hpp","Text":"std :: string name ( const std :: vector < poplar :: Tensor > & inputs ) const"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Const","Filename":"popops/Expr.hpp","Text":"class Const : public ExprType < Const > { poplar :: TypeTraits typeTraits ; poplar :: Type type ; std :: unique_ptr < char [ ] > data ; protected : template < typename T > Const ( T x , bool isHalfType ) { static_assert ( std :: is_integral < T > :: value || std :: is_floating_point < T > :: value , \"Constant expression values should be integrals or floats\" ) ; typeTraits = poplar :: TypeTraits :: make < T > ( ) ; if ( isHalfType ) { type = poplar :: HALF ; } else { type = poplar :: equivalent_device_type < T > ( ) . value ; } data . reset ( new char [ typeTraits . size ] ) ; const char * p = reinterpret_cast < const char * > ( & x ) ; std :: copy ( p , p + typeTraits . size , data . get ( ) ) ; } public : template < typename T > Const ( T x ) : Const ( x , false ) { } Const ( poplar :: TypeTraits typeTraits_ , poplar :: Type type_ , const char * data_ ) : typeTraits ( std :: move ( typeTraits_ ) ) , type ( type_ ) { data . reset ( new char [ typeTraits . size ] ) ; std :: copy ( data_ , data_ + typeTraits . size , data . get ( ) ) ; } char * getData ( ) const { return data . get ( ) ; } const poplar :: TypeTraits & getTypeTraits ( ) const { return typeTraits ; } const poplar :: Type & getType ( ) const { return type ; } std :: string printValue ( ) const ; double getDataAsDouble ( ) const ; std :: unique_ptr < Expr > clone ( ) const override { return std :: unique_ptr < Expr > ( new Const ( typeTraits , type , data . get ( ) ) ) ; } std :: string name ( const std :: vector < poplar :: Tensor > & ) const override ; }"}
{"Token type":"FunctionTemplate","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Const::Const(T, bool)","Filename":"popops/Expr.hpp","Text":"template < typename T > Const ( T x , bool isHalfType )"}
{"Token type":"FunctionTemplate","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Const::Const(T)","Filename":"popops/Expr.hpp","Text":"template < typename T > Const ( T x )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Const::Const(poplar::TypeTraits, poplar::Type, const char *)","Filename":"popops/Expr.hpp","Text":"Const ( poplar :: TypeTraits typeTraits_ , poplar :: Type type_ , const char * data_ )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Const::getData()","Filename":"popops/Expr.hpp","Text":"char * getData ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Const::getTypeTraits()","Filename":"popops/Expr.hpp","Text":"const poplar :: TypeTraits & getTypeTraits ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Const::getType()","Filename":"popops/Expr.hpp","Text":"const poplar :: Type & getType ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Const::printValue()","Filename":"popops/Expr.hpp","Text":"std :: string printValue ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Const::getDataAsDouble()","Filename":"popops/Expr.hpp","Text":"double getDataAsDouble ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Const::clone()","Filename":"popops/Expr.hpp","Text":"std :: unique_ptr < Expr > clone ( ) const override"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Const::name(const std::vector<poplar::Tensor> &)","Filename":"popops/Expr.hpp","Text":"std :: string name ( const std :: vector < poplar :: Tensor > & ) const override"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::ConstHalf","Filename":"popops/Expr.hpp","Text":"class ConstHalf : public Const { public : ConstHalf ( float x ) : Const ( x , true ) { } }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::ConstHalf::ConstHalf(float)","Filename":"popops/Expr.hpp","Text":"ConstHalf ( float x )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator\"\"_half(long double)","Filename":"popops/Expr.hpp","Text":"inline ConstHalf operator \"\" _half ( long double x )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Cast","Filename":"popops/Expr.hpp","Text":"class Cast : public ExprType < Cast > { std :: unique_ptr < Expr > a ; poplar :: Type bType ; public : Cast ( const Expr & a_ , const poplar :: Type bType_ ) : a ( a_ . clone ( ) ) , bType ( bType_ ) { } const Expr & getLHS ( ) const { return * a ; } const poplar :: Type & getRHSType ( ) const { return bType ; } std :: unique_ptr < Expr > clone ( ) const override { return std :: unique_ptr < Expr > ( new Cast ( * a , bType ) ) ; } std :: string name ( const std :: vector < poplar :: Tensor > & inputs ) const override ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Cast::Cast(const popops::expr::Expr &, const poplar::Type)","Filename":"popops/Expr.hpp","Text":"Cast ( const Expr & a_ , const poplar :: Type bType_ )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Cast::getLHS()","Filename":"popops/Expr.hpp","Text":"const Expr & getLHS ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Cast::getRHSType()","Filename":"popops/Expr.hpp","Text":"const poplar :: Type & getRHSType ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Cast::clone()","Filename":"popops/Expr.hpp","Text":"std :: unique_ptr < Expr > clone ( ) const override"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Cast::name(const std::vector<poplar::Tensor> &)","Filename":"popops/Expr.hpp","Text":"std :: string name ( const std :: vector < poplar :: Tensor > & inputs ) const override"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::PlaceHolder","Filename":"popops/Expr.hpp","Text":"class PlaceHolder : public ExprType < PlaceHolder > { unsigned index ; public : PlaceHolder ( unsigned index ) : index ( index ) { } unsigned getIndex ( ) const { return index ; } std :: unique_ptr < Expr > clone ( ) const override { return std :: unique_ptr < Expr > ( new PlaceHolder ( index ) ) ; } std :: string name ( const std :: vector < poplar :: Tensor > & inputs ) const override ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::PlaceHolder::PlaceHolder(unsigned int)","Filename":"popops/Expr.hpp","Text":"PlaceHolder ( unsigned index )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::PlaceHolder::getIndex()","Filename":"popops/Expr.hpp","Text":"unsigned getIndex ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::PlaceHolder::clone()","Filename":"popops/Expr.hpp","Text":"std :: unique_ptr < Expr > clone ( ) const override"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::PlaceHolder::name(const std::vector<poplar::Tensor> &)","Filename":"popops/Expr.hpp","Text":"std :: string name ( const std :: vector < poplar :: Tensor > & inputs ) const override"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::UnaryOp","Filename":"popops/Expr.hpp","Text":"class UnaryOp : public ExprType < UnaryOp > { static const std :: vector < std :: string > UnaryOpNames ; UnaryOpType type ; std :: unique_ptr < Expr > a ; public : UnaryOp ( UnaryOpType type , const Expr & a ) : type ( type ) , a ( a . clone ( ) ) { } UnaryOpType getOpType ( ) const { return type ; } const Expr & getArg ( ) const { return * a ; } std :: unique_ptr < Expr > clone ( ) const override { return std :: unique_ptr < Expr > ( new UnaryOp ( type , * a ) ) ; } std :: string name ( const std :: vector < poplar :: Tensor > & inputs ) const override { return UnaryOpNames [ static_cast < unsigned > ( type ) ] + \"u_\" + a -> name ( inputs ) + \"_d\" ; } std :: string exprName ( const std :: vector < poplar :: Tensor > & inputs ) const { return a -> name ( inputs ) ; } ; }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::UnaryOp::UnaryOp(popops::expr::UnaryOpType, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"UnaryOp ( UnaryOpType type , const Expr & a )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::UnaryOp::getOpType()","Filename":"popops/Expr.hpp","Text":"UnaryOpType getOpType ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::UnaryOp::getArg()","Filename":"popops/Expr.hpp","Text":"const Expr & getArg ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::UnaryOp::clone()","Filename":"popops/Expr.hpp","Text":"std :: unique_ptr < Expr > clone ( ) const override"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::UnaryOp::name(const std::vector<poplar::Tensor> &)","Filename":"popops/Expr.hpp","Text":"std :: string name ( const std :: vector < poplar :: Tensor > & inputs ) const override"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::UnaryOp::exprName(const std::vector<poplar::Tensor> &)","Filename":"popops/Expr.hpp","Text":"std :: string exprName ( const std :: vector < poplar :: Tensor > & inputs ) const"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Abs","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP ( Abs , ABSOLUTE )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Abs::Abs(const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP ( Abs , ABSOLUTE )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Asin","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP ( Asin , ASIN )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Asin::Asin(const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP ( Asin , ASIN )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::BitwiseNot","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP_AND_SYMBOL ( BitwiseNot , BITWISE_NOT , ~ )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::BitwiseNot::BitwiseNot(const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP_AND_SYMBOL ( BitwiseNot , BITWISE_NOT , ~ )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator~(const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP_AND_SYMBOL ( BitwiseNot , BITWISE_NOT , ~ )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Ceil","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP ( Ceil , CEIL )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Ceil::Ceil(const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP ( Ceil , CEIL )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Cos","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP ( Cos , COS )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Cos::Cos(const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP ( Cos , COS )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Exp","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP ( Exp , EXPONENT )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Exp::Exp(const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP ( Exp , EXPONENT )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Expm1","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP ( Expm1 , EXPONENT_MINUS_ONE )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Expm1::Expm1(const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP ( Expm1 , EXPONENT_MINUS_ONE )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Floor","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP ( Floor , FLOOR )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Floor::Floor(const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP ( Floor , FLOOR )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Inv","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP ( Inv , INVERSE )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Inv::Inv(const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP ( Inv , INVERSE )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::IsFinite","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP ( IsFinite , IS_FINITE )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::IsFinite::IsFinite(const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP ( IsFinite , IS_FINITE )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::IsInf","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP ( IsInf , IS_INF )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::IsInf::IsInf(const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP ( IsInf , IS_INF )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::IsNaN","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP ( IsNaN , IS_NAN )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::IsNaN::IsNaN(const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP ( IsNaN , IS_NAN )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Log","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP ( Log , LOGARITHM )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Log::Log(const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP ( Log , LOGARITHM )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Log1p","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP ( Log1p , LOGARITHM_ONE_PLUS )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Log1p::Log1p(const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP ( Log1p , LOGARITHM_ONE_PLUS )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Not","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP_AND_SYMBOL ( Not , LOGICAL_NOT , ! )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Not::Not(const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP_AND_SYMBOL ( Not , LOGICAL_NOT , ! )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator!(const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP_AND_SYMBOL ( Not , LOGICAL_NOT , ! )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Neg","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP_AND_SYMBOL ( Neg , NEGATE , - )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Neg::Neg(const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP_AND_SYMBOL ( Neg , NEGATE , - )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator-(const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP_AND_SYMBOL ( Neg , NEGATE , - )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Signum","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP ( Signum , SIGNUM )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Signum::Signum(const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP ( Signum , SIGNUM )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Sin","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP ( Sin , SIN )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Sin::Sin(const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP ( Sin , SIN )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Tan","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP ( Tan , TAN )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Tan::Tan(const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP ( Tan , TAN )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Tanh","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP ( Tanh , TANH )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Tanh::Tanh(const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP ( Tanh , TANH )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Round","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP ( Round , ROUND )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Round::Round(const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP ( Round , ROUND )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Sqrt","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP ( Sqrt , SQRT )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Sqrt::Sqrt(const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP ( Sqrt , SQRT )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Square","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP ( Square , SQUARE )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Square::Square(const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP ( Square , SQUARE )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Sigmoid","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP ( Sigmoid , SIGMOID )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Sigmoid::Sigmoid(const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP ( Sigmoid , SIGMOID )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Rsqrt","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP ( Rsqrt , RSQRT )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Rsqrt::Rsqrt(const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_UNARY_OP ( Rsqrt , RSQRT )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::BinaryOp","Filename":"popops/Expr.hpp","Text":"class BinaryOp : public ExprType < BinaryOp > { static const std :: vector < std :: string > BinaryOpNames ; BinaryOpType type ; std :: unique_ptr < Expr > a , b ; public : BinaryOp ( BinaryOpType type , const Expr & a , const Expr & b ) : type ( type ) , a ( a . clone ( ) ) , b ( b . clone ( ) ) { } BinaryOpType getOpType ( ) const { return type ; } const Expr & getLHS ( ) const { return * a ; } const Expr & getRHS ( ) const { return * b ; } std :: unique_ptr < Expr > clone ( ) const override { return std :: unique_ptr < Expr > ( new BinaryOp ( type , * a , * b ) ) ; } std :: string name ( const std :: vector < poplar :: Tensor > & inputs ) const override { return BinaryOpNames [ static_cast < unsigned > ( type ) ] + \"u_\" + a -> name ( inputs ) + \"_\" + b -> name ( inputs ) + \"_d\" ; } std :: string exprName ( const std :: vector < poplar :: Tensor > & inputs ) const { return a -> name ( inputs ) + \"_\" + b -> name ( inputs ) ; } }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::BinaryOp::BinaryOp(popops::expr::BinaryOpType, const popops::expr::Expr &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"BinaryOp ( BinaryOpType type , const Expr & a , const Expr & b )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::BinaryOp::getOpType()","Filename":"popops/Expr.hpp","Text":"BinaryOpType getOpType ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::BinaryOp::getLHS()","Filename":"popops/Expr.hpp","Text":"const Expr & getLHS ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::BinaryOp::getRHS()","Filename":"popops/Expr.hpp","Text":"const Expr & getRHS ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::BinaryOp::clone()","Filename":"popops/Expr.hpp","Text":"std :: unique_ptr < Expr > clone ( ) const override"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::BinaryOp::name(const std::vector<poplar::Tensor> &)","Filename":"popops/Expr.hpp","Text":"std :: string name ( const std :: vector < poplar :: Tensor > & inputs ) const override"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::BinaryOp::exprName(const std::vector<poplar::Tensor> &)","Filename":"popops/Expr.hpp","Text":"std :: string exprName ( const std :: vector < poplar :: Tensor > & inputs ) const"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Add","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Add , ADD , + )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Add::Add(const popops::expr::Expr &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Add , ADD , + )"}
{"Token type":"FunctionTemplate","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator+(const T &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Add , ADD , + )"}
{"Token type":"FunctionTemplate","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator+(const popops::expr::Expr &, const T &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Add , ADD , + )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator+(const popops::expr::Expr &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Add , ADD , + )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Atan2","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP ( Atan2 , ATAN2 )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Atan2::Atan2(const popops::expr::Expr &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP ( Atan2 , ATAN2 )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::BitwiseAnd","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( BitwiseAnd , BITWISE_AND , & )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::BitwiseAnd::BitwiseAnd(const popops::expr::Expr &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( BitwiseAnd , BITWISE_AND , & )"}
{"Token type":"FunctionTemplate","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator&(const T &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( BitwiseAnd , BITWISE_AND , & )"}
{"Token type":"FunctionTemplate","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator&(const popops::expr::Expr &, const T &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( BitwiseAnd , BITWISE_AND , & )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator&(const popops::expr::Expr &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( BitwiseAnd , BITWISE_AND , & )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::BitwiseOr","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( BitwiseOr , BITWISE_OR , | )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::BitwiseOr::BitwiseOr(const popops::expr::Expr &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( BitwiseOr , BITWISE_OR , | )"}
{"Token type":"FunctionTemplate","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator|(const T &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( BitwiseOr , BITWISE_OR , | )"}
{"Token type":"FunctionTemplate","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator|(const popops::expr::Expr &, const T &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( BitwiseOr , BITWISE_OR , | )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator|(const popops::expr::Expr &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( BitwiseOr , BITWISE_OR , | )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::BitwiseXor","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( BitwiseXor , BITWISE_XOR , ^ )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::BitwiseXor::BitwiseXor(const popops::expr::Expr &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( BitwiseXor , BITWISE_XOR , ^ )"}
{"Token type":"FunctionTemplate","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator^(const T &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( BitwiseXor , BITWISE_XOR , ^ )"}
{"Token type":"FunctionTemplate","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator^(const popops::expr::Expr &, const T &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( BitwiseXor , BITWISE_XOR , ^ )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator^(const popops::expr::Expr &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( BitwiseXor , BITWISE_XOR , ^ )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::BitwiseXnor","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP ( BitwiseXnor , BITWISE_XNOR )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::BitwiseXnor::BitwiseXnor(const popops::expr::Expr &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP ( BitwiseXnor , BITWISE_XNOR )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Divide","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Divide , DIVIDE , / )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Divide::Divide(const popops::expr::Expr &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Divide , DIVIDE , / )"}
{"Token type":"FunctionTemplate","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator/(const T &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Divide , DIVIDE , / )"}
{"Token type":"FunctionTemplate","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator/(const popops::expr::Expr &, const T &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Divide , DIVIDE , / )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator/(const popops::expr::Expr &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Divide , DIVIDE , / )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Equal","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Equal , EQUAL , == )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Equal::Equal(const popops::expr::Expr &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Equal , EQUAL , == )"}
{"Token type":"FunctionTemplate","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator==(const T &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Equal , EQUAL , == )"}
{"Token type":"FunctionTemplate","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator==(const popops::expr::Expr &, const T &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Equal , EQUAL , == )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator==(const popops::expr::Expr &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Equal , EQUAL , == )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Gte","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Gte , GREATER_THAN_EQUAL , >= )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Gte::Gte(const popops::expr::Expr &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Gte , GREATER_THAN_EQUAL , >= )"}
{"Token type":"FunctionTemplate","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator>=(const T &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Gte , GREATER_THAN_EQUAL , >= )"}
{"Token type":"FunctionTemplate","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator>=(const popops::expr::Expr &, const T &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Gte , GREATER_THAN_EQUAL , >= )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator>=(const popops::expr::Expr &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Gte , GREATER_THAN_EQUAL , >= )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Gt","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Gt , GREATER_THAN , > )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Gt::Gt(const popops::expr::Expr &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Gt , GREATER_THAN , > )"}
{"Token type":"FunctionTemplate","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator>(const T &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Gt , GREATER_THAN , > )"}
{"Token type":"FunctionTemplate","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator>(const popops::expr::Expr &, const T &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Gt , GREATER_THAN , > )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator>(const popops::expr::Expr &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Gt , GREATER_THAN , > )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Lte","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Lte , LESS_THAN_EQUAL , <= )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Lte::Lte(const popops::expr::Expr &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Lte , LESS_THAN_EQUAL , <= )"}
{"Token type":"FunctionTemplate","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator<=(const T &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Lte , LESS_THAN_EQUAL , <= )"}
{"Token type":"FunctionTemplate","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator<=(const popops::expr::Expr &, const T &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Lte , LESS_THAN_EQUAL , <= )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator<=(const popops::expr::Expr &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Lte , LESS_THAN_EQUAL , <= )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::And","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( And , LOGICAL_AND , && )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::And::And(const popops::expr::Expr &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( And , LOGICAL_AND , && )"}
{"Token type":"FunctionTemplate","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator&&(const T &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( And , LOGICAL_AND , && )"}
{"Token type":"FunctionTemplate","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator&&(const popops::expr::Expr &, const T &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( And , LOGICAL_AND , && )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator&&(const popops::expr::Expr &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( And , LOGICAL_AND , && )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Or","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Or , LOGICAL_OR , || )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Or::Or(const popops::expr::Expr &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Or , LOGICAL_OR , || )"}
{"Token type":"FunctionTemplate","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator||(const T &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Or , LOGICAL_OR , || )"}
{"Token type":"FunctionTemplate","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator||(const popops::expr::Expr &, const T &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Or , LOGICAL_OR , || )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator||(const popops::expr::Expr &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Or , LOGICAL_OR , || )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Lt","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Lt , LESS_THAN , < )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Lt::Lt(const popops::expr::Expr &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Lt , LESS_THAN , < )"}
{"Token type":"FunctionTemplate","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator<(const T &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Lt , LESS_THAN , < )"}
{"Token type":"FunctionTemplate","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator<(const popops::expr::Expr &, const T &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Lt , LESS_THAN , < )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator<(const popops::expr::Expr &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Lt , LESS_THAN , < )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::InvStdDevToVariance","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP ( InvStdDevToVariance , INV_STD_DEV_TO_VARIANCE )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::InvStdDevToVariance::InvStdDevToVariance(const popops::expr::Expr &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP ( InvStdDevToVariance , INV_STD_DEV_TO_VARIANCE )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Max","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP ( Max , MAXIMUM )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Max::Max(const popops::expr::Expr &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP ( Max , MAXIMUM )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Min","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP ( Min , MINIMUM )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Min::Min(const popops::expr::Expr &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP ( Min , MINIMUM )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Mul","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Mul , MULTIPLY , * )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Mul::Mul(const popops::expr::Expr &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Mul , MULTIPLY , * )"}
{"Token type":"FunctionTemplate","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator*(const T &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Mul , MULTIPLY , * )"}
{"Token type":"FunctionTemplate","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator*(const popops::expr::Expr &, const T &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Mul , MULTIPLY , * )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator*(const popops::expr::Expr &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Mul , MULTIPLY , * )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::NotEqual","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( NotEqual , NOT_EQUAL , != )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::NotEqual::NotEqual(const popops::expr::Expr &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( NotEqual , NOT_EQUAL , != )"}
{"Token type":"FunctionTemplate","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator!=(const T &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( NotEqual , NOT_EQUAL , != )"}
{"Token type":"FunctionTemplate","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator!=(const popops::expr::Expr &, const T &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( NotEqual , NOT_EQUAL , != )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator!=(const popops::expr::Expr &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( NotEqual , NOT_EQUAL , != )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Pow","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP ( Pow , POWER )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Pow::Pow(const popops::expr::Expr &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP ( Pow , POWER )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Rem","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Rem , REMAINDER , % )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Rem::Rem(const popops::expr::Expr &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Rem , REMAINDER , % )"}
{"Token type":"FunctionTemplate","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator%(const T &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Rem , REMAINDER , % )"}
{"Token type":"FunctionTemplate","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator%(const popops::expr::Expr &, const T &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Rem , REMAINDER , % )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator%(const popops::expr::Expr &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Rem , REMAINDER , % )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Shl","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Shl , SHIFT_LEFT , << )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Shl::Shl(const popops::expr::Expr &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Shl , SHIFT_LEFT , << )"}
{"Token type":"FunctionTemplate","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator<<(const T &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Shl , SHIFT_LEFT , << )"}
{"Token type":"FunctionTemplate","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator<<(const popops::expr::Expr &, const T &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Shl , SHIFT_LEFT , << )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator<<(const popops::expr::Expr &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Shl , SHIFT_LEFT , << )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Shr","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Shr , SHIFT_RIGHT , >> )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Shr::Shr(const popops::expr::Expr &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Shr , SHIFT_RIGHT , >> )"}
{"Token type":"FunctionTemplate","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator>>(const T &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Shr , SHIFT_RIGHT , >> )"}
{"Token type":"FunctionTemplate","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator>>(const popops::expr::Expr &, const T &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Shr , SHIFT_RIGHT , >> )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator>>(const popops::expr::Expr &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Shr , SHIFT_RIGHT , >> )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::ShrSE","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP ( ShrSE , SHIFT_RIGHT_SIGN_EXTEND )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::ShrSE::ShrSE(const popops::expr::Expr &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP ( ShrSE , SHIFT_RIGHT_SIGN_EXTEND )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Sub","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Sub , SUBTRACT , - )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Sub::Sub(const popops::expr::Expr &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Sub , SUBTRACT , - )"}
{"Token type":"FunctionTemplate","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator-(const T &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Sub , SUBTRACT , - )"}
{"Token type":"FunctionTemplate","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator-(const popops::expr::Expr &, const T &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Sub , SUBTRACT , - )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::operator-(const popops::expr::Expr &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP_AND_SYMBOL ( Sub , SUBTRACT , - )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::VarianceToInvStdDev","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP ( VarianceToInvStdDev , VARIANCE_TO_INV_STD_DEV )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::VarianceToInvStdDev::VarianceToInvStdDev(const popops::expr::Expr &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_BINARY_OP ( VarianceToInvStdDev , VARIANCE_TO_INV_STD_DEV )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::TernaryOp","Filename":"popops/Expr.hpp","Text":"class TernaryOp : public ExprType < TernaryOp > { static const std :: vector < std :: string > TernaryOpNames ; TernaryOpType type ; std :: unique_ptr < Expr > a , b , c ; public : TernaryOp ( TernaryOpType type , const Expr & a , const Expr & b , const Expr & c ) : type ( type ) , a ( a . clone ( ) ) , b ( b . clone ( ) ) , c ( c . clone ( ) ) { } TernaryOpType getOpType ( ) const { return type ; } const Expr & getArg0 ( ) const { return * a ; } const Expr & getArg1 ( ) const { return * b ; } const Expr & getArg2 ( ) const { return * c ; } std :: unique_ptr < Expr > clone ( ) const override { return std :: unique_ptr < Expr > ( new TernaryOp ( type , * a , * b , * c ) ) ; } std :: string name ( const std :: vector < poplar :: Tensor > & inputs ) const override { return TernaryOpNames [ static_cast < unsigned > ( type ) ] + \"u_\" + exprName ( inputs ) + \"_d\" ; } std :: string exprName ( const std :: vector < poplar :: Tensor > & inputs ) const { return a -> name ( inputs ) + \"_\" + b -> name ( inputs ) + \"_\" + c -> name ( inputs ) ; } }"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::TernaryOp::TernaryOp(popops::expr::TernaryOpType, const popops::expr::Expr &, const popops::expr::Expr &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"TernaryOp ( TernaryOpType type , const Expr & a , const Expr & b , const Expr & c )"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::TernaryOp::getOpType()","Filename":"popops/Expr.hpp","Text":"TernaryOpType getOpType ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::TernaryOp::getArg0()","Filename":"popops/Expr.hpp","Text":"const Expr & getArg0 ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::TernaryOp::getArg1()","Filename":"popops/Expr.hpp","Text":"const Expr & getArg1 ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::TernaryOp::getArg2()","Filename":"popops/Expr.hpp","Text":"const Expr & getArg2 ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::TernaryOp::clone()","Filename":"popops/Expr.hpp","Text":"std :: unique_ptr < Expr > clone ( ) const override"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::TernaryOp::name(const std::vector<poplar::Tensor> &)","Filename":"popops/Expr.hpp","Text":"std :: string name ( const std :: vector < poplar :: Tensor > & inputs ) const override"}
{"Token type":"CXXMethod","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::TernaryOp::exprName(const std::vector<poplar::Tensor> &)","Filename":"popops/Expr.hpp","Text":"std :: string exprName ( const std :: vector < poplar :: Tensor > & inputs ) const"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Select","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_TERNARY_OP ( Select , SELECT )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Select::Select(const popops::expr::Expr &, const popops::expr::Expr &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_TERNARY_OP ( Select , SELECT )"}
{"Token type":"ClassDecl","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Clamp","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_TERNARY_OP ( Clamp , CLAMP )"}
{"Token type":"CXXConstructor","FaliureReason":"","Implemented":false,"Namespace":"popops::expr","Name":"popops::expr::Clamp::Clamp(const popops::expr::Expr &, const popops::expr::Expr &, const popops::expr::Expr &)","Filename":"popops/Expr.hpp","Text":"POPLIBS_DEFINE_EXPR_TERNARY_OP ( Clamp , CLAMP )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::varianceToInvStdDev(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const poplar::Type, const std::string &)","Filename":"popops/ElementWise.hpp","Text":"poplar :: Tensor varianceToInvStdDev ( poplar :: Graph & graph , const poplar :: Tensor & src , const poplar :: Tensor & epsilon , poplar :: program :: Sequence & prog , const poplar :: Type dstType = poplar :: HALF , const std :: string & debugPrefix = \"\" )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::varianceToInvStdDev(poplar::Graph &, const poplar::Tensor &, const float, poplar::program::Sequence &, const poplar::Type, const std::string &)","Filename":"popops/ElementWise.hpp","Text":"poplar :: Tensor varianceToInvStdDev ( poplar :: Graph & graph , const poplar :: Tensor & src , const float epsilon , poplar :: program :: Sequence & prog , const poplar :: Type dstType = poplar :: HALF , const std :: string & debugPrefix = \"\" )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::invStdDevToVariance(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const poplar::Type, const std::string &)","Filename":"popops/ElementWise.hpp","Text":"poplar :: Tensor invStdDevToVariance ( poplar :: Graph & graph , const poplar :: Tensor & src , const poplar :: Tensor & epsilon , poplar :: program :: Sequence & prog , const poplar :: Type dstType = poplar :: FLOAT , const std :: string & debugPrefix = \"\" )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::invStdDevToVariance(poplar::Graph &, const poplar::Tensor &, const float, poplar::program::Sequence &, const poplar::Type, const std::string &)","Filename":"popops/ElementWise.hpp","Text":"poplar :: Tensor invStdDevToVariance ( poplar :: Graph & graph , const poplar :: Tensor & src , const float epsilon , poplar :: program :: Sequence & prog , const poplar :: Type dstType = poplar :: FLOAT , const std :: string & debugPrefix = \"\" )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":false,"Namespace":"popops","Name":"popops::map(poplar::Graph &, const expr::Expr &, const std::vector<poplar::Tensor> &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"poplar :: Tensor map ( poplar :: Graph & graph , const expr :: Expr & expr , const std :: vector < poplar :: Tensor > & ts , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":false,"Namespace":"popops","Name":"popops::map(poplar::Graph &, expr::UnaryOpType, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor map ( poplar :: Graph & graph , expr :: UnaryOpType op , const poplar :: Tensor & t , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":false,"Namespace":"popops","Name":"popops::map(poplar::Graph &, expr::BinaryOpType, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor map ( poplar :: Graph & graph , expr :: BinaryOpType op , const poplar :: Tensor & a , const poplar :: Tensor & b , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":false,"Namespace":"popops","Name":"popops::map(poplar::Graph &, expr::TernaryOpType, const poplar::Tensor &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor map ( poplar :: Graph & graph , expr :: TernaryOpType op , const poplar :: Tensor & a , const poplar :: Tensor & b , const poplar :: Tensor & c , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":false,"Namespace":"popops","Name":"popops::mapInPlace(poplar::Graph &, const expr::Expr &, const std::vector<poplar::Tensor> &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"void mapInPlace ( poplar :: Graph & graph , const expr :: Expr & expr , const std :: vector < poplar :: Tensor > & ts , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":false,"Namespace":"popops","Name":"popops::mapInPlace(poplar::Graph &, expr::UnaryOpType, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void mapInPlace ( poplar :: Graph & graph , expr :: UnaryOpType op , const poplar :: Tensor & t , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":false,"Namespace":"popops","Name":"popops::mapInPlace(poplar::Graph &, expr::BinaryOpType, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void mapInPlace ( poplar :: Graph & graph , expr :: BinaryOpType op , const poplar :: Tensor & a , const poplar :: Tensor & b , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":false,"Namespace":"popops","Name":"popops::mapInPlace(poplar::Graph &, expr::TernaryOpType, const poplar::Tensor &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void mapInPlace ( poplar :: Graph & graph , expr :: TernaryOpType op , const poplar :: Tensor & a , const poplar :: Tensor & b , const poplar :: Tensor & c , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::abs(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor abs ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::absInPlace(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void absInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::asin(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor asin ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::asinInPlace(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void asinInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::bitwiseNot(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor bitwiseNot ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::bitwiseNotInPlace(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void bitwiseNotInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::ceil(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor ceil ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::ceilInPlace(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void ceilInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::countLeadingZeros(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor countLeadingZeros ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::countLeadingZerosInPlace(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void countLeadingZerosInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::cos(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor cos ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::cosInPlace(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void cosInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::exp(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor exp ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::expInPlace(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void expInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::expm1(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor expm1 ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::expm1InPlace(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void expm1InPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::floor(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor floor ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::floorInPlace(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void floorInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::inv(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor inv ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::invInPlace(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void invInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::log(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor log ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::logInPlace(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void logInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::log1p(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor log1p ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::log1pInPlace(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void log1pInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::logicalNot(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor logicalNot ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::logicalNotInPlace(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void logicalNotInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::neg(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor neg ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::negInPlace(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void negInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::popcount(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor popcount ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::popcountInPlace(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void popcountInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::signum(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor signum ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::signumInPlace(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void signumInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::sin(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor sin ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::sinInPlace(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void sinInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::tan(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor tan ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::tanInPlace(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void tanInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::tanh(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor tanh ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::tanhInPlace(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void tanhInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::round(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor round ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::roundInPlace(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void roundInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::sqrt(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor sqrt ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::sqrtInPlace(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void sqrtInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::square(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor square ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::squareInPlace(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void squareInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::sigmoid(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor sigmoid ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::sigmoidInPlace(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void sigmoidInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::rsqrt(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor rsqrt ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::rsqrtInPlace(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void rsqrtInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::isFinite(poplar::Graph &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor isFinite ( poplar :: Graph & graph , const poplar :: Tensor & A , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::checkTypes(poplar::Type, constType)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline void checkTypes ( poplar :: Type elementType , constType constant )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::checkTypes<>(poplar::Type, float)","Filename":"popops/ElementWise.hpp","Text":"template < > inline void checkTypes < float > ( poplar :: Type elementType , float constant )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::checkTypes<>(poplar::Type, double)","Filename":"popops/ElementWise.hpp","Text":"template < > inline void checkTypes < double > ( poplar :: Type elementType , double constant )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::add(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor add ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::add(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor add ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::add(poplar::Graph &, const constType, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor add ( poplar :: Graph & graph , const constType A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::addInPlace(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void addInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::addInPlace(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline void addInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::atan2(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor atan2 ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::atan2(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor atan2 ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::atan2(poplar::Graph &, const constType, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor atan2 ( poplar :: Graph & graph , const constType A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::atan2InPlace(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void atan2InPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::atan2InPlace(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline void atan2InPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::bitwiseAnd(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor bitwiseAnd ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::bitwiseAnd(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor bitwiseAnd ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::bitwiseAnd(poplar::Graph &, const constType, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor bitwiseAnd ( poplar :: Graph & graph , const constType A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::bitwiseAndInPlace(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void bitwiseAndInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::bitwiseAndInPlace(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline void bitwiseAndInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::bitwiseOr(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor bitwiseOr ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::bitwiseOr(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor bitwiseOr ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::bitwiseOr(poplar::Graph &, const constType, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor bitwiseOr ( poplar :: Graph & graph , const constType A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::bitwiseOrInPlace(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void bitwiseOrInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::bitwiseOrInPlace(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline void bitwiseOrInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::bitwiseXor(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor bitwiseXor ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::bitwiseXor(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor bitwiseXor ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::bitwiseXor(poplar::Graph &, const constType, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor bitwiseXor ( poplar :: Graph & graph , const constType A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::bitwiseXorInPlace(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void bitwiseXorInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::bitwiseXorInPlace(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline void bitwiseXorInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::bitwiseXnor(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor bitwiseXnor ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::bitwiseXnor(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor bitwiseXnor ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::bitwiseXnor(poplar::Graph &, const constType, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor bitwiseXnor ( poplar :: Graph & graph , const constType A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::bitwiseXnorInPlace(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void bitwiseXnorInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::bitwiseXnorInPlace(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline void bitwiseXnorInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::div(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor div ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::div(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor div ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::div(poplar::Graph &, const constType, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor div ( poplar :: Graph & graph , const constType A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::divInPlace(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void divInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::divInPlace(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline void divInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::eq(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor eq ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::eq(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor eq ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::eq(poplar::Graph &, const constType, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor eq ( poplar :: Graph & graph , const constType A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::eqInPlace(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void eqInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::eqInPlace(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline void eqInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::gteq(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor gteq ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::gteq(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor gteq ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::gteq(poplar::Graph &, const constType, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor gteq ( poplar :: Graph & graph , const constType A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::gteqInPlace(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void gteqInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::gteqInPlace(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline void gteqInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::gt(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor gt ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::gt(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor gt ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::gt(poplar::Graph &, const constType, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor gt ( poplar :: Graph & graph , const constType A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::gtInPlace(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void gtInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::gtInPlace(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline void gtInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::invStdDevToVariance(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor invStdDevToVariance ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::invStdDevToVariance(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor invStdDevToVariance ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::invStdDevToVariance(poplar::Graph &, const constType, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor invStdDevToVariance ( poplar :: Graph & graph , const constType A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::invStdDevToVarianceInPlace(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void invStdDevToVarianceInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::invStdDevToVarianceInPlace(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline void invStdDevToVarianceInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::lteq(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor lteq ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::lteq(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor lteq ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::lteq(poplar::Graph &, const constType, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor lteq ( poplar :: Graph & graph , const constType A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::lteqInPlace(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void lteqInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::lteqInPlace(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline void lteqInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::logicalAnd(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor logicalAnd ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::logicalAnd(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor logicalAnd ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::logicalAnd(poplar::Graph &, const constType, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor logicalAnd ( poplar :: Graph & graph , const constType A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::logicalAndInPlace(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void logicalAndInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::logicalAndInPlace(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline void logicalAndInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::logicalOr(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor logicalOr ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::logicalOr(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor logicalOr ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::logicalOr(poplar::Graph &, const constType, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor logicalOr ( poplar :: Graph & graph , const constType A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::logicalOrInPlace(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void logicalOrInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::logicalOrInPlace(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline void logicalOrInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::lt(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor lt ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::lt(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor lt ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::lt(poplar::Graph &, const constType, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor lt ( poplar :: Graph & graph , const constType A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::ltInPlace(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void ltInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::ltInPlace(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline void ltInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::max(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor max ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::max(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor max ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::max(poplar::Graph &, const constType, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor max ( poplar :: Graph & graph , const constType A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::maxInPlace(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void maxInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::maxInPlace(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline void maxInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::min(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor min ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::min(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor min ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::min(poplar::Graph &, const constType, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor min ( poplar :: Graph & graph , const constType A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::minInPlace(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void minInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::minInPlace(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline void minInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::mul(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor mul ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::mul(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor mul ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::mul(poplar::Graph &, const constType, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor mul ( poplar :: Graph & graph , const constType A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::mulInPlace(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void mulInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::mulInPlace(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline void mulInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::neq(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor neq ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::neq(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor neq ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::neq(poplar::Graph &, const constType, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor neq ( poplar :: Graph & graph , const constType A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::neqInPlace(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void neqInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::neqInPlace(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline void neqInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::pow(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor pow ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::pow(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor pow ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::pow(poplar::Graph &, const constType, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor pow ( poplar :: Graph & graph , const constType A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::powInPlace(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void powInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::powInPlace(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline void powInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::rem(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor rem ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::rem(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor rem ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::rem(poplar::Graph &, const constType, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor rem ( poplar :: Graph & graph , const constType A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::remInPlace(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void remInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::remInPlace(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline void remInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::shiftLeft(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor shiftLeft ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::shiftLeft(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor shiftLeft ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::shiftLeft(poplar::Graph &, const constType, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor shiftLeft ( poplar :: Graph & graph , const constType A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::shiftLeftInPlace(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void shiftLeftInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::shiftLeftInPlace(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline void shiftLeftInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::shiftRight(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor shiftRight ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::shiftRight(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor shiftRight ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::shiftRight(poplar::Graph &, const constType, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor shiftRight ( poplar :: Graph & graph , const constType A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::shiftRightInPlace(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void shiftRightInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::shiftRightInPlace(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline void shiftRightInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::shiftRightSignExtend(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor shiftRightSignExtend ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::shiftRightSignExtend(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor shiftRightSignExtend ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::shiftRightSignExtend(poplar::Graph &, const constType, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor shiftRightSignExtend ( poplar :: Graph & graph , const constType A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::shiftRightSignExtendInPlace(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void shiftRightSignExtendInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::shiftRightSignExtendInPlace(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline void shiftRightSignExtendInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::sub(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor sub ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::sub(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor sub ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::sub(poplar::Graph &, const constType, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor sub ( poplar :: Graph & graph , const constType A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::subInPlace(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void subInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::subInPlace(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline void subInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::varianceToInvStdDev(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor varianceToInvStdDev ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::varianceToInvStdDev(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor varianceToInvStdDev ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::varianceToInvStdDev(poplar::Graph &, const constType, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline poplar :: Tensor varianceToInvStdDev ( poplar :: Graph & graph , const constType A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::varianceToInvStdDevInPlace(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void varianceToInvStdDevInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"popops","Name":"popops::varianceToInvStdDevInPlace(poplar::Graph &, const poplar::Tensor &, const constType, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"template < typename constType > inline void varianceToInvStdDevInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const constType B , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::select(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor select ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , const poplar :: Tensor & C , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::selectInPlace(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void selectInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , const poplar :: Tensor & C , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::clamp(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline poplar :: Tensor clamp ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , const poplar :: Tensor & C , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::clampInPlace(poplar::Graph &, const poplar::Tensor &, const poplar::Tensor &, const poplar::Tensor &, poplar::program::Sequence &, const std::string &, const poplar::OptionFlags &)","Filename":"popops/ElementWise.hpp","Text":"inline void clampInPlace ( poplar :: Graph & graph , const poplar :: Tensor & A , const poplar :: Tensor & B , const poplar :: Tensor & C , poplar :: program :: Sequence & prog , const std :: string & debugPrefix = \"\" , const poplar :: OptionFlags & options = { } )"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::ArrayRef<T>(std::nullptr_t)","Filename":"poplar/ArrayRef.hpp","Text":"ArrayRef ( std :: nullptr_t ) = delete"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::ArrayRef<T>()","Filename":"poplar/ArrayRef.hpp","Text":"constexpr ArrayRef ( ) : ptr ( nullptr ) , len ( 0 ) { }"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::ArrayRef<T>(const T *, std::size_t)","Filename":"poplar/ArrayRef.hpp","Text":"constexpr ArrayRef ( const T * p , std :: size_t size ) : ptr ( p ) , len ( size ) { }"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::ArrayRef<T>(const std::vector<T> &)","Filename":"poplar/ArrayRef.hpp","Text":"ArrayRef ( const std :: vector < T > & v )"}
{"Token type":"FunctionTemplate","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::ArrayRef<T>(const std::array<T, N> &)","Filename":"poplar/ArrayRef.hpp","Text":"template < std :: size_t N > constexpr ArrayRef ( const std :: array < T , N > & a ) : ArrayRef ( a . data ( ) , N ) { }"}
{"Token type":"FunctionTemplate","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::ArrayRef<T>(const T (&)[N])","Filename":"poplar/ArrayRef.hpp","Text":"template < std :: size_t N > constexpr ArrayRef ( const T ( & p ) [ N ] ) : ArrayRef ( p , N ) { }"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::ArrayRef<T>(const std::initializer_list<T> &)","Filename":"poplar/ArrayRef.hpp","Text":"constexpr ArrayRef ( const std :: initializer_list < T > & list ) : ArrayRef ( list . begin ( ) , list . size ( ) ) { }"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::ArrayRef<T>(const ArrayRef<T> &)","Filename":"poplar/ArrayRef.hpp","Text":"constexpr ArrayRef ( const ArrayRef & ) = default"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::data()","Filename":"poplar/ArrayRef.hpp","Text":"constexpr const T * data ( ) const { return ptr ; }"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::size()","Filename":"poplar/ArrayRef.hpp","Text":"constexpr std :: size_t size ( ) const { return len ; }"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::empty()","Filename":"poplar/ArrayRef.hpp","Text":"constexpr bool empty ( ) const { return len == 0 ; }"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::front()","Filename":"poplar/ArrayRef.hpp","Text":"const T & front ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::operator[](std::size_t)","Filename":"poplar/ArrayRef.hpp","Text":"const T & operator [ ] ( std :: size_t i ) const"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::begin()","Filename":"poplar/ArrayRef.hpp","Text":"const_iterator begin ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::end()","Filename":"poplar/ArrayRef.hpp","Text":"const_iterator end ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::cbegin()","Filename":"poplar/ArrayRef.hpp","Text":"const_iterator cbegin ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::cend()","Filename":"poplar/ArrayRef.hpp","Text":"const_iterator cend ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::cloneAsVector()","Filename":"poplar/ArrayRef.hpp","Text":"std :: vector < T > cloneAsVector ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::ArrayRef<T>::max_size()","Filename":"poplar/ArrayRef.hpp","Text":"std :: size_t max_size ( ) const"}
{"Token type":"FunctionTemplate","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::operator==(const ArrayRef<T> &, const ArrayRef<T> &)","Filename":"poplar/ArrayRef.hpp","Text":"template < class T > inline bool operator == ( const ArrayRef < T > & l , const ArrayRef < T > & r )"}
{"Token type":"FunctionTemplate","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::operator!=(const ArrayRef<T> &, const ArrayRef<T> &)","Filename":"poplar/ArrayRef.hpp","Text":"template < class T > inline bool operator != ( const ArrayRef < T > & l , const ArrayRef < T > & r )"}
{"Token type":"StructDecl","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef","Filename":"poplar/StringRef.hpp","Text":"struct StringRef : public ArrayRef < char > { constexpr StringRef ( ) : ArrayRef ( nullptr , 0 ) { } constexpr StringRef ( const StringRef & ) = default ; StringRef ( std :: nullptr_t ) = delete ; StringRef ( const std :: string & s ) : ArrayRef ( s . data ( ) , s . size ( ) ) { } constexpr StringRef ( const char * p , std :: size_t len ) : ArrayRef ( p , len ) { } StringRef ( const char * p ) : ArrayRef ( p , std :: strlen ( p ) ) { } // String literal will always be null terminated hence N-1: template < std :: size_t N > constexpr StringRef ( const char ( & p ) [ N ] ) : ArrayRef ( p , N - 1 ) { } std :: string cloneAsString ( ) const { return std :: string ( begin ( ) , size ( ) ) ; } operator std :: string ( ) const { return cloneAsString ( ) ; } }"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef::StringRef()","Filename":"poplar/StringRef.hpp","Text":"constexpr StringRef ( ) : ArrayRef ( nullptr , 0 ) { }"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef::StringRef(const poplar::StringRef &)","Filename":"poplar/StringRef.hpp","Text":"constexpr StringRef ( const StringRef & ) = default"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef::StringRef(std::nullptr_t)","Filename":"poplar/StringRef.hpp","Text":"StringRef ( std :: nullptr_t ) = delete"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef::StringRef(const std::string &)","Filename":"poplar/StringRef.hpp","Text":"StringRef ( const std :: string & s )"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef::StringRef(const char *, std::size_t)","Filename":"poplar/StringRef.hpp","Text":"constexpr StringRef ( const char * p , std :: size_t len ) : ArrayRef ( p , len ) { }"}
{"Token type":"CXXConstructor","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef::StringRef(const char *)","Filename":"poplar/StringRef.hpp","Text":"StringRef ( const char * p )"}
{"Token type":"FunctionTemplate","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef::StringRef(const char (&)[N])","Filename":"poplar/StringRef.hpp","Text":"template < std :: size_t N > constexpr StringRef ( const char ( & p ) [ N ] ) : ArrayRef ( p , N - 1 ) { }"}
{"Token type":"CXXMethod","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::StringRef::cloneAsString()","Filename":"poplar/StringRef.hpp","Text":"std :: string cloneAsString ( ) const"}
{"Token type":"FunctionDecl","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::operator==(poplar::StringRef, poplar::StringRef)","Filename":"poplar/StringRef.hpp","Text":"inline bool operator == ( StringRef l , StringRef r )"}
{"Token type":"FunctionDecl","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::operator!=(poplar::StringRef, poplar::StringRef)","Filename":"poplar/StringRef.hpp","Text":"inline bool operator != ( StringRef l , StringRef r )"}
{"Token type":"FunctionDecl","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<(poplar::StringRef, poplar::StringRef)","Filename":"poplar/StringRef.hpp","Text":"inline bool operator < ( StringRef l , StringRef r )"}
{"Token type":"FunctionDecl","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::operator+(poplar::StringRef, poplar::StringRef)","Filename":"poplar/StringRef.hpp","Text":"inline std :: string operator + ( StringRef l , StringRef r )"}
{"Token type":"FunctionDecl","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::operator+=(std::string &, poplar::StringRef)","Filename":"poplar/StringRef.hpp","Text":"inline std :: string & operator += ( std :: string & s , StringRef r )"}
{"Token type":"FunctionDecl","FaliureReason":"header_blacklisted","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<<(std::ostream &, const poplar::StringRef &)","Filename":"poplar/StringRef.hpp","Text":"inline std :: ostream & operator << ( std :: ostream & os , const StringRef & s )"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::Type","Filename":"poplar/Type.hpp","Text":"class Type"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::Type()","Filename":"poplar/Type.hpp","Text":"Type ( )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::Type(poplar::Type &&)","Filename":"poplar/Type.hpp","Text":"Type ( Type && other )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::operator=(const poplar::Type &)","Filename":"poplar/Type.hpp","Text":"Type & operator = ( const Type & other )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::operator=(poplar::Type &&)","Filename":"poplar/Type.hpp","Text":"Type & operator = ( Type && other )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::operator==(const poplar::Type &)","Filename":"poplar/Type.hpp","Text":"bool operator == ( const Type & other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::operator!=(const poplar::Type &)","Filename":"poplar/Type.hpp","Text":"bool operator != ( const Type & other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::operator<(const poplar::Type &)","Filename":"poplar/Type.hpp","Text":"bool operator < ( const Type & other ) const"}
{"Token type":"CXXConstructor","FaliureReason":"unique_ptr_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::Type(std::unique_ptr<core::Type>)","Filename":"poplar/Type.hpp","Text":"Type ( std :: unique_ptr < core :: Type > )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Type::getImpl()","Filename":"poplar/Type.hpp","Text":"const core :: Type & getImpl ( ) const"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<<(std::ostream &, const poplar::Type &)","Filename":"poplar/Type.hpp","Text":"inline std :: ostream & operator << ( std :: ostream & os , const Type & t )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<bool>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( bool , BOOL )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<char>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( char , CHAR )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<unsigned char>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( unsigned char , UNSIGNED_CHAR )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<signed char>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( signed char , SIGNED_CHAR )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<unsigned short>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( unsigned short , UNSIGNED_SHORT )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<short>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( signed short , SHORT )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<unsigned int>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( unsigned int , UNSIGNED_INT )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<int>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( signed int , INT )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<unsigned long>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( unsigned long , UNSIGNED_LONG )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<long>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( signed long , LONG )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<unsigned long long>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( unsigned long long , UNSIGNED_LONGLONG )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<long long>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( signed long long , LONGLONG )"}
{"Token type":"StructDecl","FaliureReason":"","Implemented":false,"Namespace":"poplar","Name":"poplar::equivalent_device_type<float>","Filename":"poplar/Type.hpp","Text":"POPLAR_DECLARE_EQUIV_TYPE ( float , FLOAT )"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::DataStreamRef","Filename":"poplar/DataStream.hpp","Text":"class DataStreamRef"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::RemoteBufferRef","Filename":"poplar/DataStream.hpp","Text":"class RemoteBufferRef"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::DataStream::DataStream()","Filename":"poplar/DataStream.hpp","Text":"DataStream ( )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::DataStream::DataStream(poplar::DataStream &&)","Filename":"poplar/DataStream.hpp","Text":"DataStream ( DataStream && )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::DataStream::operator=(const poplar::DataStream &)","Filename":"poplar/DataStream.hpp","Text":"DataStream & operator = ( const DataStream & )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::DataStream::operator=(poplar::DataStream &&)","Filename":"poplar/DataStream.hpp","Text":"DataStream & operator = ( DataStream && )"}
{"Token type":"CXXConstructor","FaliureReason":"unique_ptr_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::DataStream::DataStream(std::unique_ptr<core::DataStreamRef>)","Filename":"poplar/DataStream.hpp","Text":"DataStream ( std :: unique_ptr < core :: DataStreamRef > )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::DataStream::getImpl()","Filename":"poplar/DataStream.hpp","Text":"const core :: DataStreamRef & getImpl ( ) const"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::RemoteBuffer::RemoteBuffer()","Filename":"poplar/DataStream.hpp","Text":"RemoteBuffer ( )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::RemoteBuffer::RemoteBuffer(poplar::RemoteBuffer &&)","Filename":"poplar/DataStream.hpp","Text":"RemoteBuffer ( RemoteBuffer && )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::RemoteBuffer::operator=(const poplar::RemoteBuffer &)","Filename":"poplar/DataStream.hpp","Text":"RemoteBuffer & operator = ( const RemoteBuffer & )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::RemoteBuffer::operator=(poplar::RemoteBuffer &&)","Filename":"poplar/DataStream.hpp","Text":"RemoteBuffer & operator = ( RemoteBuffer && )"}
{"Token type":"CXXConstructor","FaliureReason":"unique_ptr_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::RemoteBuffer::RemoteBuffer(std::unique_ptr<core::RemoteBufferRef>)","Filename":"poplar/DataStream.hpp","Text":"RemoteBuffer ( std :: unique_ptr < core :: RemoteBufferRef > )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::RemoteBuffer::getImpl()","Filename":"poplar/DataStream.hpp","Text":"const core :: RemoteBufferRef & getImpl ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::RemoteBuffer::operator==(const poplar::RemoteBuffer &)","Filename":"poplar/DataStream.hpp","Text":"bool operator == ( const RemoteBuffer & b ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::RemoteBuffer::operator!=(const poplar::RemoteBuffer &)","Filename":"poplar/DataStream.hpp","Text":"bool operator != ( const RemoteBuffer & b ) const"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::OptionFlags","Filename":"poplar/OptionFlags.hpp","Text":"class OptionFlags"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::OptionFlagsIterator","Filename":"poplar/OptionFlags.hpp","Text":"class OptionFlagsIterator"}
{"Token type":"CXXConstructor","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::iterator(std::unique_ptr<core::OptionFlagsIterator> &&)","Filename":"poplar/OptionFlags.hpp","Text":"iterator ( std :: unique_ptr < core :: OptionFlagsIterator > && p ) noexcept"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::operator=(const poplar::OptionFlags::iterator &)","Filename":"poplar/OptionFlags.hpp","Text":"iterator & operator = ( const iterator & other )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::iterator(poplar::OptionFlags::iterator &&)","Filename":"poplar/OptionFlags.hpp","Text":"iterator ( iterator && other ) noexcept"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::operator=(poplar::OptionFlags::iterator &&)","Filename":"poplar/OptionFlags.hpp","Text":"iterator & operator = ( iterator && other ) noexcept"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::operator*()","Filename":"poplar/OptionFlags.hpp","Text":"const OptionFlag & operator * ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::operator->()","Filename":"poplar/OptionFlags.hpp","Text":"const OptionFlag * operator -> ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::operator==(const poplar::OptionFlags::iterator &)","Filename":"poplar/OptionFlags.hpp","Text":"bool operator == ( const iterator & other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::operator!=(const poplar::OptionFlags::iterator &)","Filename":"poplar/OptionFlags.hpp","Text":"bool operator != ( const iterator & other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::operator++()","Filename":"poplar/OptionFlags.hpp","Text":"iterator & operator ++ ( )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::iterator::operator++(int)","Filename":"poplar/OptionFlags.hpp","Text":"iterator operator ++ ( int )"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::OptionFlags()","Filename":"poplar/OptionFlags.hpp","Text":"OptionFlags ( )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::OptionFlags(poplar::OptionFlags &&)","Filename":"poplar/OptionFlags.hpp","Text":"OptionFlags ( OptionFlags && other )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::operator=(const poplar::OptionFlags &)","Filename":"poplar/OptionFlags.hpp","Text":"OptionFlags & operator = ( const OptionFlags & other )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::operator=(poplar::OptionFlags &&)","Filename":"poplar/OptionFlags.hpp","Text":"OptionFlags & operator = ( OptionFlags && other )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::operator==(const poplar::OptionFlags &)","Filename":"poplar/OptionFlags.hpp","Text":"bool operator == ( const OptionFlags & other ) const"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::OptionFlags(poplar::OptionFlags::initializer_list &&)","Filename":"poplar/OptionFlags.hpp","Text":"OptionFlags ( initializer_list && list )"}
{"Token type":"CXXMethod","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::OptionFlags::set(poplar::OptionFlags::initializer_list &&)","Filename":"poplar/OptionFlags.hpp","Text":"void set ( initializer_list && list )"}
{"Token type":"FunctionDecl","FaliureReason":"istream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::readJSON(std::istream &, poplar::OptionFlags &)","Filename":"poplar/OptionFlags.hpp","Text":"void readJSON ( std :: istream & stream , OptionFlags & flags )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::GlobalExchangeFlow::operator==(const poplar::GlobalExchangeFlow &)","Filename":"poplar/GlobalExchangeConstraints.hpp","Text":"bool operator == ( const GlobalExchangeFlow & other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::GlobalExchangeFlow::operator<(const poplar::GlobalExchangeFlow &)","Filename":"poplar/GlobalExchangeConstraints.hpp","Text":"bool operator < ( const GlobalExchangeFlow & other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::GlobalExchangeConstraint::operator==(const poplar::GlobalExchangeConstraint &)","Filename":"poplar/GlobalExchangeConstraints.hpp","Text":"bool operator == ( const GlobalExchangeConstraint & other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::GlobalExchangeConstraint::operator<(const poplar::GlobalExchangeConstraint &)","Filename":"poplar/GlobalExchangeConstraints.hpp","Text":"bool operator < ( const GlobalExchangeConstraint & other ) const"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<<(std::ostream &, poplar::IpuLinkConfiguration)","Filename":"poplar/IpuLinkConfiguration.hpp","Text":"std :: ostream & operator << ( std :: ostream & os , IpuLinkConfiguration ic )"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<<(std::ostream &, poplar::IpuLinkTopology)","Filename":"poplar/IpuLinkTopology.hpp","Text":"std :: ostream & operator << ( std :: ostream & os , IpuLinkTopology topo )"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::Target","Filename":"poplar/Target.hpp","Text":"class Target"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::Target()","Filename":"poplar/Target.hpp","Text":"Target ( )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::Target(poplar::Target &&)","Filename":"poplar/Target.hpp","Text":"Target ( Target && )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::operator=(const poplar::Target &)","Filename":"poplar/Target.hpp","Text":"Target & operator = ( const Target & )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::operator=(poplar::Target &&)","Filename":"poplar/Target.hpp","Text":"Target & operator = ( Target && )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::operator==(const poplar::Target &)","Filename":"poplar/Target.hpp","Text":"bool operator == ( const Target & ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::operator!=(const poplar::Target &)","Filename":"poplar/Target.hpp","Text":"bool operator != ( const Target & ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::operator<(const poplar::Target &)","Filename":"poplar/Target.hpp","Text":"bool operator < ( const Target & ) const"}
{"Token type":"CXXConstructor","FaliureReason":"unique_ptr_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::Target(std::unique_ptr<core::Target>)","Filename":"poplar/Target.hpp","Text":"Target ( std :: unique_ptr < core :: Target > )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Target::getImpl()","Filename":"poplar/Target.hpp","Text":"core :: Target & getImpl ( ) const"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::Device","Filename":"poplar/Device.hpp","Text":"class Device"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::Device::Device()","Filename":"poplar/Device.hpp","Text":"Device ( )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Device::Device(poplar::Device &&)","Filename":"poplar/Device.hpp","Text":"Device ( Device && )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Device::operator=(poplar::Device &&)","Filename":"poplar/Device.hpp","Text":"Device & operator = ( Device && )"}
{"Token type":"CXXConstructor","FaliureReason":"deleted_method","Implemented":false,"Namespace":"poplar","Name":"poplar::Device::Device(const poplar::Device &)","Filename":"poplar/Device.hpp","Text":"Device ( const Device & ) = delete"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Device::operator=(const poplar::Device &)","Filename":"poplar/Device.hpp","Text":"Device & operator = ( const Device & ) = delete"}
{"Token type":"CXXConstructor","FaliureReason":"unique_ptr_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Device::Device(std::unique_ptr<core::Device>)","Filename":"poplar/Device.hpp","Text":"Device ( std :: unique_ptr < core :: Device > )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Device::getImpl()","Filename":"poplar/Device.hpp","Text":"core :: Device & getImpl ( ) const"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::Executable","Filename":"poplar/Executable.hpp","Text":"class Executable"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Executable::Executable(poplar::Executable &&)","Filename":"poplar/Executable.hpp","Text":"Executable ( Executable && other )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Executable::operator=(poplar::Executable &&)","Filename":"poplar/Executable.hpp","Text":"Executable & operator = ( Executable && other )"}
{"Token type":"CXXMethod","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Executable::serialize(std::ostream &)","Filename":"poplar/Executable.hpp","Text":"void serialize ( std :: ostream & out ) const"}
{"Token type":"CXXMethod","FaliureReason":"istream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Executable::deserialize(std::istream &)","Filename":"poplar/Executable.hpp","Text":"static Executable deserialize ( std :: istream & in )"}
{"Token type":"CXXConstructor","FaliureReason":"unique_ptr_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Executable::Executable(std::unique_ptr<core::Executable>)","Filename":"poplar/Executable.hpp","Text":"explicit Executable ( std :: unique_ptr < core :: Executable > impl )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Executable::getImpl()","Filename":"poplar/Executable.hpp","Text":"const core :: Executable & getImpl ( ) const"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::GraphBuilder","Filename":"poplar/GraphElements.hpp","Text":"class GraphBuilder"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::VertexRef::VertexRef()","Filename":"poplar/GraphElements.hpp","Text":"VertexRef ( )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::VertexRef::operator[](poplar::StringRef)","Filename":"poplar/GraphElements.hpp","Text":"FieldRef operator [ ] ( StringRef fieldName ) const"}
{"Token type":"CXXConstructor","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::VertexRef::VertexRef(const core::GraphBuilder *, unsigned int)","Filename":"poplar/GraphElements.hpp","Text":"VertexRef ( const core :: GraphBuilder * graph , unsigned id )"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldRef::FieldRef()","Filename":"poplar/GraphElements.hpp","Text":"FieldRef ( )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldRef::operator[](std::size_t)","Filename":"poplar/GraphElements.hpp","Text":"FieldRef operator [ ] ( std :: size_t index ) const"}
{"Token type":"CXXConstructor","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldRef::FieldRef(poplar::VertexRef, poplar::StringRef)","Filename":"poplar/GraphElements.hpp","Text":"FieldRef ( VertexRef vertex , StringRef fieldName )"}
{"Token type":"CXXConstructor","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldRef::FieldRef(poplar::VertexRef, unsigned int)","Filename":"poplar/GraphElements.hpp","Text":"FieldRef ( VertexRef vertex , unsigned fieldId )"}
{"Token type":"CXXConstructor","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldRef::FieldRef(poplar::VertexRef, poplar::StringRef, std::size_t)","Filename":"poplar/GraphElements.hpp","Text":"FieldRef ( VertexRef vertex , StringRef fieldName , std :: size_t index )"}
{"Token type":"CXXConstructor","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldRef::FieldRef(poplar::VertexRef, unsigned int, std::size_t)","Filename":"poplar/GraphElements.hpp","Text":"FieldRef ( VertexRef vertex , unsigned fieldId , std :: size_t index )"}
{"Token type":"CXXMethod","FaliureReason":"constructor_missing_class","Implemented":false,"Namespace":"poplar","Name":"poplar::operator[](poplar::StringRef)","Filename":"poplar/GraphElements.hpp","Text":"inline FieldRef VertexRef :: operator [ ] ( StringRef fieldName ) const"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::ComputeSet::ComputeSet()","Filename":"poplar/GraphElements.hpp","Text":"ComputeSet ( )"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::Function::Function()","Filename":"poplar/GraphElements.hpp","Text":"Function ( )"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::MutableProfileValue","Filename":"poplar/ProfileValue.hpp","Text":"class MutableProfileValue"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::operator[](poplar::StringRef)","Filename":"poplar/ProfileValue.hpp","Text":"const ProfileValue & operator [ ] ( StringRef s ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::operator[](std::size_t)","Filename":"poplar/ProfileValue.hpp","Text":"const ProfileValue & operator [ ] ( std :: size_t i ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::operator==(const poplar::ProfileValue &)","Filename":"poplar/ProfileValue.hpp","Text":"bool operator == ( const ProfileValue & other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::operator!=(const poplar::ProfileValue &)","Filename":"poplar/ProfileValue.hpp","Text":"bool operator != ( const ProfileValue & other ) const"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::ProfileValue()","Filename":"poplar/ProfileValue.hpp","Text":"ProfileValue ( )"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::ProfileValue(T)","Filename":"poplar/ProfileValue.hpp","Text":"template < class T , typename = typename std :: enable_if < std :: is_integral < T > :: value > :: type > ProfileValue ( T init )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::ProfileValue(poplar::ProfileValue &&)","Filename":"poplar/ProfileValue.hpp","Text":"ProfileValue ( ProfileValue && other ) noexcept"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::operator=(const poplar::ProfileValue &)","Filename":"poplar/ProfileValue.hpp","Text":"ProfileValue & operator = ( const ProfileValue & other )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::operator=(poplar::ProfileValue &&)","Filename":"poplar/ProfileValue.hpp","Text":"ProfileValue & operator = ( ProfileValue && other ) noexcept"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::operator=(poplar::ProfileValue::Boolean)","Filename":"poplar/ProfileValue.hpp","Text":"ProfileValue & operator = ( Boolean init )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::operator=(poplar::ProfileValue::Number)","Filename":"poplar/ProfileValue.hpp","Text":"ProfileValue & operator = ( Number init )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::operator=(poplar::ProfileValue::String)","Filename":"poplar/ProfileValue.hpp","Text":"ProfileValue & operator = ( String init )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::operator=(poplar::ProfileValue::Vector)","Filename":"poplar/ProfileValue.hpp","Text":"ProfileValue & operator = ( Vector init )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::operator=(poplar::ProfileValue::Map)","Filename":"poplar/ProfileValue.hpp","Text":"ProfileValue & operator = ( Map init )"}
{"Token type":"FunctionTemplate","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::ProfileValue::operator=(T)","Filename":"poplar/ProfileValue.hpp","Text":"template < class T , typename = typename std :: enable_if < std :: is_integral < T > :: value > :: type > ProfileValue & operator = ( T init )"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::serializeToJSON(std::ostream &, const poplar::ProfileValue &, bool)","Filename":"poplar/ProfileValue.hpp","Text":"void serializeToJSON ( std :: ostream & out , const ProfileValue & val , bool prettyPrint = false )"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::serializeToCBOR(std::ostream &, const poplar::ProfileValue &, bool)","Filename":"poplar/ProfileValue.hpp","Text":"void serializeToCBOR ( std :: ostream & out , const ProfileValue & val , bool withTag = true )"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<<(std::ostream &, const poplar::ProfileValue &)","Filename":"poplar/ProfileValue.hpp","Text":"std :: ostream & operator << ( std :: ostream & os , const ProfileValue & v )"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::printGraphSummary(std::ostream &, const poplar::ProfileValue &, const poplar::OptionFlags &)","Filename":"poplar/ProfileValue.hpp","Text":"void printGraphSummary ( std :: ostream & out , const ProfileValue & graphProfile , const OptionFlags & opts )"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::printExecutionSummary(std::ostream &, const poplar::ProfileValue &, const poplar::ProfileValue &, const poplar::OptionFlags &)","Filename":"poplar/ProfileValue.hpp","Text":"void printExecutionSummary ( std :: ostream & out , const ProfileValue & graphProfile , const ProfileValue & executionProfile , const OptionFlags & opts )"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::printProfileSummary(std::ostream &, const poplar::ProfileValue &, const poplar::ProfileValue &, const poplar::OptionFlags &)","Filename":"poplar/ProfileValue.hpp","Text":"void printProfileSummary ( std :: ostream & out , const ProfileValue & graphProfile , const ProfileValue & executionProfile , const OptionFlags & opts = { } )"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::profiling_disabled::profiling_disabled()","Filename":"poplar/exceptions.hpp","Text":"profiling_disabled ( )"}
{"Token type":"CXXConstructor","FaliureReason":"constructor_missing_class","Implemented":false,"Namespace":"poplar","Name":"poplar::GenericInterval<T>::GenericInterval<T>()","Filename":"poplar/Interval.hpp","Text":"GenericInterval ( ) = default"}
{"Token type":"CXXConstructor","FaliureReason":"constructor_missing_class","Implemented":false,"Namespace":"poplar","Name":"poplar::GenericInterval<T>::GenericInterval<T>(T, T)","Filename":"poplar/Interval.hpp","Text":"GenericInterval ( T begin , T end )"}
{"Token type":"CXXMethod","FaliureReason":"constructor_missing_class","Implemented":false,"Namespace":"poplar","Name":"poplar::GenericInterval<T>::begin()","Filename":"poplar/Interval.hpp","Text":"const T & begin ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"constructor_missing_class","Implemented":false,"Namespace":"poplar","Name":"poplar::GenericInterval<T>::end()","Filename":"poplar/Interval.hpp","Text":"const T & end ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"constructor_missing_class","Implemented":false,"Namespace":"poplar","Name":"poplar::GenericInterval<T>::size()","Filename":"poplar/Interval.hpp","Text":"T size ( ) const"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::operator==(const GenericInterval<T> &, const GenericInterval<T> &)","Filename":"poplar/Interval.hpp","Text":"template < class T > inline bool operator == ( const GenericInterval < T > & a , const GenericInterval < T > & b )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<(const GenericInterval<T> &, const GenericInterval<T> &)","Filename":"poplar/Interval.hpp","Text":"template < class T > inline bool operator < ( const GenericInterval < T > & a , const GenericInterval < T > & b )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::operator!=(const GenericInterval<T> &, const GenericInterval<T> &)","Filename":"poplar/Interval.hpp","Text":"template < class T > inline bool operator != ( const GenericInterval < T > & a , const GenericInterval < T > & b )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::operator>=(const GenericInterval<T> &, const GenericInterval<T> &)","Filename":"poplar/Interval.hpp","Text":"template < class T > inline bool operator >= ( const GenericInterval < T > & a , const GenericInterval < T > & b )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::operator>(const GenericInterval<T> &, const GenericInterval<T> &)","Filename":"poplar/Interval.hpp","Text":"template < class T > inline bool operator > ( const GenericInterval < T > & a , const GenericInterval < T > & b )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<=(const GenericInterval<T> &, const GenericInterval<T> &)","Filename":"poplar/Interval.hpp","Text":"template < class T > inline bool operator <= ( const GenericInterval < T > & a , const GenericInterval < T > & b )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<<(std::ostream &, const GenericInterval<T> &)","Filename":"poplar/Interval.hpp","Text":"template < class T > inline std :: ostream & operator << ( std :: ostream & os , const GenericInterval < T > & b )"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::SourceLocation::SourceLocation()","Filename":"poplar/DebugContext.hpp","Text":"SourceLocation ( ) = default"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::DebugInfo","Filename":"poplar/DebugContext.hpp","Text":"class DebugInfo"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::DebugInfo::operator=(const poplar::DebugInfo &)","Filename":"poplar/DebugContext.hpp","Text":"DebugInfo & operator = ( const DebugInfo & ) = delete"}
{"Token type":"CXXConstructor","FaliureReason":"deleted_method","Implemented":false,"Namespace":"poplar","Name":"poplar::DebugInfo::DebugInfo(const poplar::DebugInfo &)","Filename":"poplar/DebugContext.hpp","Text":"DebugInfo ( const DebugInfo & ) = delete"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::DebugInfo::getImpl()","Filename":"poplar/DebugContext.hpp","Text":"core :: DebugInfo & getImpl ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::DebugInfo::setValue(std::string, poplar::ProfileValue)","Filename":"poplar/DebugContext.hpp","Text":"bool setValue ( std :: string name , ProfileValue value )"}
{"Token type":"StructDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::DebugContext","Filename":"poplar/DebugContext.hpp","Text":"struct DebugContext"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::DebugContext::DebugContext(poplar::DebugContext &&)","Filename":"poplar/DebugContext.hpp","Text":"DebugContext ( DebugContext && )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::DebugContext::getImpl()","Filename":"poplar/DebugContext.hpp","Text":"core :: DebugContext & getImpl ( ) const"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar","Name":"poplar::IeeeHalf","Filename":"poplar/TypeTraits.hpp","Text":"class IeeeHalf"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::TypeTraits::make()","Filename":"poplar/TypeTraits.hpp","Text":"template < typename T > static TypeTraits make ( )"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::TypeTraits::isSimpleType()","Filename":"poplar/TypeTraits.hpp","Text":"template < typename T > static constexpr bool isSimpleType ( )"}
{"Token type":"FunctionTemplate","FaliureReason":"constructor_missing_class","Implemented":false,"Namespace":"poplar","Name":"poplar::make()","Filename":"poplar/TypeTraits.hpp","Text":"template < typename T > TypeTraits TypeTraits :: make ( )"}
{"Token type":"CXXMethod","FaliureReason":"constructor_missing_class","Implemented":false,"Namespace":"poplar","Name":"poplar::make<>()","Filename":"poplar/TypeTraits.hpp","Text":"template < > inline TypeTraits TypeTraits :: make < IeeeHalf > ( )"}
{"Token type":"FunctionTemplate","FaliureReason":"constructor_missing_class","Implemented":false,"Namespace":"poplar","Name":"poplar::isSimpleType()","Filename":"poplar/TypeTraits.hpp","Text":"template < typename T > constexpr bool TypeTraits :: isSimpleType ( ) { return std :: is_integral < T > :: value || std :: is_floating_point < T > :: value ; }"}
{"Token type":"CXXMethod","FaliureReason":"constructor_missing_class","Implemented":false,"Namespace":"poplar","Name":"poplar::isSimpleType<>()","Filename":"poplar/TypeTraits.hpp","Text":"template < > constexpr bool TypeTraits :: isSimpleType < IeeeHalf > ( ) { return true ; }"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::Tensor","Filename":"poplar/Tensor.hpp","Text":"class Tensor"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::Tensor()","Filename":"poplar/Tensor.hpp","Text":"Tensor ( )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::Tensor(poplar::Tensor &&)","Filename":"poplar/Tensor.hpp","Text":"Tensor ( Tensor && other )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::operator=(const poplar::Tensor &)","Filename":"poplar/Tensor.hpp","Text":"const Tensor & operator = ( const Tensor & other ) &"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::operator=(poplar::Tensor &&)","Filename":"poplar/Tensor.hpp","Text":"Tensor & operator = ( Tensor && other ) &"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::operator[](std::size_t)","Filename":"poplar/Tensor.hpp","Text":"Tensor operator [ ] ( std :: size_t i ) const &"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::operator[](std::size_t)","Filename":"poplar/Tensor.hpp","Text":"Tensor && operator [ ] ( std :: size_t i ) &&"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::getConstantValue(T *)","Filename":"poplar/Tensor.hpp","Text":"template < typename T > bool getConstantValue ( T * val ) const"}
{"Token type":"CXXMethod","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::output(std::ostream &)","Filename":"poplar/Tensor.hpp","Text":"std :: ostream & output ( std :: ostream & os ) const"}
{"Token type":"CXXMethod","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::outputRegions(std::ostream &)","Filename":"poplar/Tensor.hpp","Text":"std :: ostream & outputRegions ( std :: ostream & os ) const"}
{"Token type":"CXXConstructor","FaliureReason":"unique_ptr_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::Tensor(std::unique_ptr<core::Tensor>)","Filename":"poplar/Tensor.hpp","Text":"Tensor ( std :: unique_ptr < core :: Tensor > )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::getImpl()","Filename":"poplar/Tensor.hpp","Text":"core :: Tensor & getImpl ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::getPImpl()","Filename":"poplar/Tensor.hpp","Text":"std :: unique_ptr < core :: Tensor > * getPImpl ( )"}
{"Token type":"CXXMethod","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Tensor::getConstantData(void *, const poplar::TypeTraits &)","Filename":"poplar/Tensor.hpp","Text":"bool getConstantData ( void * dst , const TypeTraits & traits ) const"}
{"Token type":"FunctionDecl","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::operator==(const poplar::Tensor &, const poplar::Tensor &)","Filename":"poplar/Tensor.hpp","Text":"bool operator == ( const Tensor & a , const Tensor & b )"}
{"Token type":"FunctionDecl","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::operator!=(const poplar::Tensor &, const poplar::Tensor &)","Filename":"poplar/Tensor.hpp","Text":"bool inline operator != ( const Tensor & a , const Tensor & b )"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<<(std::ostream &, const poplar::Tensor &)","Filename":"poplar/Tensor.hpp","Text":"std :: ostream & operator << ( std :: ostream & os , const Tensor & tensor )"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::ProgramImpl","Filename":"poplar/Program.hpp","Text":"class ProgramImpl"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Program::Program()","Filename":"poplar/Program.hpp","Text":"Program ( )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Program::Program(poplar::program::Program &&)","Filename":"poplar/Program.hpp","Text":"Program ( Program && p )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Program::operator=(const poplar::program::Program &)","Filename":"poplar/Program.hpp","Text":"Program & operator = ( const Program & p )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Program::operator=(poplar::program::Program &&)","Filename":"poplar/Program.hpp","Text":"Program & operator = ( Program && p )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Program::getImpl()","Filename":"poplar/Program.hpp","Text":"core :: ProgramImpl & getImpl ( ) const"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Sequence::add_many(const poplar::program::Program &, T &&...)","Filename":"poplar/Program.hpp","Text":"template < class ... T > void add_many ( const Program & first , T && ... rest )"}
{"Token type":"CXXMethod","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Sequence::add_many()","Filename":"poplar/Program.hpp","Text":"void add_many ( )"}
{"Token type":"CXXMethod","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Sequence::init()","Filename":"poplar/Program.hpp","Text":"void init ( )"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Sequence::Sequence()","Filename":"poplar/Program.hpp","Text":"Sequence ( )"}
{"Token type":"FunctionTemplate","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Sequence::Sequence(T &&...)","Filename":"poplar/Program.hpp","Text":"template < class ... T > Sequence ( T && ... args )"}
{"Token type":"CXXConstructor","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Switch::Switch(poplar::Tensor, const poplar::program::Program &, const bool)","Filename":"poplar/Program.hpp","Text":"Switch ( Tensor control , const Program & defaultCaseBody , const bool unreachableDefault )"}
{"Token type":"CXXConstructor","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Copy::Copy(const poplar::DataStream &, poplar::Tensor, bool, poplar::Tensor, size_t, bool, const poplar::OptionFlags &)","Filename":"poplar/Program.hpp","Text":"Copy ( const DataStream & stream , Tensor dst , bool rearrangeOnHost , Tensor offset , size_t repeats , bool optimiseMemory , const OptionFlags & options = { } )"}
{"Token type":"CXXConstructor","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::Copy::Copy(poplar::Tensor, const poplar::DataStream &, bool, poplar::Tensor, size_t, bool, const poplar::OptionFlags &)","Filename":"poplar/Program.hpp","Text":"Copy ( Tensor src , const DataStream & stream , bool rearrangeOnHost , Tensor offset , size_t repeats , bool optimiseMemory , const OptionFlags & options = { } )"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar::program","Name":"poplar::program::dumpProgram(const poplar::Graph &, const poplar::program::Program &, std::ostream &)","Filename":"poplar/Program.hpp","Text":"void dumpProgram ( const Graph & graph , const Program & program , std :: ostream & out )"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::VariableRef::VariableRef()","Filename":"poplar/VariableRef.hpp","Text":"VariableRef ( ) = default"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::VariableRef::VariableRef(poplar::VariableRef &&)","Filename":"poplar/VariableRef.hpp","Text":"VariableRef ( VariableRef && other ) = default"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::VariableRef::operator=(const poplar::VariableRef &)","Filename":"poplar/VariableRef.hpp","Text":"VariableRef & operator = ( const VariableRef & other ) = default"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::VariableRef::operator=(poplar::VariableRef &&)","Filename":"poplar/VariableRef.hpp","Text":"VariableRef & operator = ( VariableRef && other ) = default"}
{"Token type":"FunctionDecl","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::VariableRef::operator==(const poplar::VariableRef &, const poplar::VariableRef &)","Filename":"poplar/VariableRef.hpp","Text":"friend bool operator == ( const VariableRef & a , const VariableRef & b )"}
{"Token type":"FunctionDecl","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::VariableRef::operator<(const poplar::VariableRef &, const poplar::VariableRef &)","Filename":"poplar/VariableRef.hpp","Text":"friend bool operator < ( const VariableRef & a , const VariableRef & b )"}
{"Token type":"CXXConstructor","FaliureReason":"default_constructor","Implemented":false,"Namespace":"poplar","Name":"poplar::VariableInterval::VariableInterval()","Filename":"poplar/VariableRef.hpp","Text":"VariableInterval ( ) = default"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::VariableInterval::VariableInterval(poplar::VariableInterval &&)","Filename":"poplar/VariableRef.hpp","Text":"VariableInterval ( VariableInterval && other ) = default"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::VariableInterval::operator=(const poplar::VariableInterval &)","Filename":"poplar/VariableRef.hpp","Text":"VariableInterval & operator = ( const VariableInterval & other ) = default"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::VariableInterval::operator=(poplar::VariableInterval &&)","Filename":"poplar/VariableRef.hpp","Text":"VariableInterval & operator = ( VariableInterval && other ) = default"}
{"Token type":"FunctionDecl","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::operator==(const poplar::VariableInterval &, const poplar::VariableInterval &)","Filename":"poplar/VariableRef.hpp","Text":"bool operator == ( const VariableInterval & a , const VariableInterval & b )"}
{"Token type":"FunctionDecl","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::operator<(const poplar::VariableInterval &, const poplar::VariableInterval &)","Filename":"poplar/VariableRef.hpp","Text":"bool operator < ( const VariableInterval & a , const VariableInterval & b )"}
{"Token type":"StructDecl","FaliureReason":"not_allowed_namespace","Implemented":false,"Namespace":"std","Name":"std::hash<poplar::VariableRef>","Filename":"poplar/VariableRef.hpp","Text":"template < > struct hash < poplar :: VariableRef > { size_t operator ( ) ( const poplar :: VariableRef & v ) const { return v . hash ( ) ; } }"}
{"Token type":"CXXMethod","FaliureReason":"not_allowed_namespace","Implemented":false,"Namespace":"std","Name":"std::hash<poplar::VariableRef>::operator()(const poplar::VariableRef &)","Filename":"poplar/VariableRef.hpp","Text":"size_t operator ( ) ( const poplar :: VariableRef & v ) const"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar::layout","Name":"poplar::layout::operator<<(std::ostream &, const poplar::layout::Vector)","Filename":"poplar/VectorLayout.hpp","Text":"std :: ostream & operator << ( std :: ostream & os , const Vector v )"}
{"Token type":"FunctionDecl","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar::layout","Name":"poplar::layout::operator<<(std::ostream &, const poplar::layout::VectorList)","Filename":"poplar/VectorLayout.hpp","Text":"std :: ostream & operator << ( std :: ostream & os , const VectorList v )"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::VertexIntrospector","Filename":"poplar/VertexIntrospector.hpp","Text":"class VertexIntrospector"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::FieldData","Filename":"poplar/VertexIntrospector.hpp","Text":"class FieldData"}
{"Token type":"CXXMethod","FaliureReason":"filedata_size_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldData::SizeT::size()","Filename":"poplar/VertexIntrospector.hpp","Text":"std :: size_t size ( ) const"}
{"Token type":"CXXConstructor","FaliureReason":"deleted_method","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldData::FieldData(const poplar::FieldData &)","Filename":"poplar/VertexIntrospector.hpp","Text":"FieldData ( const FieldData & ) = delete"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldData::FieldData(poplar::FieldData &&)","Filename":"poplar/VertexIntrospector.hpp","Text":"FieldData ( FieldData && )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldData::operator[](std::size_t)","Filename":"poplar/VertexIntrospector.hpp","Text":"SizeT operator [ ] ( std :: size_t i ) const"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldData::getInitialValue(const poplar::Target &)","Filename":"poplar/VertexIntrospector.hpp","Text":"template < typename T > T getInitialValue ( const Target & target ) const"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldData::getInitialValues(const poplar::Target &)","Filename":"poplar/VertexIntrospector.hpp","Text":"template < typename T > std :: vector < T > getInitialValues ( const Target & target ) const"}
{"Token type":"CXXConstructor","FaliureReason":"unique_ptr_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldData::FieldData(std::unique_ptr<core::FieldData>)","Filename":"poplar/VertexIntrospector.hpp","Text":"FieldData ( std :: unique_ptr < core :: FieldData > fd )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldData::getInitialValuesOverload(const poplar::Target &, std::vector<T> &)","Filename":"poplar/VertexIntrospector.hpp","Text":"template < typename T > void getInitialValuesOverload ( const Target & target , std :: vector < T > & result ) const"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldData::getInitialValuesOverload(const poplar::Target &, std::vector<std::vector<T> > &)","Filename":"poplar/VertexIntrospector.hpp","Text":"template < typename T > void getInitialValuesOverload ( const Target & target , std :: vector < std :: vector < T >> & result ) const"}
{"Token type":"CXXMethod","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::FieldData::getInitialValues(const poplar::Target &, void *, const poplar::TypeTraits &, std::size_t)","Filename":"poplar/VertexIntrospector.hpp","Text":"void getInitialValues ( const Target & target , void * dst , const TypeTraits & traits , std :: size_t index = std :: numeric_limits < std :: size_t > :: max ( ) ) const"}
{"Token type":"CXXConstructor","FaliureReason":"unique_ptr_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::VertexIntrospector::VertexIntrospector(std::unique_ptr<core::VertexIntrospector>)","Filename":"poplar/VertexIntrospector.hpp","Text":"VertexIntrospector ( std :: unique_ptr < core :: VertexIntrospector > impl )"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::VertexIntrospector::VertexIntrospector(poplar::VertexIntrospector &&)","Filename":"poplar/VertexIntrospector.hpp","Text":"VertexIntrospector ( VertexIntrospector && )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::VertexIntrospector::getImpl()","Filename":"poplar/VertexIntrospector.hpp","Text":"const core :: VertexIntrospector & getImpl ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::replication_factor::operator++()","Filename":"poplar/replication_factor.hpp","Text":"replication_factor & operator ++ ( )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::replication_factor::operator==(const poplar::replication_factor)","Filename":"poplar/replication_factor.hpp","Text":"bool operator == ( const replication_factor other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::replication_factor::operator!=(const poplar::replication_factor)","Filename":"poplar/replication_factor.hpp","Text":"bool operator != ( const replication_factor other ) const"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::replication_factor::operator<(const poplar::replication_factor)","Filename":"poplar/replication_factor.hpp","Text":"bool operator < ( const replication_factor other ) const"}
{"Token type":"ClassDecl","FaliureReason":"skip_empty_classdecl","Implemented":false,"Namespace":"poplar::core","Name":"poplar::core::GraphBuilder","Filename":"poplar/Graph.hpp","Text":"class GraphBuilder"}
{"Token type":"CXXConstructor","FaliureReason":"rvalue_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::Graph(poplar::Graph &&)","Filename":"poplar/Graph.hpp","Text":"Graph ( Graph && )"}
{"Token type":"CXXMethod","FaliureReason":"operator_unsupported","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::operator=(poplar::Graph &&)","Filename":"poplar/Graph.hpp","Text":"Graph & operator = ( Graph && )"}
{"Token type":"CXXMethod","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::addCodelets(poplar::StringRef, poplar::CodeletFileType, poplar::StringRef, std::ostream &)","Filename":"poplar/Graph.hpp","Text":"bool addCodelets ( StringRef src , CodeletFileType type , StringRef compileFlags , std :: ostream & compileOutput )"}
{"Token type":"CXXMethod","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::addCodelets(std::stringstream &, poplar::StringRef, std::ostream &)","Filename":"poplar/Graph.hpp","Text":"void addCodelets ( std :: stringstream & stream , StringRef compileFlags , std :: ostream & compileOutput )"}
{"Token type":"EnumDecl","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::ConnectionDesc::Kind","Filename":"poplar/Graph.hpp","Text":"enum class Kind { TensorEdge , ValueEdge , VectorTensorEdge }"}
{"Token type":"EnumConstantDecl","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::ConnectionDesc::Kind::TensorEdge","Filename":"poplar/Graph.hpp","Text":"TensorEdge"}
{"Token type":"EnumConstantDecl","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::ConnectionDesc::Kind::ValueEdge","Filename":"poplar/Graph.hpp","Text":"ValueEdge"}
{"Token type":"EnumConstantDecl","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::ConnectionDesc::Kind::VectorTensorEdge","Filename":"poplar/Graph.hpp","Text":"VectorTensorEdge"}
{"Token type":"CXXMethod","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::ConnectionDesc::connect(poplar::Graph &, const poplar::VertexRef &)","Filename":"poplar/Graph.hpp","Text":"void connect ( Graph & g , const VertexRef & v ) const"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::ConnectionDesc::ConnectionDesc(poplar::StringRef, T, typename std::enable_if<TypeTraits::isSimpleType<T>()>::type *)","Filename":"poplar/Graph.hpp","Text":"template < typename T > ConnectionDesc ( StringRef field , T v , typename std :: enable_if < TypeTraits :: isSimpleType < T > ( ) > :: type * = nullptr )"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::addConstant(const poplar::Type &, ArrayRef<std::size_t>, T, const poplar::DebugContext &, typename std::enable_if<TypeTraits::isSimpleType<T>()>::type *)","Filename":"poplar/Graph.hpp","Text":"template < typename T > Tensor addConstant ( const Type & type , ArrayRef < std :: size_t > shape , T val , const DebugContext & debugContext = { \"<const>\" } , typename std :: enable_if < TypeTraits :: isSimpleType < T > ( ) > :: type * = nullptr )"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::addConstant(const poplar::Type &, ArrayRef<std::size_t>, const T *, const poplar::DebugContext &, typename std::enable_if<TypeTraits::isSimpleType<T>()>::type *)","Filename":"poplar/Graph.hpp","Text":"template < typename T > Tensor addConstant ( const Type & type , ArrayRef < std :: size_t > shape , const T * val , const DebugContext & debugContext = { \"<const>\" } , typename std :: enable_if < TypeTraits :: isSimpleType < T > ( ) > :: type * = nullptr )"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::connect(poplar::FieldRef, T, typename std::enable_if<TypeTraits::isSimpleType<T>()>::type *)","Filename":"poplar/Graph.hpp","Text":"template < typename T > void connect ( FieldRef field , T v , typename std :: enable_if < TypeTraits :: isSimpleType < T > ( ) > :: type * = nullptr )"}
{"Token type":"CXXMethod","FaliureReason":"calls_deleted_function","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::registerCycleEstimator(poplar::StringRef, poplar::CycleEstimateFunc)","Filename":"poplar/Graph.hpp","Text":"void registerCycleEstimator ( StringRef vertexTypeName , CycleEstimateFunc f )"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::setInitialValue(poplar::FieldRef, T, typename std::enable_if<TypeTraits::isSimpleType<T>()>::type *)","Filename":"poplar/Graph.hpp","Text":"template < typename T > void setInitialValue ( FieldRef field , T val , typename std :: enable_if < TypeTraits :: isSimpleType < T > ( ) > :: type * = nullptr )"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::setInitCallback(poplar::FieldRef, LateInitCallback<T>, typename std::enable_if<std::is_arithmetic<T>::value>::type *)","Filename":"poplar/Graph.hpp","Text":"template < typename T > void setInitCallback ( FieldRef field , LateInitCallback < T > callback , typename std :: enable_if < std :: is_arithmetic < T > :: value > :: type * = nullptr )"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::setInitialValue(poplar::FieldRef, const std::vector<T> &)","Filename":"poplar/Graph.hpp","Text":"template < typename T > void setInitialValue ( FieldRef field , const std :: vector < T > & v )"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::setInitialValue(poplar::FieldRef, const std::initializer_list<T> &)","Filename":"poplar/Graph.hpp","Text":"template < typename T > void setInitialValue ( FieldRef field , const std :: initializer_list < T > & l )"}
{"Token type":"FunctionTemplate","FaliureReason":"unsupported_template","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::setInitialValue(const poplar::Tensor &, T, typename std::enable_if<TypeTraits::isSimpleType<T>()>::type *)","Filename":"poplar/Graph.hpp","Text":"template < typename T > void setInitialValue ( const Tensor & t , T val , typename std :: enable_if < TypeTraits :: isSimpleType < T > ( ) > :: type * = nullptr )"}
{"Token type":"CXXMethod","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::outputVertexGraph(std::ostream &, ArrayRef<program::Program>)","Filename":"poplar/Graph.hpp","Text":"void outputVertexGraph ( std :: ostream & outputStream , ArrayRef < program :: Program > progs = { } ) const"}
{"Token type":"CXXMethod","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::outputComputeGraph(std::ostream &, ArrayRef<program::Program>)","Filename":"poplar/Graph.hpp","Text":"void outputComputeGraph ( std :: ostream & outputStream , ArrayRef < program :: Program > progs = { } ) const"}
{"Token type":"CXXMethod","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::serializeTensors(std::ostream &, ArrayRef<poplar::Tensor>, poplar::SerializationFormat)","Filename":"poplar/Graph.hpp","Text":"void serializeTensors ( std :: ostream & out , ArrayRef < Tensor > tensors , SerializationFormat format ) const"}
{"Token type":"CXXMethod","FaliureReason":"istream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::deserializeTensors(std::istream &, poplar::SerializationFormat)","Filename":"poplar/Graph.hpp","Text":"std :: vector < Tensor > deserializeTensors ( std :: istream & in , SerializationFormat format )"}
{"Token type":"CXXMethod","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::serialize(std::ostream &, poplar::SerializationFormat)","Filename":"poplar/Graph.hpp","Text":"void serialize ( std :: ostream & out , SerializationFormat format ) const"}
{"Token type":"CXXMethod","FaliureReason":"ostream_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::serialize(std::ostream &, ArrayRef<program::Program>, poplar::SerializationFormat)","Filename":"poplar/Graph.hpp","Text":"void serialize ( std :: ostream & out , ArrayRef < program :: Program > progs , SerializationFormat format ) const"}
{"Token type":"CXXConstructor","FaliureReason":"unique_ptr_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::Graph(std::unique_ptr<core::GraphBuilder>, poplar::Target)","Filename":"poplar/Graph.hpp","Text":"Graph ( std :: unique_ptr < core :: GraphBuilder > , Target target )"}
{"Token type":"CXXMethod","FaliureReason":"getimpl_blacklist","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::getImpl()","Filename":"poplar/Graph.hpp","Text":"core :: GraphBuilder & getImpl ( ) const"}
{"Token type":"CXXMethod","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::setInitialValue(poplar::FieldRef, const void *, const poplar::TypeTraits &)","Filename":"poplar/Graph.hpp","Text":"void setInitialValue ( FieldRef field , const void * val , const TypeTraits & )"}
{"Token type":"FunctionTemplate","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::setInitCallback(poplar::FieldRef, LateInitCallback<T>, const poplar::TypeTraits &)","Filename":"poplar/Graph.hpp","Text":"template < typename T > void setInitCallback ( FieldRef field , LateInitCallback < T > callback , const TypeTraits & )"}
{"Token type":"CXXMethod","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::setInitialValue(const poplar::Tensor &, const void *, const poplar::TypeTraits &)","Filename":"poplar/Graph.hpp","Text":"void setInitialValue ( const Tensor & t , const void * val , const TypeTraits & )"}
{"Token type":"CXXMethod","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::connect(poplar::FieldRef, void *, const poplar::TypeTraits &)","Filename":"poplar/Graph.hpp","Text":"void connect ( FieldRef field , void * val , const TypeTraits & )"}
{"Token type":"CXXMethod","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::checkFieldSubgraph(const poplar::FieldRef &)","Filename":"poplar/Graph.hpp","Text":"void checkFieldSubgraph ( const FieldRef & f ) const"}
{"Token type":"CXXMethod","FaliureReason":"insufficient_access","Implemented":false,"Namespace":"poplar","Name":"poplar::Graph::checkVertexSubgraph(const poplar::VertexRef &)","Filename":"poplar/Graph.hpp","Text":"void checkVertexSubgraph ( const VertexRef & v ) const"}
{"Token type":"FunctionDecl","FaliureReason":"","Implemented":true,"Namespace":"popops","Name":"popops::addCodelets(poplar::Graph &)","Filename":"popops/codelets.hpp","Text":"void addCodelets ( poplar :: Graph & graph )"}
